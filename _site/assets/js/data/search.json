[
  
  {
    "title": "문자열 - 아호 코라식(Aho-Corasick)",
    "url": "/posts/aho-corasick/",
    "categories": "BOJ",
    "tags": "아호 코라식, 문자열",
    "date": "2024-07-17 00:00:00 +0900",
    "content": "아호 코라식(Aho-Corasick)에 대해 알아보자.  개요 문자열 알고리즘은 어렵다.  트라이 부터 조금 어려워지다가 KMP의 failure function, 접미사 배열 등이 나오면서 대가리가 깨진다.  하나씩 차근차근 정리를 해보려고 한다.  지금 클래스 8을 풀다가 문자열 집합 판결이라는 문제에서 막혔는데 태그를 까보니 아호 코라식이 써 있었다. 이 문제를 계기로 아호 코라식을 정리해 보겠다.  언제 쓰지? 일단 KMP같은 경우엔 Hay(건초)에서 Needle(바늘)이 몇 개, 어디에 있는지 찾을 수 있다.  인터넷에서 ctrl + f를 누르고 어떤 패턴의 문자열을 찾는 식이다.  그니깐, 하나의 패턴만 찾을 수 있다는 것이다.  그럼 어떤 큰 문자열에 dosa, was, hi 등의 문자열이 있는지 확인하려면 KMP 알고리즘으로는 dosa를 needle로 한번, was를 needle로 또 한번, 마지막으로 hi를 needle로 총 3번의 KMP를 돌릴 것이다.  아호 코라식은 좀 다르다.  여러 패턴들이 어떤 큰 문자열에 있는지 한번에 확인할 수 있다.  시간 복잡도 아직 공부를 마치지 않았지만 어떤 문자열 S에서 $w_1,w_2,\\cdots, w_n$ 의 문자열이 있는지 확인한다고 하면 \\(O(len(S) + len(w_{1})+\\cdots+len(w_{n}))\\) 이 된다.  KMP가 쭉 한번만 훑으면서 검사하는 것과 굉장히 비슷한 시간복잡도를 가진다.  과정  알고리즘의 단계     트라이 생성:            주어진 모든 패턴 문자열을 사용하여 트라이를 만듭니다.           실패 링크 생성:            BFS(너비 우선 탐색)를 사용하여 트라이를 탐색하며 실패 링크를 설정합니다. 루트 노드의 자식 노드의 실패 링크는 루트 노드를 가리키도록 하고, 나머지 노드들은 그 부모 노드의 실패 링크를 따라 설정합니다.           검색(Search):            텍스트 문자열을 한 문자씩 읽으면서 트라이를 탐색합니다.       매칭이 실패하면 실패 링크를 따라가며 매칭을 계속 시도합니다.       매칭이 성공하면 출력 링크를 따라가며 결과를 출력합니다.           예시  패턴: [“he”, “she”, “his”, “hers”]  트라이 구성:           (root)          /  |  \\         h   s   h         |       |         e       i        / \\       \\       r   s       s      /           /     s           h   실패 링크 설정 후:           (root)          /  |  \\         h   s   h         |   |   |         e   e   i        / \\  |    \\       r   s s     s      /       |   /     s        h  h   텍스트: “ushers”  탐색 과정:    “u” -&gt; 매칭 실패, 루트로 돌아감.   ”s” -&gt; 매칭 성공, 다음 문자로 이동.   “h” -&gt; 매칭 성공, 다음 문자로 이동.   “e” -&gt; 매칭 성공, 다음 문자로 이동.   “r” -&gt; 매칭 성공, 다음 문자로 이동.   ”s” -&gt; 매칭 성공, 패턴 “hers” 매칭됨.   이와 같은 방법으로 아호 코라식 알고리즘은 효율적으로 다수의 패턴 문자열을 검색할 수 있다.  핵심적인 부분은    매칭을 성공했을 때 갈 곳(go)   매칭을 실패(fail) 했을 때 갈 곳   패턴이 다 나왔을 때 체크 을 잘 구현해야하는 것이다.   이 때 실패는 KMP의 실패함수와 논리구조가 똑같다.  내가 봐야하는 부분부터 볼 수 있게끔 도와준다.  구현 구현은 라이님 블로그를 참고했다. (진짜 초갓갓 블로그 중 하나다)  Trie 먼저 트라이 구현이다. struct Trie{     vector&lt;Trie *&gt; go; //성공     Trie *fail; // 실패     bool output; // 출력      Trie(){         go = vector&lt;Trie * &gt; (26, nullptr);         output = false;     }      ~Trie(){         for(int i=0;i&lt;26;i++) if(go[i]) delete go[i];     }      void insert(const string &amp; pattern, int idx){         if(idx == pattern.size()){             output = true;             return ;         }         int nxt = pattern[idx] - 'a';         if(!go[nxt]){             go[nxt] = new Trie;         }         go[nxt] -&gt; insert(pattern, idx + 1);     } };  이 트라이의 노드는 go, fail, output으로 구현이 되어있다.  fail BFS를 통해 실패함수를 만든다. 처음에 root노드가 들어오고 다음으로 갈 수 있다고 치면 그건 실패함수가 아니라 성공으로 이동해야하니까 넘긴다.  지금 어떤 노드 (nd)에서 패턴이 없어서 nxt(go)가 없으면 fail로 어디로 갈지 정해야한다.  nxt가 있을 때 까지 빠꾸 친다.(fail을 계속 따라간다) 그럼 nxt가 있으면 nxt -&gt; go[nd] 이 fail이 가리키는 곳이 된다. (지금 제가 한 말이 뭔가 가독성이 안좋은듯 ㅋㅋ)  근데 만약에 실패함수가 가리키는 곳이 어떤 패턴의 끝이라고 해보자.  그럼 그 패턴을 포함한다는 것이니까 nxt는 어떤 패턴을 포함한다라고 생각하면 된다.    BFS     // 실패함수 만들기  queue&lt;Trie *&gt; Q;  rt -&gt;fail = rt;  Q.push(rt);  while(!Q.empty()){      Trie * nd = Q.front();      Q.pop();       for(int i=0;i&lt;26;i++){          Trie * nxt = nd-&gt;go[i];          if(!nxt) continue;           if(nd == rt) nxt -&gt; fail = rt;          else{              Trie *dest = nd-&gt;fail;              while(dest != rt &amp;&amp; !dest-&gt;go[i]){                  dest = dest -&gt;fail;              }              if(dest -&gt; go[i]) dest = dest-&gt;go[i];              nxt -&gt; fail = dest;          }           if(nxt -&gt; fail -&gt; output) nxt -&gt; output = true;           Q.push(nxt);      }  }           다양한 패턴이 있는지 확인하는 작업 어떤 string s에 대해 패턴이 있는지 확인하는 부분이다. root에서 시작해서 s따라 쭉쭉 따라가면서 cur -&gt; output이 참이면 성공이다. int M; cin &gt;&gt; M;     while(M--){         string s; cin &gt;&gt; s;         bool ok = false;         Trie *cur = rt;         for(char c : s){             int nd = c - 'a';             while(cur != rt &amp;&amp; !cur-&gt;go[nd]){                 cur = cur -&gt; fail;             }             if(cur-&gt;go[nd]) cur = cur -&gt; go[nd];             if(cur -&gt; output){                 ok = true;                 break;             }         }         cout &lt;&lt; (ok ? \"YES\\n\" : \"NO\\n\");     }   결론 구현이 굉장히 깔끔하고 KMP의 Trie 버전이다.  좀 멋있는 것 같다.  KMP도 Trie 자료구조도 다 어려웠는데 그 둘을 합친 느낌의 알고리즘이라니… 어렵지만 재밌다. 그래도 여러 패턴과 매칭을 할 때 쓴다는 것은 확실히 알았으니 문제에 적용할 수 있을 것 같다.  다음엔 suffix array를 좀 정리해보려고 한다. 저번에 하려다가 뭔소린지 잘 모르겠어서 그냥 안했었는데 좀 해라..나란 놈아"
  },
  
  {
    "title": "docker 이해해보기",
    "url": "/posts/docker-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/",
    "categories": "CS",
    "tags": "docker",
    "date": "2024-06-12 00:00:00 +0900",
    "content": "docker를 이해해보자  프로젝트를 제대로 배포해보지 않은 입장에서 docker는 뭔가 개념자체가 잘 와닿지 않았다.  그래서 직접 정리를 하며 docker, k8s, jenkins에 대해 각각 한페이지짜리 정리를 해보려한다.  개요 일단 내가 어떤 Web Service를 개발했는데, 이것이 누군가의 환경에서는 동작하지 않을 수가 있다. 이는 여러 이유가 있겠지만, 한마디로 dependencies가 달라서라고 할 수 있다.  매우 쉬운 예시로, 파이썬으로 Hello world를 출력하는 프로그램을 만들었는데 다른 컴퓨터에서 실행하려니 파이썬이 안깔려있는 상황인 것이다.     개발환경과 운영환경의 불일치가 있고   매우 가벼운 실행 패키지가 필요해졌다.   그래서 등장한 것이 Containerization이다.  Docker Docker는 Docker사의 Container engine을 뜻한다.  Container engine이라는 것은 OS level에서 virtualization을 해서 software package를 deliver하는 것을 뜻한다.  각 환경에 따른 가상머신에 앱을 설치하고 실행하는 것이 아닌 OS와 interface한 container라는 곳에서 앱을 실행시킨다.  VM은 메모리 점유가 심하고, 부팅 시간이 느리며 성능저하도 있다. 또한 VM사이에서 데이터 공유도 힘들다.  반면 container를 사용하면 이 모든 단점이 해결된다.     다양한 화물들을 일정한 규격의 컨테이너에 적재한다. (interface)   컨테이너를 항구에 내린다. (VM에 container 데려와서)   컨테이너를 부리고 원하는 작업을 수행한다. (app 실행)    container engine에는 OS kernel같은게 있는 것이 아니다.  저런 image를 가지고 어디든 가서 앱을 실행시킬 수 있게 된다.  그럼 여기까지 보면 image와 container의 차이가 헷갈리게 된다.  image vs Container  이 그림을 보면 image와 container의 차이를 잘 느낄 수 있다.  image는 정적인 파일이다. 그러니깐 정적인 코드를 지니고 있다.  image를 가지고 containerization platform에 가면 run시킬 수 있는 것이다.  즉, template의 역할을 한다. (app code, sw system, os)  container = running instance of an image  image는 레시피, container는 만들어진 요리가 된다.  container는 stop, delete할 수 있는데 stop하면 먹다가 냉장고에 넣는 것이고 delete면 다 먹었거나 버린 것이 되겠다.  Docker hub에는 매우 많은 image들이 떠돌아 댕기고 있다. 가져와서 나의 컴퓨터에 컨테이너를 내리고 앱을 실행시킬 수 있다.  예시 코드 docker pull ubuntu docker images # 내게 있는 이미지들을 볼 수 있다. docker run -it -d ubuntu  #1. `-i` (interactive): 컨테이너가 실행되는 동안 입력을 받을 수 있게 합니다.   # 2. `-t` (tty): 이 옵션은 가상 터미널을 할당합니다. 이것은 `-i` 옵션과 함께 사용되어야 하며, 인터랙티브 쉘 세션을 가지기 위해 필요합니다.  # 3. `-d` (detached): 이 옵션은 컨테이너를 백그라운드에서 실행하도록 합니다.  docker ps # 실행되고 있는 컨테이너들을 확인할 수 있다.  # exec docker exec -it &lt;container id&gt; &lt;prompt in the container&gt;  # container에 있는 bash shell을 실행할 때 쓴다.  # stop docker stop &lt;container id&gt; docker kill &lt;container id&gt; docker ps -a  # remove (container와 image 지우기) docker rm -f &lt;container id&gt; docker rmi -f &lt;image id&gt;   docker file 위의 그림에서 docker file만 다루지 않았다.  docker hub에서 가져올 수만 있다면 내가 원하는 기능을 찾지 못할 수도 있다.  docker file은 docker image를 만들기 위해 실행하는 command 들을 모아 둔 text 파일이다.     docker image를 만드는 방법            docker hub에서 가져와서 내 맘대로 바꾸는 명령을 실행한다음 push한다.       dockerfile을 작성하고 build한다. dockerfile은 단순한 text파일로서 크기가 작다.           예시에 주석을 달아서 설명하겠다. # base이미지로 ubuntu를 사용 FROM ubuntu   # Update package lists RUN apt-get update  #이는 docker run과는 전혀다른 RUN이다. 명령어를 보면 알 수 있다.  # intall Apache2 RUN apt-get install -y apache2  # Add files 현재 디렉토리에서 &lt;dest in container&gt;로 파일 복사 (Copy) ADD . /var/www/html  # Expose port 80 for HTTP traffic EXPOSE 80  # Start Apache2 in the foreground ENTRYPOINT [\"apache2ctl\", \"-D\", \"FOREGROUND\"]  마지막 ENTRYPOINT를 조금 설명해보겠다.  CMD라는 명령으로 container 안에서 실행하려는 command를 써둘 수 있는데 ENTRYPOINT를 쓰면 이와 유사하지만 다른 command를 입력해서 docker file의 CMD에 지정된 명령을 생략할 수 없게 할 때 사용한다.  위 dockerfile을 image로 만드는 것은 어떻게 하는가? vi dockerfile #이름은 반드시 dockerfile이여야한다.  docker rm -f &lt;existing container&gt; docker build -t &lt;image name&gt; # 이 과정이 image를 dockerfile로부터 만드는것이다.  docker run -it -p &lt;hostport:containerport&gt; -d &lt;image&gt;  docker rm -f &lt;exeisting container&gt; # port 80에 충돌이 생기지 않게 하기 위해서   p는 published로 호스트 port와 container port를 mapping할 때 쓴다. 외부에서 컨테이너에 접근할 수 있게 된다. docker volume 여기까지 어찌저찌 이해했다. 근데 만약에 앱을 실행할 때 변경사항을 저장할 필요가 있다면 어떨까? 특히 DB를 사용하는 컨테이너라면 저장이 필수일것이다.  컨테이너는 read-only app으로 사용하는게 기본이다.  왜냐면 컨테이너 각자가 자신만의 OS자원, DRAM영역, cpu시간을 가지고 있고 디스크 같은 persistent storage를 사용하지 않기 때문이다.  여기서 persistent storage를 사용하기 위해 이를 host machine에서 mount해온다.  이것이 docker volume이다.  하지만 이 행위는 보안의 입장에서는 안 좋을 수 있다.  Three types of docker volumes    Host volume - docker run -v /home/mount/data:/var/lib/mysql/data 처럼 사용   anonymous volume - host를 지정하지 않으면 알아서 정해진 폴더에 생성(random hash)   named volume - 생성된 볼륨에 이름을 붙여서 여러 컨테이너가 이름을 통해 공유   docker compose  docker container는 하나의 image만을 실행하는 것이 원칙? 권장된다.  따라서 container들을 여러개가 같이 실행되는 때가 더 많을 것이다.  여기서 docker compose가 등장한다.  이 것은 docker-compose.yml 파일을 실행, 중지, 제거 하는 도구다.  docker-compose.yml에는 한 개 이상의 container를 규정하고 run하는 내용이 담겨있다.     docker-compose.yml 파일을 만든다.   version: '3' services:   web:     image: nginx     ports:       - \"80:80\"   db:     image: mysql     environment:       MYSQL_ROOT_PASSWORD: example   위와 같은 파일을 만들고    inbound rule을 변경해서 외부에서 접근할 수 있게 한다.   docker-compose up -d            build하고 run       새로운 설정이 있으면 container를 재시작하지 않고 적용시킨다.       -d하면 log를 안 볼 수 있음           docker-compose stop   docker-compose down (–volumes)            이건 stop과 달리 리소스까지 다 제거하는 것이다.           docker volume ls   docker volume inspect &lt;volume name&gt;   docker volume rm &lt;volume name&gt;   yml파일에 volume 적용되어 있으면 알아서 잘 저장 될 것이다.  docker network compose를 하려면 docker container들 사이에 연결이 있어야한다.  즉, 서로 네트워크로 연결되어 통신해야한다는 것이다.  도커가 해준다.  1) bridge– default– virtual L2 switch - each container has its own private IP address    2) host– host의 네트워크와 동일한 네트워크 사용    3) overlay– docker swarm service 네트워크 – conventional overlay network (i.e., conventional virtual network)    4) macvlan– MAC 주소에 대한 완전한 제어 제공 – each container has its own MAC address+IP address    5) ipvlan– IP 주소 사용에 대한 완전한 제어를 제공 – each container has its own IP address sharing MAC with others   6) none– no network interface provided for full customization  namespace &amp; cgroup  컨테이너의 목적을 생각해보자. “단일 호스트 (VM 포함) 에서 서로 독립적으로 분리 운영되는 프로세스 그룹을 만드는 것 (VM을 만드는 것이 아님)” 이를 위해서 namespace와 cgroup 위에 docker container가 만들어진다.  namespace process trees, network interfaces, user IDs, filesystem mounts 등 시스템 요소들의 경계를 긋고 제한하는 mechanism이다.  Cgroup  Cgroups는 각 프로세스 그룹에 OS 자원을 배정하고 측정하는 커널 장치 Cgroups를 사용하여 CPU time, network, memory, block io 같은 자원을배정 namespaces에 cgroups를 적용하여 일단의 프로세스들을 container로 구성하여 해당 프로세스들만의 virtual 시스템 구현"
  },
  
  {
    "title": "염소줄서기 문제 풀이",
    "url": "/posts/2060-%EC%97%BC%EC%86%8C%EC%A4%84%EC%84%9C%EA%B8%B0-%ED%92%80%EC%9D%B4/",
    "categories": "BOJ",
    "tags": "2060, 염소줄서기, 백준, 이분탐색",
    "date": "2024-04-20 00:00:00 +0900",
    "content": "2060 염소줄서기 풀이 및 코드  개요 오랜만에 다이아 문제 풀이를 써보려고 한다.  이 문제는 내가 옛날에 북마크 해뒀던 문젠데 북마크에서 거의 1년간 썩어가고 있어서 속상해서 선택했다.  문제 이해가 어렵지 않아서 선택한 것도 있다.  다이아 문제를 하루에 하나씩 풀면 엄청난 도움이 되겠지만 블로그 풀이를 안보면 하루에 하나는 무슨 일주일에 하나도 힘들것이다. 그래도 1일 1플레는 도전을 해봐야겠다.  문제 이해 염소들 번호가 있는데 밥먹는 순서는 다음과 같다. 염소번호를 이진수로 나타냈을 때    1의 개수가 적을 수록 먼저먹는다.   1의 개수가 같다면 그냥 이진수 크기가 더 작은 염소가 먼저 먹는다.   이진수로 A부터 B까지의 염소가 있을 때, k번째 밥을 먹는 염소는 몇 번 친구인가?  Naive한 풀이         당연히 정렬을 생각할 수 있다.  하지만 1의 개수가 최대 31개, 따라서 integer형 범위를 모두 포함한다면 약 20억이다. $A = 0$, $B = 2^{32} - 1$ 이라면 절대 순수하게 정렬할 수는 없을 것이다.           손으로 하는 풀이 내가 내 눈과 손으로 답을 구할 때는 먼저 1의 개수가 작은 것부터 보면서 counting을 했다.  1의 개수가 1개인것이 $a_1$개 2개 인것이 $a_2$ 개 .. 이런식으로 생각하면서 k를 줄여나갔다.      풀이 세 단계로 풀이를 세웠다.    1의 개수가 $i$개인 염소의 수를 dp table에 전처리 해둔다.($0 \\leq i \\leq 31$)   dp table의 누적합을 이용해 k번째 염소가 몇개의 1이 있는지 확인한다.   c개의 1이 있는 염소들 중 k - 어쩌구 번째 친구를 구한다.   1단계    rnk(i, X) : X보다 작은 1의 개수가 i개인 수의 개수   A와 B가 고정이기 때문에 rnk(i, B) - rnk(i, A-1)을 하면 i별로 1의 개수가 i개인 염소의 수를 구할 수 있다. rnk(i, X) 예를 들어 1001011보다 작은 1의 개수가 5개인 수들을 구해보자! 아래 예시에서 첫번째 요소를 볼때 0이 오는지 1이 오는지에 따라 경우의 수를 세줄 수 있다.    즉, 1을 만났을 때 $\\binom{이후 자리수}{남은 1의 수}$ 를 더해주면 된다.  ll rnk(int cnt, string s){     ll ret = 0, one = 0;     for(int i=0;i&lt;s.length();i++){         if (s[i] == '1') one++;     }     for(int i=0;i&lt;s.length();i++){         if ((s.length() - i == one) || one == 0 || cnt == 0){             ret += binom(one, cnt);             break;         }         if(s[i] == '1'){             ret += binom(s.length()-i-1, cnt);             one -= 1;             cnt -= 1;         }     }     return ret; }  이렇게 rnk함수를 구할 수 있었다. binom함수는 2차원 dp로 구현했다. 처음에 one == 0, cnt == 0이 되는 경우를 처리하지 않아서 계속 틀렸다. 2단계 누적합을 이용하면 $O(31)$ 이내에 간단하게 몇개의 비트를 쓰는지 확인할 수 있다. for(int i=0;i&lt;32;i++){ \tdp[i] = ((i == 0) ? 0 : dp[i-1]) + dp[i]; } int c = 0; ll kk = 0; for(int i=0;i&lt;32;i++){ \tif(dp[i] &gt;= k) break; \tc = i; \tkk = dp[i]; } k -= kk;  k번째 수가 c개의 비트를 가지고 있다는 뜻이고 kk는 지금까지 건너뛴 염소들의 수다.  이제 A와 B사이에 있는 c개의 비트를 가진 수들 중에서 k(-= kk)번째 수를 구하면 된다. 3단계 사실 이 과정에서 막혔다… c개의 비트를 가진 수들 중에서 k번째 수를 어떻게 구할까..? 근데 잘 생각해보니 그냥 아까의 rnk함수를 이용해서 이분탐색을 하면 됐다.  왜냐면 x보다 작은 1의 개수가 c인 수는 정렬되어있기 때문이다.  그리고 그것이 변하는 순간은 무조건 c개의 비트를 가지고 있는것이 명확하기 때문에 제일 먼저 k가 나오는 순간을 포착하면 답이 된다.  전체 코드 #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; typedef tuple&lt;ll, ll, ll&gt; tlll; #define xx first #define yy second  ll comb[32][32];  ll binom(int n, int k){     if(n &lt; k) return 0;     if(k == 0 || n == k) return 1;     ll &amp;ret = comb[n][k];     if(ret != -1) return ret;     ret = binom(n-1, k) + binom(n-1, k-1);     return ret; }  ll rnk(int cnt, string s){     ll ret = 0, one = 0;     for(int i=0;i&lt;s.length();i++){         if (s[i] == '1') one++;     }     for(int i=0;i&lt;s.length();i++){         if ((s.length() - i == one) || one == 0 || cnt == 0){             ret += binom(one, cnt);             break;         }         if(s[i] == '1'){             ret += binom(s.length()-i-1, cnt);             one -= 1;             cnt -= 1;         }     }     return ret; }  string to_binary(ll x){     if(!x) return \"0\";     string ret = \"\";     while(x){         ret += (x % 2) + '0';         x /= 2;     }     reverse(ret.begin(), ret.end());     return ret; }  ll to_ll(string s){     if(s == \"-1\") return -1;     ll ret = 0;     ll j = 1;     for(int i=s.length()-1;i&gt;=0;i--){         ret += j * (s[i] - '0');         j *= 2;     }     return ret; }  int main(){     fast_io     string A, B;     cin &gt;&gt; A &gt;&gt; B;     ll k; cin &gt;&gt; k;     assert (to_ll(B) - to_ll(A) + 1 &gt;= k);     memset(comb, -1, sizeof(comb));     if(A != \"0\"){         for (int i = A.length() - 1; i &gt;= 0; i--){             if (A[i] == '0') A[i] = '1';             else{                 A[i] = '0';                 if(i == 0){                     if(A.length() != 1) A.erase(A.begin());                 }                 break;             }         }     }else{         A = \"-1\";     }     vector&lt;ll&gt; dp(32, 0);     for(int i=0;i&lt;32;i++){         dp[i] = rnk(i, B) - (A == \"-1\" ? 0 : rnk(i, A));     }     for(int i=0;i&lt;32;i++){         dp[i] = ((i == 0) ? 0 : dp[i-1]) + dp[i];     }     int c = 0;     ll kk = 0;     for(int i=0;i&lt;32;i++){         c = i;         if(dp[i] &gt;= k) break;         kk = dp[i];     }     k -= kk;     ll lo = to_ll(A), hi = to_ll(B);     while(lo + 1 &lt; hi){         ll mid = (lo + hi) &gt;&gt; 1;         if(rnk(c, to_binary(mid)) - (A == \"-1\" ? 0 : rnk(c, A))&lt; k) lo = mid;         else hi = mid;     }     cout &lt;&lt; to_binary(hi); }  마무리 솔직히 엄청 어려운 알고리즘은 하나도 안들어간다.  진법 변환, 자릿수 dp, 이항계수, 누적합 등 매우 쉬운 알고리즘 들이다. 항상 보면 이런 자잘한 것들이 모여서 어려운 문제를 만들어낸다..ㅠㅠ 이 문제의 포인트는 누적합 논리인것 같다.  그리고 누적합에서는 이분탐색이 가능하다는 것도 잘 이용한 좋은 문제라고 생각한다."
  },
  
  {
    "title": "D&C Optimization",
    "url": "/posts/%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%B5%9C%EC%A0%81%ED%99%94(Divide-&-Conquer-Optimization)/",
    "categories": "BOJ",
    "tags": "dnc, 분할정복을 이용한 최적화",
    "date": "2024-04-08 00:00:00 +0900",
    "content": "분할정복을 이용한 다이나믹 프로그래밍 최적화  목적과 조건  목적     $O(KN^2)$ 의 알고리즘을 $O(KNlogN)$으로 시간복잡도를 줄이기 위함   조건  1. DP 점화식 $dp[i][j] = min_{k&lt;i}(dp[i-1][k] + C[k][j])$ 2. C의 조건 $C[i][j]$ 는 Monge array이거나 최적해의 단조성이 있어야한다. Monge array $C[a][b] + C[b][d] \\leq C[a][d] + C[b][c]$  인 배열이라는 뜻이다. $C[i][j]$ 를 $i, j$  사이에서의 비용이라고 하면 구간을 포함하면 더 비싼 배열이라고 보면 된다. (최솟값인지 최댓값인지에 따라 부등호 방향이 바뀜) 최적해의 단조성은 임의의 $c &lt; d$ 에 대해 $dp[i-1][k] + C[k][c]$ 를 최소화하는 k를 $k_c$ $dp[i-1][k] + C[k][d]$ 를 최소화하는 k를 $k_d$ 라고 하면 $k_{c}&lt;k_{d}$ 가 되는 것을 말한다.  이분탐색도 단조성이 있기 때문에 $O(N)$에서 $O(logN)$ 으로 줄일 수 있듯이 단조성이 있기 때문에 탐색범위를 줄일 수 있는 것이다.  예제 1 11001 김치  이 문제를 분석하면서 어떨 때 이 최적화를 쓸 수 있는지 확인해보자.     김치의 맛의 가치를 구하는 문제이다.  \t김치의 맛의 식은 다음과 같다.  \t$taste = time * temp + val_{ori}$ \t맛은 숙성시간 * 온도 + 원래 가치로 정의 된다.  \t$time = (꺼낸날 - 넣은날)$  \t$temp_{i} \\geq temp_{i+1}$ 온도는 점점 내려간다.      점화식 짜기 $dp[i]$ : i번째 날에 최대 김치 가치 $dp[i] = max_{\\substack{i-D \\leq j \\leq i}}{(i-j)t_{i}+ v_j}$   구현1 D&amp;C를 이용한 최적화 구현 기본적인 틀은 위의 링크와 같다. 그럼 이것을 이용해서 김치를 풀어보겠다. #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; typedef tuple&lt;ll, ll, ll&gt; tlll; #define xx first #define yy second  const int MAX = 1e5+1; ll m, n, d, T[MAX], V[MAX]; vector&lt;ll&gt; dp_cur;  ll C(ll i, ll j){     return (j - i) * T[j] + V[i]; }  void compute(ll l, ll r, ll optl, ll optr){     if(l &gt; r) return ;      ll mid = (l + r) &gt;&gt; 1;     pll best = {LLONG_MIN, -1};     for(ll k=max(optl, mid-d);k&lt;=min(mid, optr);k++){         best = max(best, {C(k, mid), k});     }     dp_cur[mid] = best.xx;     int opt = best.yy;      compute(l, mid-1, optl, opt);     compute(mid+1, r, opt, optr); }  ll solve(){     dp_cur.assign(n, 0);     for(int i=0;i&lt;m;i++){         compute(0, n-1, 0, n-1);     }     return *max_element(dp_cur.begin(), dp_cur.end()); }  int main(){     fast_io     m = 1;     cin &gt;&gt; n &gt;&gt; d;     for(int i=0;i&lt;n;i++) cin &gt;&gt; T[i];     for (int i = 0; i &lt; n; i++) cin &gt;&gt; V[i];     ll res = solve();     cout &lt;&lt; res; }  이 문제는 dp식을 한번만 구하면 된다.  사실 dp배열도 필요없고 최댓값만 구하면 되긴한다.  핵심은 $N \\times D$ 의 경우를 모두 계산하는게 아니라 $D \\times \\log N$  만큼만 계산하는 것이다. $O(N\\log N)$ 이라고 표현할 수 있을 것이다.  예제 2 18444 우체국 3 각 마을이 원형으로 V개 존재하고 V개의 마을 중 P곳에 우체국을 지으려고 한다.  이 때 우체국과 각 마을 사이의 거리의 합이 최소가 되도록하는 우체국 위치를 모두 구하는 문제다. 거리는 다음과 같은 식으로 구한다.  \\(C(x, y) = min(|y -x|, L - |y-x|)\\) 이 때 L은 마을 둘레의 길이다. \\  [\\begin{align} 1 \\leq P \\leq V \\leq 250 1 \\leq L \\leq 1e12 \\end{align}]  일단, 원형을 선형으로 바꿔서 풀기 위해 $2 \\times V$ 짜리 배열을 만든다. cost 전처리 그리고 Cost를 $O(V^3)$ 으로 전처리 해둔다. 그럼 $C[i][j]$ 의 배열이 뜻하는 것은 , i ~ j까지 우체국 하나를 썼을 때 드는 최소 비용이 된다. 최소 비용은 i ~ j의 중간에 있는 것이 무조건 최적의 값이 되기 때문에 cost의 전처리가 가능한 것이다. // cost 전처리 for(int i=1;i&lt;=2*V;i++){ \tfor(int j=i;j&lt;=2*V;j++){ \t\tint mid = (i + j) &gt;&gt; 1; \t\tfor(int k=i;k&lt;=j;k++) { \t\t\tC[i][j] += abs(pos[k] - pos[mid]); \t\t} \t} }  $1$ ~ $V$ , $2$ ~ $V + 1$, $\\cdots$  , $V$ ~ $2V$ 의 경우의 dp식을 업데이트 해줄 것이다. dp 식 dp[i][j] = 시작점부터 i까지 우체국을 j개 설치했을 때 최소 비용  이렇게 해두면 \\(\\begin{align*} dp(i, j) &amp;= dp(k, j-1) + C(k+1, i) (k&lt;i )\\\\ \\end{align*}\\) 이렇게 볼 수 있다. 최적화 i보다 작은 모든 k에 대해 검사하면 dp짜는데만 $O(N^2)$ 이다. 이를 최적화 해서 k값을 검사하는 것을 $O(N\\log N)$ 에 할 수 있게 되는 것이다. 구현 2 #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; typedef tuple&lt;ll, ll, ll&gt; tlll; #define xx first #define yy second  const int MAX = 501; const ll INF = 1e18+1; ll V, P, L, pos[MAX], C[MAX][MAX]; vector&lt;vector&lt;ll&gt;&gt; dp, recon; pair&lt;ll, vector&lt;ll&gt;&gt; res;  void dnc(ll x, int l, int r, int optl, int optr){     if(l &gt; r) return ;      int mid = (l+r) &gt;&gt; 1;     int opt = 1;     dp[mid][x] = INF;     for(int k = optl ; k &lt; min(mid, optr+1);k++){         if (dp[mid][x] &gt; dp[k][x - 1] + C[k+1][mid]){             dp[mid][x] = dp[k][x - 1] + C[k+1][mid];             opt = k;             recon[mid][x] = k ;         }                  }      dnc(x, l, mid - 1, optl, opt);     dnc(x, mid + 1, r, opt, optr); }  void reconstruct(int c, int i, int j){     if(!j){         return ;     }     ll posi = pos[(i +recon[i][j] + 1) &gt;&gt; 1];     if(posi &gt; L) posi -= L;     res.yy.push_back(posi);     reconstruct(c, recon[i][j], j-1); }  void solve(int cnt){     dp.assign(2*V+1, vector&lt;ll&gt;(2*V+1, 0));     recon.assign(2*V + 1, vector&lt;ll&gt;(2*V + 1, 0));     for (int i = 1; i &lt;= V; i++){         dp[cnt + i][1] = C[cnt + 1][cnt + i];         recon[cnt+i][1] = cnt + 1 ;     }      for(int i=2;i&lt;=P;i++){ // i개 설치 할 때          dnc(i, cnt + 1,cnt + V, cnt + 1 ,cnt + V);     }     if (res.xx &gt; dp[cnt + V][P]){         res.xx = dp[cnt + V][P];         res.yy.clear();         reconstruct(cnt, cnt + V, P);     } }  int main(){     fast_io     cin &gt;&gt; V &gt;&gt; P &gt;&gt; L;     for(int i=1;i&lt;=V;i++) {cin &gt;&gt; pos[i]; pos[i + V] = pos[i] + L;}     // cost 전처리     for(int i=1;i&lt;=2*V;i++){         for(int j=i;j&lt;=2*V;j++){             int mid = (i + j) &gt;&gt; 1;             for(int k=i;k&lt;=j;k++) {                 C[i][j] += abs(pos[k] - pos[mid]);             }         }     }     res.xx = INF;     // cnt마다 최솟값 구하기     for(int c = 0;c&lt;V;c++) solve(c);     cout &lt;&lt; res.xx &lt;&lt; '\\n';     sort(res.yy.begin(), res.yy.end());     for(ll ans : res.yy) cout &lt;&lt; ans &lt;&lt; ' '; }   내가 문제를 풀 때 실수로 좌표를 1 ~ L까지로보고 풀었는데 정답을 받았다.  데이터에 좌표가 0인 경우가 없었던것 같아서 추가 요청을 백준에 드렸다.  또 틀렸던 부분이 지금 내 코드는 recon이라는 배열로 이전의 우체국 위치를 추적하고 있는데 우체국이 1개밖에 없는 경우는 따로 처리하고 있는데 recon배열을 같이 처리하지 않은 실수를 했다. 또, opt값의 default 0으로 해서 배열에서 out_of_bound를 받았다.  이제 마지막 문제를 풀어보겠다. 예제 3 12766 지사배정 일단 i사에서 j사까지 메시지를 전달하려면 본사를 무조건 들러야한다.  또한 하위 프로젝트를 맡은 지사끼리만 연결되면 된다.  적절히 이동거리를 최소로 하도록 하위 프로젝트를 지사에 배정하면 된다. 이전 문제에서 우체국을 적절히 배치하는 것과 매우 비슷하다.  근데 우체국 문제는 마을들이 정렬이 되어있어 dp식을 짜기 편했다. 하지만 이 문제는 그래프로 되어있어 그것이 까다로워진다.  우체국 3 문제처럼 바꿔보자!! dp[i][j] : i번째 지사까지 확인했고 그때 배정한 프로젝트가 j개 일때 최소거리  \\(dp[i][j] = min(dp[k][j-1] +C[k+1][i])\\) 여기서 C는 k+1부터 i까지를 한 그룹에 넣었을 때의 비용이다.  \\(C[i][j] = (j-i) \\times\\sum\\limits_{k=i}^{j}d_{k}\\) gs는 그룹 사이즈라고 생각했다. 여기서 gs는 $j-i$이다.  $d_i$ 는 i에서 본사까지 그리고 본사에서 i까지 오는데 걸리는 거리다.  그리고 $d_i$가 크면 큰 그룹에 있을 수록 안좋고 $d_i$ 가 작으면 큰 그룹에 넣는게 낫다. 따라서 우리는 우체국 3 문제처럼 바꾸기 위해 $d_i$를 기준으로 정렬해서 해결 할 수 있다.     다익스트라로 각 정점 사이 거리를 구한다. $O(N^2\\log N)$   $d_i$ 를 구해서 정렬 해둔다.   $C_{i, j}$ 를 쉽게 구하기 위해 $d_i$ 의 prefix sum ps를 전처리 해둔다.   dnc optimization을 적용한다.!!   첫번째 시간초과 위 방법으로 풀 수 있는줄 알았지만…. 다익스트라 과정이 시간이 오래 걸렸는지 시간초과가 났다.  이건 다익스트라 두 번으로 가능했다.  \bb + 1번 정점에서 다른 모든 정점까지는 그냥 평소처럼 다익스트라하면 되고 다른 모든 정점에서 b+1까지는 간선들을 뒤집고 그것을 따라가면 된다. 따라서 다익스트라 과정을 $O(N\\log N)$ 으로 줄였다.  두번째 시간초과 하지만 또 시간초과를 받았다. 후보군은 다음과 같다.    벡터가 오래걸린다.            reserve를 쓰거나       그냥 배열로 바꿔본다.           분할정복 과정이 문제다.            지금 내 코드는 $O(bs\\log b)$ 정도로 돌아가지만 잡스런 과정이 많다.           해결은 다음과 같이 했다. for(int i=2;i&lt;=s;i++){ \tcompute(i, 1, b, 1, b); }  위 부분을 for(int i=2;i&lt;=s;i++){ \tcompute(i, i, b, i-1, b); }  이렇게 바꿨다.  s에 따라서 검사할 구간이 줄어드니까 이를 이용해 처음에 검사하는 구간을 줄여버리는 것이다.  그래서 꽤 긴 시간, 2733ms정도로 겨우 통과했다 ㅠㅠ 구현 3 #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; typedef tuple&lt;ll, ll, ll&gt; tlll; #define xx first #define yy second  const int MAX = 5001; const ll INF = 1e15; int n, b, s, r;  vector&lt;pll&gt; G[MAX],R[MAX], firm; vector&lt;ll&gt; D1,D2, ps; vector&lt;vector&lt;ll&gt;&gt; dp;  vector&lt;ll&gt; dijkstra(int st, bool rev){     vector&lt;ll&gt; dist(n+1, INF);     dist[st] = 0;     priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; pq;     pq.push({dist[st], st});     while(!pq.empty()){         auto [d, now] = pq.top();         pq.pop();         if(dist[now] &lt; d) continue;         if(rev){             for (auto [nxt, cost] : R[now]){                 if (dist[nxt] &gt; dist[now] + cost){                     dist[nxt] = dist[now] + cost;                     pq.push({dist[nxt], nxt});                 }             }         }else{             for (auto [nxt, cost] : G[now]){                 if (dist[nxt] &gt; dist[now] + cost){                     dist[nxt] = dist[now] + cost;                     pq.push({dist[nxt], nxt});                 }             }         }              }     return dist; }  inline ll C(ll i, ll j){ // i번 지사에서 j까지 한 그룹으로 묶을 때 최소거리     return (j - i) * (ps[j] - ps[i-1]); }  void compute(int x, int l, int r, int optl, int optr){     if(l &gt; r) return ;      int mid = (l + r) &gt;&gt; 1;     dp[mid][x] = INF;     int opt = 1;     for(int i=optl;i&lt;min(mid , optr+1);i++){         if (dp[mid][x] &gt; dp[i][x - 1] + C(i + 1, mid)){             dp[mid][x] = dp[i][x - 1] + C(i + 1, mid);             opt = i;         }     }      compute(x, l, mid-1, optl, opt);     compute(x, mid+1, r, opt, optr); }  ll solve(){     dp.assign(b+1, vector&lt;ll&gt;(s+1, INF));     ps.assign(b+1, 0);     for(int i=1;i&lt;=b;i++){         ps[i] = ps[i-1] + firm[i].xx;     }     for(int i=1;i&lt;=b;i++){         dp[i][1] = C(1, i);     }     for(int i=2;i&lt;=s;i++){         compute(i, i, b, i-1, b);     }          return dp[b][s]; }  int main(){     fast_io     cin &gt;&gt; n &gt;&gt; b &gt;&gt; s &gt;&gt; r;     for(int i=0;i&lt;r;i++){         ll u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;         G[u].push_back({v, w});         R[v].push_back({u, w});     }     D1 = dijkstra(b+1, 0);     D2 = dijkstra(b+1, 1);     firm.assign(b+1, {0, 0});     for(int i=1;i&lt;=b;i++){         firm[i] = {D1[i] + D2[i], i};     }     sort(++firm.begin(), firm.end());     cout &lt;&lt; solve(); }   마무리 아주 옛날에 탈옥이라는 문제를 블로그 뒤져가면서 풀고 묵혀놨던 최적화 테크닉인데 오랜만에 제대로 공부해서 다이아문제 2개를 풀 수 있었다. 꽤 쉬운 문제고 이런 문제의 형태는 찾아낼 수 있을 듯하다.  하지만 대회나 풀이 중에 이 문제가 정확히 Monge array거나 단조성이 있는지 없는지를 증명하기는 꽤 어려울 듯하다.  다음엔 더 재밌는 알고리즘을 또 올려보겠다."
  },
  
  {
    "title": "코드포스 - 다시 맘 잡기",
    "url": "/posts/Codeforces-Round-936(Div.2)/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2024-03-22 00:00:00 +0900",
    "content": "코드포스 다시 열심히! 블로그도 열심히!  개요 본케도 블루에 올려놨지만 맨날 민트로 다시 떨어진다. 항상 잘보면 1700언저리 못보면 1500 정도 나와서 딱 민트 상위 블루 하위가 지금 나의 퍼포먼스라고 생각하면 될 듯하다. 하지만 나는 더 잘하고 싶다. 지금까지 귀찮아서 버추얼과 업솔빙을 소홀히 했는데 지금이라도 열심히 해보려한다. 목표는 정규라운드를 포함하여 일주일에 꼭 2번은 대회를 치고 업솔빙까지 블로그에 쓰는 식으로 해보려고 한다. 내가 퍼플에 가는 그 날까지 블로그에는 코드포스 관련 글만 올릴 듯 싶다. 오늘 대회는 2솔을 했다. 너무 슬프다 ㅠㅠ 하지만 내실력인걸 어떡하겠나…열심히해야지  A. Median of an Array 배열의 원소에 1을 더하는 연산을 할 수 있다.  이 때, 배열에 적절히 연산을 해서 처음으로 중간값을 바뀌게하는 연산 횟수를 구하고 싶다.     먼저 중간값이 딱 하나면 그냥 거기에 1을 더해주면 된다.   하지만 중간값이 여러개라면 하나를 1올려도 다른 하나로 대체된다.   따라서 정렬하고 (n+1)/2 이상의 index에서 중간값과 같은 값의 개수를 세면 된다.   #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; typedef tuple&lt;ll, ll, ll&gt; tlll; #define xx first #define yy second  void solv(){     int n; cin &gt;&gt; n;     vector&lt;int&gt; a(n);     for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i];     sort(a.begin(), a.end());     int x = a[(n+1)/2-1];     int cnt = 0;     for(int i=(n+1)/2-1;i&lt;n;i++){         if(x == a[i]) cnt++;     }     cout &lt;&lt; cnt &lt;&lt; '\\n'; }  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while(tt--) solv(); }   B. Maximum Sum 배열이 있다.  여기에 연산을 할 수 있는데 배열에서 가장 큰 부분합을 찾은 후에 그 값을 배열의 아무데나 추가하는 것이다. 이 연산을 k번 했을 때 모든 배열 원소의 합을 구하는 문제다.     음수밖에 없으면 더할 필요가 없다.   요소들의 합이 가장 큰 연속되는 subarray를 찾고 그 연속되는 subarray안에 넣는다.   그렇게 k번 요소를 추가한 후 합을 계산한다.   2번은 1912 연속합의 아이디어로 dp로 구할 수 있다. 이 후, 최대 연속합을 x라고 하면 $\\sum\\limits_{i=1}^{k}x*2^{i-1}$ 이 추가된 요소가 된다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; typedef tuple&lt;ll, ll, ll&gt; tlll; #define xx first #define yy second  const ll mod = 1e9+7;  void solv(){     int n, k;     cin &gt;&gt; n &gt;&gt; k;     vector&lt;ll&gt; a(n+1), dp(n+1);     for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i];     ll x = 0;     dp[1] = max(0LL, a[1]);     x = max(x, dp[1]);     for(int i=2;i&lt;=n;i++){         dp[i] = max(dp[i-1] + a[i], a[i]);         x = max(x,dp[i]);     }          ll add = x;     for(int i=0;i&lt;k-1;i++){         add += x * 2LL;         x *= 2LL;         x %= mod;         add %= mod;     }     for(int i=1;i&lt;=n;i++){         add += a[i];         add %= mod;     }     cout &lt;&lt; (add % mod + mod) % mod &lt;&lt; '\\n'; }  int main() {     fast_io      int tt; cin &gt;&gt; tt;     while (tt--) solv(); }   C. Tree Cutting 문제는 매우 간단하다. 트리의 간선을 끊으면 subtree가 2개 생긴다.  이 때, 간선을 끊는 행위를 k번 한후 제일 작은 subtree의 크기가 제일 큰 경우를 구하면 된다.  먼저 분석해보면 아무리 잘 짤라도 답이 n/(k+1) 을 넘길 수는 없다.  일단 subtree가 제일 큰 경우를 구하면 되니까 이거는 binary search를 이용할 수 있다.  솔직히 여기까진 생각했다.  그리고 내가 정한 답이 되는가? 를 판단할 때는 그리디 알고리즘으로 하는데 여기를 어케해야하지 싶었다.  아이디어도 꽤 간단했다.  트리를 쭉 보는데 서브트리가 내가 설정한 것보다 같거나 커지는 순간 뚝 끊어버리고 보면 된다.  근데 이게 구현이 생각보다 까다롭다. 답을 봤는데 코드이해는 쉬웠는데 생각보다 구현이 어려웠다.  ㅠㅠ #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; typedef tuple&lt;ll, ll, ll&gt; tlll; #define xx first #define yy second  const int MAX = 1e5+1; int n, k; vector&lt;int&gt; G[MAX]; int res = 0, X = 0;  int dfs(int now, int par){     int sz = 1;     for(int nxt : G[now]){         if(nxt == par) continue;         sz += dfs(nxt, now);     }     if(X &lt;= sz &amp;&amp; now != par){         sz = 0;         res += 1;     }     return sz; }  bool chk(int x){     X = x;     res = 0;     int sz = dfs(1, 1);     if(res &gt; k || (res == k &amp;&amp; sz &gt;= x)) return true;     return false; }  void solv(){     cin &gt;&gt; n &gt;&gt; k;     for(int i=1;i&lt;n;i++){         int u, v; cin &gt;&gt; u &gt;&gt; v;         G[u].push_back(v);         G[v].push_back(u);     }          int lo = 0, hi = n/(k + 1) + 1;     while(lo + 1 &lt; hi){         int mid = (lo + hi) &gt;&gt; 1;         if(chk(mid)){             lo = mid;         }else{             hi = mid;         }     }      cout &lt;&lt; lo &lt;&lt; '\\n';     for(int i=1;i&lt;=n;i++) G[i].clear(); }  int main() {     fast_io      int tt; cin &gt;&gt; tt;     while (tt--) solv(); }  핵심은 서브트리 수를 관리하다가 아래서 부터 0으로 만들어버리는 것이다.  재귀 원리를 이용한 정말 좋은 테크닉이다.  D. Birthday Gift 문제를 간단히 요약하면 배열이 주어지고 이를 최대한 많은 그룹으로 나눌건데 각 그룹을 xor한 값들을 모아서 or연산한 값이 특정한 값 x를 넘어서는 안된다.  그렇게 할 수 있는 가장 많은 그룹의 수를 구하면 되는 것이다.  그룹을 많게하려면 배열을 잘게잘게 쪼개는 것이 이득이지만 잘게 쪼갤 수록 or연산했을 때 값이 커질 확률이 높을 것이다.  모든 구간을 전수조사하려면 $2^{100000}$ 의 시간이 걸리니 절대 불가능이다.  배열을 쭉 보면서 확인하는 수 밖에 없다.  일단 내가 생각했던 아이디어를 되짚어보면    각 구간의 xor값은 누적합으로 $O(30)$ 만에 구할 수 있다.   그리고 map을 이용한 dp처럼 해결하는 것이다.   또는 앞에서 부터 보면서 그리디하게 끊을 수 없을까 고민하기도 했다. 근데 내 풀이는 map에 넣는 연산도 너무 많이하고 심지어 예제도 잘 안나왔다.  x보다 작은 값을 모두 검사할 수도 없다. (x가 너무 큼) 그리고 앞에서 부터 끊는 건 안될 것 같았다.   정답은… 3번풀이를 bit별로 수행하는 것이다.  가장 큰 비트부터해서 조건을 만족하면 그냥 살리고 아니면 나눠버린다. 이 과정을 끝 비트까지 하면된다.  가면 갈 수록 그룹이 계속 합쳐져 작아진다. 그래서 중간에 성공하면 그것이 답일 것이다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; typedef tuple&lt;ll, ll, ll&gt; tlll; #define xx first #define yy second  void solv(){     int n, x; cin &gt;&gt; n &gt;&gt; x;     x += 1;     vector&lt;int&gt; a(n+1);     for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i];     int res = -1;     for(int i=30;i&gt;=0;i--){         vector&lt;int&gt; b;         b.push_back(0);         bool zero = true; // 이번 비트가 0인지 아닌지         for(int j=1;j&lt;a.size();j++){             if(zero){                 b.push_back(a[j]); // 0이면 일단 추가(그룹이 많을 수록 좋음)             }else{                 b.back() ^= a[j]; // 1이면 0을 없애주기 위해 xor해줌             }             if(a[j] &amp; (1 &lt;&lt; i)){ // 1이면 zero의 상태가 바뀜                 zero ^= 1;             }         }         if(x &amp; (1&lt;&lt; i)){ // 이번 비트가 1이면 뒤에 비트에서 걸리는지 확인해야함             if (zero)                 res = max(res, (int)b.size()-1);         }else{             if (!zero){                 cout &lt;&lt; res &lt;&lt; '\\n';                 return;             }             a = b;         }     }     cout &lt;&lt; res &lt;&lt; '\\n'; }  int main(){     fast_io      int tt; cin &gt;&gt; tt;     while (tt--) solv(); }     구현할 때 테크닉            x를 1키워서 작은 경우만 확인한다.       내가 1-based 로 해서 구현이 좀 별로였다…           마무리 솔직히 아직도 구현 실력이 많이 부족하다.  그 이유는 내가 틀린 문제를 다시 보지 않는 정말 쓰레기 같은 습관을 가지고 있기 때문이다.  코포 실력이 늘려면 코포를 많이 치는게 좋은데 나는 버추얼도 안풀면서 퍼플을 가고 싶다는 것 자체가 참 욕심쟁이다. 이제 부터 2가지를 꼭해보겠다.    버추얼 포함 일주일에 2번 코포 치기   2000이하 rating 문제는 무조건 upsolving 하기 퍼플 갈 때까지 2가지 꼭 지키자 화이팅!!"
  },
  
  {
    "title": "rust 문법 공부",
    "url": "/posts/1.-rust-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95/",
    "categories": "rust",
    "tags": "programming language, rust",
    "date": "2024-03-12 00:00:00 +0900",
    "content": "rust 공부시작!  개요 C, C++, python을 할줄 알지만 뭔가 다른 사람들과의 차별점을 두고 싶어서 하나만 더 배워보고 싶었다.  rust는 백준 사이트에서 보면 굉장히 빠르다.  또한 보안에도 좋다고 들었다.  그런것도 있지만 희소성도 있는 것 같아서 공부를 해보려고 한다.  여기서는 출력, 입력, 자료형 등 기본적인 문법을 정리해보겠다. 공부할 때, tour of rust 를 많이 참고했다.  출력(print) “Hello world”를 출력하는 것은 언제나 기본이다. fn main() { \tprintln!(\"Hello, world!\"); }  C와 비슷하게 main함수 안에 있고 ;(세미콜론)으로 문장을 마무리하는 것을 알 수 있다. 그리고 특이한것은 println!, 맨뒤에 !가 붙는다는 것이다. 또한 문자열은 ““로 감쌀 수 있어보인다.  변수(variable) fn main() { \tlet x = 13; \tprintln!(\"{}\", x); \t \t// 자료형을 지정 float64 \tlet x: f64 = 3.14159; \tprintln!(\"{}\", x); \t \tlet mut a = 34; \ta = 10; \tprintln!(\"{}\", a) }  변수는 let을 이용해 선언한다.    선언과 함께 초기화 할 수 있다.(선언만 하고 나중에 초기화해도 된다…굳이?)   자료형을 지정할 수 있다. (이후 자료형을 나열해보겠다)   mut : mutable 변경가능한지 아닌지 설정한다.            default가 immutable이라 변수의 값은 변경이 불가능하다.       따라서 mut 명령어를 통해 바꿀 수 있는 변수는 명시적으로 써준다.           똑같은 이름의 변수를 같은 함수에서 또 선언할 수 있다. (이것은 덮어쓰기라고 생각하면 될 듯하다)            이를 변수 숨김(variable shadowing)이라고 부른다.       심지어 이 때 자료형도 변환 할 수 있다.           자료형(data type) fn main() { \tlet a = 1; // default : i32 \tlet b: i64 = 12345678910; \tlet c: u32 = 19; \tlet d = 5.1; //default : f64 \tlet e = 5.1f32; // 이런식으로 뒤에 붙여도 됨 \tlet f = true; //default : bool \tlet tup = (123, true); // tuple : 다른 자료형도 ok \tlet sen = \"HI deer\"; // default :str }  기본적으로 다른 언어들과 다를게 없다.    boolean : bool   integer : i8, i16, i32, i64   unsigned integer : u8,u16, u32, u64   float : f32, f64   string : str   tuple : (value1, value2, ..)   자료형 변환 fn main() { \tlet a = 1; // default : i32 \tlet c: u32 = 19; \tprintln!(\"{}\", a as u32 + c); }  as라는 예약어를 사용하여 쉽게 자료형을 변경할 수 있다.  상수 const PI: f32 = 3.14159;  특징은 상수는 무조건 자료형을 명시해야한다는 것이다.  배열 fn main() {     let nums: [i32; 3] = [1, 2, 3];     println!(\"{:?}\", nums);     println!(\"{}\", nums[1]); }   배열의 선언방식이 꽤나 신선하다. nums : (자료형) 에서 자료형 자리에 배열 표시를 해주는 것이다. [배열 요소의 자료형; 배열의 크기] 로 깔끔하게 선언할 수 있다. fn main() { \tlet mut nums: [i32; 3]; \tnums = [1, 2, 3]; \tnums = [4, 5, 6]; \tprintln!(\"{:?}\", nums); \tprintln!(\"{}\", nums[1]); }  이 또한 mutable하게 선언해서 사용할 수 있다. mut 명령어가 없다면 [1, 2 , 3] 까지는 되지만 [4, 5, 6]이 안될 것이다.  고정길이 배열이기 때문에 초기화시 맘대로 원소의 수를 줄이거나 늘리기는 힘들다.  함수 fn add(x: i32, y: i32) -&gt; i32 { \treturn x + y; }    fn main() { \tprintln!(\"{}\", add(1, 2)); }     fn 함수이름(매개변수 : 자료형 , 매개변수 : 자료형 ) -&gt; 리턴값의 자료형{함수내용}   재밌는 것은 c, c++과 달리 add 함수를 선언을 해주지 않고 main함수 뒤로 보내도 정상 작동한다.   튜플을 리턴하기  fn swap(x: i32, y: i32) -&gt; (i32, i32) {     return (y, x); }  fn main() {     // 리턴 값의 튜플을 리턴     let result = swap(123, 321);     println!(\"{} {}\", result.0, result.1);      // 튜플을 두 변수명으로 분해     let (a, b) = swap(result.0, result.1);     println!(\"{} {}\", a, b); }  튜플의 각 원소에 접근하는 것이 간단하다. (.0, .1로 접근하고 있다.) let (mut a, mut b) = swap(result.0, result.1); println!(\"{} {}\", a, b); (a, b) = swap(a, b); println!(\"{} {}\", a, b);  이런식으로 편하게 swap함수를 이용해 변수에 있는 값을 뒤바꿀 수도 있다. 튜플에 mut을 적용하는 방법은 위와 같다. (하지만 mut를 남용하는 것은 좋지 않아보인다.)  unit c++의 void 처럼 아무것도 리턴하지 않으려면 어떻게 해야할까? 정답은 빈 튜플을 리턴하는 것이다. 이를 unit이라고 한다. fn unit() -&gt; () { \t// 아무것도 리턴 안해도 return ()과 같은 효과 }   fn main() { \tlet a = unit(); \tprintln!(\"The value of a: {:?}\", a); } // 결과 : The value of a : ()  출력할 내용이 없어서 디버그 문자열을 출력한다.  마무리 rust는 충분히 재밌는 것 같다. 각 언어마다 매력이 넘쳐서 새로운 언어를 배우는 것은 언제나 즐겁다. 애인을 두고 다른 사람과 만나는 것은 현실에서는 안되겠지만 프로그래밍 언어를 배울 때는 괜찮지 않을까 싶다.  rust에 관심을 가진 것은 훨씬 전이지만 이번에 노마드코더 유튜브 에서도 C, C++의 메모리 누수에 대한 우려를 보였고 러스트를 추천했다. 러스트는 변수의 default가 immutable이라는 점이 재밌다.  안전에 신경을 썼다고 하니 그런 쪽 위주로 열심히 공부를 해봐야겠다.  정말 오랜만의 블로그 글이다.  블로그를 꾸미기가 넘 힘들어서 부셔버리고 새 사이트를 만들어볼까 고민중이다. 하지만 둘다 귀찮은건 매한가지다. ㅋㅋㅋ 새학기가 시작되었으니 다시 블로그를 관리해보도록 하겠다."
  },
  
  {
    "title": "블루 달았다!",
    "url": "/posts/Codeforces_Blue/",
    "categories": "Contest",
    "tags": "대회후기, 후기, Codeforces, blue, 코드포스",
    "date": "2023-10-10 00:00:00 +0900",
    "content": "코드포스 블루 달성 후기  드디어 달성!!  1년 가까이 코드포스를 한 것 같다. 중간에 코드포스를 쉰 적도 있었지만 백준을 풀면서도 꼭 블루로 올리고 싶다고 생각을 했었다.  내가 올린 과정과 방법, 그리고 앞으로 어떻게 공부하는 것이 좋은지 글로 남기려고 한다.  내가 고생한 만큼까지 고생하지 않도록 내 글을 읽는 누군가가 도움이 되었으면 한다.  지금 찐블루가 아니기때문에 점수 올리는 법 같은 글을 쓰는 것도 웃기지만 나에게 너무 기쁜일이라 이 경험을 꼭 공유하고 싶다.  점수의 등락 과정    먼저 이건 내 본캐(dosaseung)의 점수이다. (아직 민트다..ㅎ)  그래도 뭔가 분석해보자면 뉴비에서 고생하다가 그린으로 올라가고, 또 그린에서 고생하다가 민트로 올라간다.  그리고 또 민트에서 고생하고 있었다 ㅋㅋ 마치 계단형 그래프에 노이즈를 끼운듯한 느낌?  민트에서 고생하면서 든 생각은 ‘나는 사실 블루를 갈만한 놈이 아닌건 아닐까?’였다.  하지만 그래프를 분석해보면 이제는 블루를 갈때라고 생각했어도 됐을텐데 싶다.  민트에서 고생하는 내가 싫어서 부캐를 만들었다. 그리고 조용히 실력을 쌓아보자 했던 것이다.  아래는 부캐의 점수 등락 추이다.      결과는 10번만에 블루에 입성했다!!!  마지막에 504등을 하면서 104점을 끌어올려 겨우 찍은 것이 보일것이다 ㅋㅋ  아직은 항상 블루 퍼포먼스가 나오진 않는다.  하지만 내가 확실하게 느낀 것은 계속하면 분명히 실력이 늘고 앞으로 항상 블루 퍼포먼스가 나오는 날이 분명히 올 것이라는 것이다.  점수를 올린 방법  1603점..블루 턱걸이까지 나는 겨우 왔다.  하지만 겨우 왔기 때문에 어떻게 해야 블루를 갈 수 있는지 생각을 많이 해볼 수 있었고 그 방법을 이야기 해보려고 한다.  1. 코드포스에 대해 잘 알기  일단 정보는 당연히 중요하다.  내가 어느정도를 해야 어느 정도의 점수가 오르고, 어떤 문제가 주로 나오고, 보통 대회 시간은 언제고 등 여러 정보를 알고 있어야 점수를 올리기 유리하다.  블루를 목표로 한다고 해보자.  그러면 보통 div2에는 20000명 정도가 참여한다. 그러면 여기서 최소 1500등안에 들어야한다.  블루가 상위 10퍼센트라고 하지만 점수가 오르려면 1500등 안에는 들어야 민트에서 점수가 오른다.  그러면 어떻게 풀어야 이 등수가 나올까?  나는 A, B, C를 매우 빨리(40분이내) 풀거나 D까지 대회시간 20~30분정도 남기고 풀면 이 등수가 나온다고 느꼈다.  물론 셋의 난이도에 따라 확확 변하긴하지만 중요한 것은 쉬운 문제 (A, B, C)를 빨리 푸는 것이다.  이는 타자를 빨리 치는건 중요치 않다. (올바른 생각을 한번에 하고 정확하게 밀고 나가는 것이 중요하다)  이런 목표를 세우려면 코드포스 시스템을 잘 이해하는 것이 좋다.  2. 코드포스를 많이 풀기  코드포스에 나오는 유형은 매우 전형적인 코드포스 문제이다.  아무리 백준으로 많이 연습해도 코드포스를 푸는 것과는 조금 차이가 있다는 말이다.  특히 짝수/홀수를 이용하는 문제, n = 1, 2, 3을 예외 처리하고 나머지를 처리하는 문제, gcd를 이용해야 할 것 같지만 사실은 배수/약수 논리로 푸는 문제 등이 A, B, C에 많이 배치된다.  또한 뒤에서부터 보면서 푸는 테크닉, 코포에 자주 나오는 그리디가 분명히 존재한다.  백준에서 어려운 알고리즘 (HLD, FFT 등등)을 배워도 코드포스 블루가는데는 쓸모가 없다. (생각의 성장, 구현실력 향상을 제외하곤 없다)  따라서 연습을 코드포스로 열심히 해야한다. 나는 사실 이걸 알지만 열심히 안했다….  대신!! 대회는 무조건 참가했다. 절대적인 양을 무시할 수 없다는 것이다.  단기간에 빠르게 점수를 올리고 싶다면 버츄얼을 많이 도는 것이 좋다. (특히 A, B, C, D까지 빨리 풀기를 연습해보자)  3. 업솔빙 (upsolving)  모두가 해야하는걸 알지만 너무나도 귀찮은 것이 틀린 문제 다시 풀기다.  코포에서 업솔빙이 중요한 이유는 2번에서 이야기한 내용과 일맥상통한다.  코드포스에 자주 등장하는 유형을 익히는 것이 정말 중요하기 때문이다.  특히 에디토리얼이 정말 잘 나와있다. 커뮤니티 댓글도 좋은 정보가 많다.  에디토리얼의 힌트나 설명을 이용해서 풀어보면 출제자의 의도를 확인하기도 좋을 것이다.  내가 생각하기에 중요한 것은 절대 남의 코드를 보면서 업솔빙하지 않기이다.  남의 코드를 보면서 업솔빙하면 그 논리가 제대로 내 머리속에 박히지 않고 그냥 날아가버리기 때문이다.  물론 남의 코드를 보고 다시 내 코드로 바꿔보는 것도 괜찮긴하다. 하지만 그냥 보면서 거의 배끼듯이하면 실력향상이 매우 더딜것이다. (내가 좀 그랬다…그냥 이렇게 푸는거구나 하고 넘기거나 , 에디토리얼의 코드를 좀만 손봐서 제출하곤했다)  조금 귀찮더라도 스스로 생각하는 법을 기르긴 해야한다.  4. 백준에서 연습법(꾸준함)  2번에서 이야기했듯이 사실 백준은 코드포스를 올리는데 엄청난 도움이 되지는 못한다.(한국인 세터분들의 코드포스 문제가 있긴하다)  하지만 백준에서의 장점은 한국 사이트고 사람들도 많이하고 solved.ac가 재밌어서 꾸준히 할 수 있다는 것이다.  스트릭을 쌓는 재미라던지 (근데 이게 나중엔 필수 퀘스트같아서 굉장히 힘들어지긴 한다.) 그런 것들로 문제 푸는 습관을 들일 수 있다.    나의 스트릭이다. 정말 꾸준히 했다.  근데 내가 추천하는 것은 어떤 문제를 질질 끌면서 고민하는 거 말고 백준 문제를 시간을 잡고 좀 타이트하게 푸는 연습을 하는 것이 좋다. 그러니까 코포 블루를 가고 싶다면 다이아,루비 문제는 조금 미뤄도 괜찮다.  결국 하고픈 말은 코드포스 문제를 많이 그리고 꾸준히 풀어봐라 인것 같다.  머리가 좋은 사람들은 굉장히 빨리 블루에 가곤한다. (그래서 내가 더욱 심리적으로 힘들었다)  하지만 실력이 멈춘것 같아도 무조건 늘고 있으니 계속 도전하길 바란다.  앞으로 내 계획  나 혼자 심심해서 Q&amp;A형식으로 내 계획을 말해보려한다.  Q1. 코드포스를 쉴 것인가?  네니오. 10월달은 시험기간이라서 쉬려고 한다. PS만 하다가 지난학기 좀 많이 망쳤다.  심지어 지난학기에 믿고 있던 알고리즘도 A밖에 못맞았다. (다른 과목들은 B, B+…)  이번엔 방심하지 않고 열심히 시험공부를 해야봐야겠다.  Q2. 아니 그런거 말고 앞으로 계속 코포를 도전할거냐는 뜻이다.  그렇다면 당연히 YES다. 나의 목표는 레드코더가 될 때까지 하는 것이다. 몇 년이 걸려도 계속 해볼 생각이다.  중간에 현실적인 문제(취업 등)가 있어서 못하게 된다면 잠시 쉴 수도 있지만 몇 십년이 지나도 계속 하지 않을까 싶다.  CP가 참 매력있고 재밌기 때문이다.  Q3. 취업을 위한 공부는 안하나?  그건 사실 큰일났다. 내가 개발공부를 거의 안해서 회사에서 뽑아갈지 모르겠다. ㅋㅋㅋ  하지만 왜인지 이 PS공부가 다른 사람과 나의 차이를 만들고 내 장점을 만들어준 기분이라 왠지 모를 자신감이 있다.  사실 나의 꿈은 게임개발자이다.  내 인생의 목표는 내 생각들(인생에 대한 생각, 재밌다고 생각한 것, 공부한 것 등)을 다른 사람들과 함께 즐기고 정신적인 고양을 하는 것이 목표이기 때문이다.  그 중 게임은 문학, 음악, 미술, 프로그래밍 등 다양한 분야가 합쳐진 종합 예술이고 따라서 내 생각을 전하는 매개체로 참 좋다고 생각했기 때문이다.  어쨌든 그에 대한 공부를 하긴 할거다…ㅠㅠ  내년에 휴학을 한번하고 내 공부계획을 정리 해볼까?도 고민중이다.  Q4. PS공부에서 최종목표는??  이 질문은 내가 나에게 하는건 아니고 진짜 좋아하는 사람이 질문 해줘서 넣었다.  참 어려운 것 같다. 막연하게 코드포스 레드? 오렌지? ICPC 본선 10등이내? 참 대단한 목표들이 있다. 하지만 이건 PS를 공부하는 이유가 될 수 없다.  예를 들어, “왜 공부하세요?” 라는 질문에 “좋은 회사에 가려고요” 라고 하는 느낌이기 때문이다.  위 대답이 나쁜건 아니지만 공부의 목표가 저런거라면 나는 조금 씁쓸한 느낌이 들어서 별로다.  최종목표를 생각하기 전에 왜 내가 이 공부를 하는가 생각해봤더니 재밌어서였다.  나는 이 재밌는 공부를 많이 많이 배워서 다른 누군가에게 잘 알려줄 수 있는 사람이 되고 싶다.  누군가가 나를 통해 PS에 재미를 느낀다면 정말 뿌듯할 것 같다.  뭔가 게임을 개발해서 유저에게 기쁨을 주고 싶은 마음과 일맥상통하는 것 같기도 하다.  최종목표는 누군가에게 이 재미를 알려줄 수 있을 정도로 PS를 좋아하고 잘 알기!!로 정했다.  언젠가 PS가 재미없어지는 날이 올지도 모른다.  하지만 이렇게 재밌게 했던 기억과 추억은 평생가기 때문에 이런 목표는 변하지 않을 것이다.  아니면 어쩌면 이미 이룬 상태일지도 ㅋㅋ  마무리  뭔가 추상적인 말들만 늘어놓다보니 엄청 긴 글이 되었다.  나 어쩌면 글 쓰는걸 좋아하는 걸지도??  마무리하며, 내가 하고 싶은 말을 해보겠다.  내 글을 읽어보는 사람은 PS(Problem Solving)를 하는 사람일 확률이 높을텐데  나는 스물둘에 ps를 접했다. (지금은 24이고) 그리고 20살 전까지만해도 나는 정말 똑똑한데 노력을 안해서 이런줄 알았고, 수학을 못하는 다른 애들을 무시했고, 머리가 안 좋아 보이는 사람들을 무시했다.  하지만 여기 PS판에는 괴물들이 굉장히 많다.  나는 여기서 매우 겸손해졌다 ㅋㅋ 그리고 모든 사람들을 대단하게 보기 시작했다.  내가 풀고 남이 못 푸는 문제가 있으면 내가 못풀고 남이 푸는 문제가 있듯이 서로 잘하는게 다를 수 있다.  내가 알아낸 것은 못하는 것이라도 계속하면 실력이 늘고, 못하는 것을 계속하는 것이 지능보다 대단한 진짜 능력이라는 것이다.  나는 민트에서 블루의 과정에서 포기를 생각하기도 했다. 하지만 계속했고 결국 이뤄냈다.  계속 도전하는 좋은 마인드를 얻어낸 것 같다.  너무 정신없이 글을 쓴 것 같다.  결론은     여긴 괴물들이 많으니 자신이 못한다고 좌절하지 말것!!   못한다고 생각하지만 잘하고 싶은것을 계속 할 것!!   이 두 가지이다.  나의 경험이 PS하는 사람에게 재미, 도움을 주었으면 정말 좋겠다.  긴 글을 읽어준 사람들 너무 고맙습니다 💙🩵"
  },
  
  {
    "title": "ICPC sinchon 2023 여름 캠프 후기",
    "url": "/posts/ICPCsinchonSummer/",
    "categories": "Contest",
    "tags": "대회후기, 후기",
    "date": "2023-09-03 00:00:00 +0900",
    "content": "여름캠프 및 SUAPC 후기  개요  뭔가 엄청나게 오랜만의 포스팅이다.  이 글의 주인공은 이번 방학동안 참여한 알고리즘 캠프이다.  나는 지난 3학기동안 꾸준히 신촌엽합의 캠프를 들었고 suapc는 2학기동안 참여했다.  하지만 후기를 쓰는 것은 처음이다. 항상 이 캠프가 끝나면 학기가 시작되니 귀찮음을 이겨내지 못했던 것이다.  이번엔 꽤나 만족할만한 결과를 거두기도 했고 월공강이라 여유도 생겼으니 여름캠프와 suapc둘다 여기에 후기를 남겨볼 것이다.  2023 여름 캠프  지난 캠프와 달랐던 점  이번이 3회차인 캠프인데 이번 캠프는 지난 두 차례와 많이 달랐다.  일단 난이도가 쉬워졌다. 이는 매우 좋다고 생각한다. 알고리즘에 시간투자를 많이 하지 않는 사람들 (나는 아니지만)도 문제들을 건드려 볼 수 있고 열심히 하는 사람들이 조금 여유를 가질 수 있게 해준다.  그래서 이번 캠프를 하면서는 내 개인적인 시간에 게임도 할 수 있고 다른 문제들도 풀어 볼 수 있었다. 저번캠프에서는 하루종일 풀어도 못푸는 문제도 많았었다.. 물론 내 실력이 는 이유도 있겠지만 난이도 하락은 캠프의 진입장벽을 낮춰주어 좋았다.  그리고 환급 시스템이 거의 대부분의 돈을 환급받을 수 있어서 좋았다. 나처럼 시간투자를 많이하는 사람에게는 공짜로 이런 좋은 캠프를 참여할 수 있다는 것이 너무 좋았다.  마지막으로 이번엔 조금 난이도가 쉬워진 대신 일정이 빡빡해졌다. 이전의 캠프들은 주에 2회정도 했었는데 이번엔 주 3회로 약간 빡빡한 일정이었다. 하지만 난이도가 쉬워져서 그런지 오히려 실전 압축같고 좋았다.  캠프를 하면서 느낀점          이번 캠프는 상당히 쉬워졌다고 느끼지만 그래도 사람들이 많이 풀지 않는다고 생각한다.      캠프 참여인원이 30명 정도라고 하면 실제로 열심히 푸는 사람들은 5~6명정도 된다.      막히는 문제가 생기면 놓고 싶어지는 것은 알지만 30분에서 1시간 사이로 고민하다가 질문을 하거나 인터넷을 조금 참고해도 된다고 생각한다. 모르고 포기하는 것보다 누군가 떠먹여 주더라도 해결을 하는것이 좋다고 생각하기 때문이다.      알고리즘에 인생을 갈아넣긴 어려운 사람들도 많지만 그래도 열심히하는 사람이 더 많아졌으면 좋겠다.           나는 생각보다 잘한다.      코드포스를 하다가 블루가는 것을 실패하고 절망하고, 최근에 ucpc에 나가서도 1문제도 풀지 못해 팀에게 기여하지 못해서 마음이 힘들었었다. 그래도 여기서 문제를 풀면서 깔끔하게 풀기도 하고 사람들이 내 코드를 구경해주기도 하면서 자신감을 얻었다.      누구든지 PS(problem solving)를 하다보면 절망할 때가 있다고 생각한다. 하지만 꾸준히 한다면 결코 실력이 떨어지지는 않는다. 그리고 PS를 하는 사람들은 매우 열심히 하는 사람들이 많고 그 분들이 많이 보이기 때문에 상대적으로 내가 못해보이는 것이다. 어쩌면 평범한 사회에는 PS의 존재를 아는 사람이 더 적을지도 모른다. 백준의 존재를 아는 우리는 이미 상위 1%아닐까싶다.      이번 캠프를 하면서 꾸준히 하는 나를 보며 나는 생각보다 잘한다는 것을 느꼈다.      Camp Contest   💡 결과는 ~~~ 2등입니다!!      처음 참가했던 캠콘에서는 7등 → 2번째는 3등 → 이번에는 2등으로 점점 발전했다!! (다음엔 1등??)  2등이라서 기분 좋은것도 있지만 점점 발전하는 나의 모습에 기분이 너무 좋았다.  거기다가 신촌연합에 있는 대학들 (연대, 서강대, 이대, 숙대) 모두 너무 잘하는 대학들이라 이 사이에서 내가 발전했다는 것은 정말 기분좋은 일이다.  솔직히 문제는 예전 캠콘에 비해서 1e9+7배는 쉬웠다. 이전에는 건드리지도 못하는 문제들이 막 3개씩 있었는데..  이번에는 딱 한문제만 못 건드렸다. 나머지는 다 풀었다!!  조금 아쉬운점은 페널티관리를 너무 못했다. 특히 B번에서 테스트하려고 범위를 작게 설정했던것을 그대로 제출했다거나, A번 실수오차를 3번정도 냈다거나, F번 시작할 땐 무조건 통과한다는 것을 까먹었다거나 , 자잘한 실수들은 앞으로 천천히 고쳐 나가봐야겠다.  또 아쉬운점은 마지막문제 제출이라도 해서 스코어보드에 긴장감을 불어넣지 못한 점이 아쉽다. ㅋㅋㅋ 뭔가 예제도 제대로 안나오니 제출하기 싫었나보다… 그래서 약간 김빠지는 스코어보드 개봉이 되었다.  어쨋든 매우 만족스러운 결과를 냈고, 나에게 이런 즐거운 경험을 준 신촌 연합에게 감사하다. (홍대에 오길 잘했다는 생각도 들었다.)  SUAPC  이번 대회는 감사하게도 학교 후배들인 동현이(mastershim)와 승민이(smjun04)가 같이 팀을 해보자고 해서 함께하게 되었다. 실력이 좋은 친구들이라 좋은 성적을 거둘 수 있을거라고 생각했고 목표는 5등안이였다. (당연히 무리수인 목표인데 목표는 높게 잡아야 하니까!!)  팀이름은 홍하예프로 했고 홍대생 밈을 그냥 쓰고싶어서 쓴 것이다.  이 대회에 출전하기전 ucpc도 참여해보고, 서강대에서 했던 icpc연습도 참여했는데 그 때마다 내가 너무 못해서 미안했다. 그래서 이번대회에서는 꼭 밥값을 해야지라고 생각했었다.   💡 결과는 ~~~ 10등입니다!!!      결과는 수상컷이었다. (6솔로 10등을 했다)  그래도 상위권 팀들과의 차이는 솔직히 많이 느꼈다. 6솔을 빨리해서 다행이었다.  나는 I번과 L번을 풀었고 J번 마지막에 구현해둔 코드 보여주는 정도의 기여를 했다.  L번은 우선순위큐 11개만드는 매우 쉬운문제였고, I번은 포함배제 원리를 이용한 것이였는데 dp를 곁들여서 풀었다.  I번은 솔직히 좀 어려운데 잘 푼것 같아서 기분이 매우 좋다.  아쉬운점은 D번을 실패했다는 점, 아이디어는 맞았는데 구현을 못했다는 것이 너무 아쉽고,  F번 생각을 안했다는 점, 게임이론 + kmp인것을 파악했지만 kmp를 어떻게 써야하지 고민을 10분도 안해보고 포기를 했다는게 너무 아쉽다.  9등인 우진스 팀에게 그 차이로 밀린것이 분했다!!!  그래도 우리팀의 첫 출전인데 수상권에 든 기염을 토했다는 것은 참 뿌듯했다. (나도 꽤 기여를 한 것 같고)  마무리  다음에도 신촌연합의 캠프를 참여할지는 미지수이다. 이 캠프가 싫어서가 절대 아니다. 다만 알고리즘에 시간투자를 너무해서 다른것을 너무 못했다는 것이 문제다.  하지만 후배들이 이 캠프를 고민한다면 나는 주저없이 추천할 것이다.  훌륭한 친구들이 옆에서 푸는 것을 보며, 경쟁하며, 같이 문제를 고민하는 것은 매우 도움이 되기 때문이다.  방학을 알차게 보내게 해주어서 감사하다. 나는 이제 여유롭게 문제를 풀며 코드포스 블루를 다시 도전해보려고 한다."
  },
  
  {
    "title": "코드포스 - 연습중2",
    "url": "/posts/Edu-Codeforce-round-149-(Div-2)/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2023-05-25 00:00:00 +0900",
    "content": "2023-05-25-Edu Codeforce round 149 (Div.2)  개요  디비전 2는 솔직히 4문제는 풀어야 본전이다.  나도 옛날엔 인정하지 않았지만 A == 브론즈, B== 실버하위, C == 실버 상위, D == 골드 수준의 문제들이 출제 되기 때문이다. (물론 편차가 있긴하지만)  예전에는 내가 C, D를 자주 못풀었기 때문에 D가 무슨 골드냐 플레는 되겠지..했는데 솔직히 풀이를 보면 골드가 맞다. ㅋㅋ  내가 아직 골드는 확정적으로 푸는 실력이 안되는 것이다.  그래도 오늘은 4문제를 겨우겨우 어찌저찌 풀었으니 다행이다. E까지 업솔빙을 해보겠다.  A. Grasshopper on a Line (0:05)  해가 무조건 있다고 알려줬다.  그러니 k로 나누어 떨어지지 않으면 1을 출력하고 x로 바로 이동한다.  k로 나누어 떨어지면 2를 출력하고 i, x-i로 분할하여 생각한다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while(tt--){         int x, k; cin &gt;&gt; x &gt;&gt; k;         if(x%k){             cout &lt;&lt; 1 &lt;&lt; '\\n';             cout &lt;&lt; x &lt;&lt; '\\n';         }else{             cout &lt;&lt; 2 &lt;&lt; '\\n';             for(int i=1;i&lt;=x;i++){                 if(i%k&amp;&amp;(x-i)%k){                     cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; x-i &lt;&lt; '\\n';                     break;                 }             }         }     } }   B. Comparion String (0:10)  꺾은 괄호가 들어가는 문자열에서 숫자를 적절히 배열하여 올바른 식을 만들 때 , 사용할 수 있는 숫자의 최소개수를 구하는 것이다.  연속되는 « $\\dots$와 »$\\dots$의 개수를 세고 거기에 수를 넣는다고 생각하면 연속되는 괄호의 개수 +1이 정답이다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while(tt--){         int n; cin &gt;&gt; n;         string s; cin &gt;&gt; s;         int res = 0;         char pre = 0;         int now = 0;         for(int i=0;i&lt;s.size();i++){             if(s[i]==pre){                 now++;             }else{                 now = 1;                 pre = s[i];             }             res = max(res, now);         }         cout &lt;&lt; res+1 &lt;&lt; '\\n';     } }   C. Best Binary String (0:39)  조금 오래 걸리긴 했다. 그 이유는 reverse의 뜻을 toggle과 혼동했기 때문이다.  0을 1로 바꾸고 1을 0으로 바꾸라는 줄 알았는데 알고보니 substring을 그냥 뒤집는 거였따.  문제를 똑바로 읽기로 다짐한지 2주도 안되었는데 바로 착각해버렸다.  솔직히 영어를 못하는 문제도 조금은 있는 것 같다.  결국 이 문제는 물음표 자리에 바로 이전 것이 들어가면 된다.  문제를 따라가느라 deque을 이용했다. (하지만 필요없을 듯하다, 그래도 연속되는 ?가 있을 수 있으니 자료구조를 이용하긴 해야할듯)  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while(tt--){         string s; cin &gt;&gt; s;         deque&lt;char&gt; dq;         dq.push_back('0');         string res;         for(int i=0;i&lt;s.size();i++){             if(s[i]=='0'){                 dq.push_back('0');             }else if(s[i]=='1'){                 if(dq.front()=='0'){                     while(dq.front()!='0') {                         res += dq.front();                         dq.pop_front();                     }                 }else{                     if(dq.back()=='0'){                         while(!dq.empty()){                             res += dq.front();                             dq.pop_front();                         }                     }                 }                  dq.push_back('1');             }else{                 dq.push_back(dq.back());             }         }         while(!dq.empty()){             res += dq.front();             dq.pop_front();         }         for(int i=1;i&lt;res.size();i++) cout &lt;&lt; res[i];         cout &lt;&lt; '\\n';     } }   이 풀이 말고 관찰을 통해 위 사실을 알아낸뒤  D. Bracket Coloring (1:59 , +3)  솔직히 이 문제를 이렇게나 늦게 푼 것은 온전히 해석 탓이다.  정말 화가 난다. 문제를 제대로 읽지 못해 시간 끈 것이 이 대회만 해도 2개라니….  영어 공부한다고 이런 습관이 고쳐지기는 쉽지 않을 것이다.  문제를 이해 하면 다음과 같다.     올바른 문자열은 - regular 문자열이다.   reverse하여 regular 문자열이 된다면 beautiful 문자열이다.            물론 beautiful 문자열은 regular문자열을 포함한다. (하지만 따로 보는 것이 문제에선 좋다)           이제 색을 칠할 건데, 칠한 색을 쭉 나열했을 땐 beautiful 문자열이어야한다.   따라서 위 내용 중 가장 핵심은  regular랑 beautiful이랑 섞이면 절대로 beautiful이 될 수 없다는 것이다.  그래서 이 문제는 regular와 beautiful을 따로 색칠하는 문제가 된다.  따라서 될 수 있는 Color의 최대값은 2이다.  나는 그냥 beautiful을 뒤집어서 beautiful이면 되는 줄 알았는데….이따구로 이해해서 4틀을 한 내가 너무 한심하다.  하지만 그래도 시간안에 올바르게 이해해서 다시 풀었으니 봐주도록 해야겠따.  (안봐줬을 때 페널티로 할 것도 없음ㅋㅋ)  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while(tt--){         int n; cin &gt;&gt; n;         string s; cin &gt;&gt; s;         vector&lt;int&gt; fr, bk;         for(int i=0;i&lt;n;i++){             if(s[i]=='(') fr.push_back(i);             else bk.push_back(i);         }         if(fr.size()!=bk.size()){             cout &lt;&lt; -1 &lt;&lt; '\\n';             continue;         }          set&lt;int&gt; ST;         vector&lt;int&gt; res(n);         deque&lt;char&gt; dq;         int k1 = 0, k2 = 0;         for(int i=0;i&lt;n;i++){             if(dq.empty()||dq.back()==s[i]) {                 if(s[i]=='('&amp;&amp;i&lt;fr[k1]) continue;                 if(s[i]==')'&amp;&amp;i&lt;bk[k2]) continue;                 dq.push_back(s[i]);             }             else{                 ST.insert((dq.front()=='('));                                  while(!dq.empty()){                     res[fr[k1]] = (dq.front()=='(');                     res[bk[k2]] = (dq.front()=='(');                     k1++; k2++;                     dq.pop_front();                 }                              }         }                  cout &lt;&lt; ST.size() &lt;&lt; '\\n';         for(int ANS : res){             if(ST.size()==1) cout &lt;&lt; 1 &lt;&lt; ' ';             else if(ANS==0) cout &lt;&lt; 1 &lt;&lt; ' ';             else cout &lt;&lt; 2 &lt;&lt; ' ';         }         cout &lt;&lt; '\\n';     } }   E. Playoff Fixing (Upsolving)  문제를 정리해보면 1번팀이 제일 세고 $2^k$번째 팀이 가장 약하다.  이 때 토너먼트는 seed를 받고 그에 따라 결정된다. (1-2번 시드끼리, 3-4번 시드끼리 ….)  토너먼트가 실력대로 결과가 나오도록 조작할 수 있을 때 그렇게 만들 수 있는 경우의 수를 구한다.  예를 들면  1 2 3 4 라면 1번 2번팀이 첫라운드에 싸우니까 절대로 실력대로 결과가 나오지 않는다.  -1 -1 -1 -1 이라면 1번팀은 4군데중 아무데나 갈 수 있고 2번팀은 그 반대라인으로 가면 2개 중하나가 된다. 그리고 3, 4를 배치하는경우의 수가 2개니까 $4 \\times 2 \\times 2$ 가 된다.  위 내용이 문제 정리다.  그럼 어떻게 풀어야 할까?     $2^k$의 팀이 경기를 하면 다음 승자조는 $2^{k-1}$팀이 된다.  (그리고 그 승자조는 팀번호가 낮은 사람들이다. )        이번 턴에 지는 사람 $2^{k-1}$의 배치는 맘대로 할 수 있다. (-1인 경우에)      그래서 지는 사람이 -1이라면 이들의 배치를 신경써야한다.      만약 이기는 사람, 지는 사람이 둘다 -1라면 둘의 배치는 바꿔도 되니까 2를 곱해준다.   불가능한 경우는 기준을 이용해 계산했을 때 떨어지면 안되는 사람이 떨어지면 0을 출력하고 종료한다.   만약에 둘다 -1이 아니고 결정이 되었으면 배치는 신경안써도 된다.   #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const int MOD = 998244353;  int main(){     fast_io     int K; cin &gt;&gt; K;     vector&lt;int&gt; a(1&lt;&lt;K);     for(int i=0;i&lt;(1&lt;&lt;K);i++){         cin &gt;&gt; a[i];         if(a[i]!=-1) --a[i];     }      ll res = 1;     for(int i=K-1;i&gt;=0;i--){         int big = (1 &lt;&lt; i);         int minus_one = 0;         vector&lt;int&gt; na(1 &lt;&lt; i);         for(int j=0;j&lt;(1&lt;&lt;i);j++){             if(a[2*j]&gt;a[2*j+1]) swap(a[2*j], a[2*j+1]); // 앞이 이김              if(a[2*j]==-1){                 if(a[2*j+1]&gt;= (1 &lt;&lt; i)){    //앞이 이기는 경우가 맞음                     big--;                     na[j] = -1;                 }else if(a[2*j+1]!=-1){ //이건 뒤가 이기는 경우임                     na[j] = a[2*j+1];                 }else{      //배치를 맘대로 해도 됨                     na[j] = -1;                     minus_one++;                 }                 continue;             }              if( a[2*j]&lt;(1&lt;&lt;i) == a[2*j+1]&lt; (1 &lt;&lt; i)){      //둘다 기준보다 작으면 안됨                 cout &lt;&lt; 0;                 return 0;             }              na[j] = a[2*j]; //정상적으로 앞이 이김             big--;         }          for(int i=0;i&lt;minus_one;i++) res = res * 2LL % MOD; // 둘의 배치를 바꿀 수 있음         for(int i=1;i&lt;=big;i++) res = 1LL*res * i %MOD; //이긴 것들의 순서 조정         a = na;     }     cout &lt;&lt; res;  }   재밌는 문제였따.  토너먼트 문제는 이긴 사람, 진 사람을 제대로 나누고 생각하는 것이 중요해 보인다."
  },
  
  {
    "title": "코드포스 - 연습중1",
    "url": "/posts/Edu-Codeforce-round-148-(Div-2)/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2023-05-13 00:00:00 +0900",
    "content": "2023-05-13-Edu Codeforce round 148 (Div.2)  개요  에듀라운드가 어려운건지….  에듀라운드는 블루퍼포 이상을 맞아본적이 없는 것 같다.  솔직히 그렇게 큰 차이는 없는데 왜 그러는지는 도저히 모르겠다.  이번 셋은 C까지 매우쉽고 D부터는 좀 어려웠다..  D는 감은 잡았는데 뭔가 구현이 막막해서 못풀었다. (이런 문제 좋아보이는데 많이 풀어보고 싶다. )  A. New Palindrome (0:09)  팰린드롬이다.  뭔가 나는 잘 못푼 것 같다. (그리 깔끔한 코드가 나오지 않아서 그렇게 생각했다. )     등장한 알파벳이 홀수인 것의 개수가 2개 이상이면 팰린드롬 절대 안된다.   1번을 만족하고 짝수인 것이 많으면 무조건 팰린드롬이 여러개 나온다.   그 중 짝수인것이 하나라면 (aaa같은거… 팰린드롬이 하나밖에 안나온다.)            따라서 팰린드롬이 하나인 경우, 원래 문자열이 팰린드롬인지 검사하고 결과를 출력한다.           #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int alpha[26]; int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         string s; cin &gt;&gt; s;         memset(alpha, 0, sizeof(alpha));         for(int i=0;i&lt;s.size();i++){             alpha[s[i]-'a']++;         }         int odd = 0, even = 0;         for(int i=0;i&lt;26;i++){             if(!alpha[i]) continue;             if(alpha[i] &amp; 1){                 odd++;                 if(alpha[i]!=1) even++;             }                              else even++;         }         if(odd&gt;1){             cout &lt;&lt; \"NO\\n\";             continue;         }         if(odd&lt;=1&amp;&amp;even&gt;=2){             cout &lt;&lt; \"YES\\n\";             continue;         }                  if(odd&lt;=1&amp;&amp;even==1){             bool ok = true;             for(int i=0;i&lt;s.size()/2;i++){                 if(s[i]!=s[s.size()-1-i]) ok = false;             }             if(ok){                 cout &lt;&lt; \"NO\\n\";             }else{                 cout &lt;&lt; \"YES\\n\";             }         }     } }   B. Maximum Sum (0:26)  좋은 문제 같다. 처음에는 우선순위큐로 접근했는데 단순히 이번경우가 더 작다고 그리디하게 뺴버리면 다음 경우가 최선이 아닐 수 있다. 따라서 정렬된 배열에서 앞에서 몇번, 뒤에서 몇번 빼는지를 모두 세주고 그중 최대값을 찾아주는 것이 옳다.  나는 부분합을 구하고 전체(sum)에서 빼는 식으로 구현했다.  ll res =0; for(int i=0;i&lt;=k;i++){   res = max(res, sum - psa[2*k-2*i] - (psa[n]-psa[n-i])); }   이 부분이 가장 핵심적인 부분이다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n, k; cin &gt;&gt; n &gt;&gt; k;         vector&lt;ll&gt; a(n+1), psa(n+1);         ll sum = 0;         for(int i=1;i&lt;=n;i++){             cin &gt;&gt; a[i];             sum += a[i];         }         sort(a.begin(), a.end());         for(int i=1;i&lt;=n;i++){             psa[i] = psa[i-1] + a[i];         }                  ll res =0;         for(int i=0;i&lt;=k;i++){             res = max(res, sum - psa[2*k-2*i] - (psa[n]-psa[n-i]));         }                  cout &lt;&lt; res &lt;&lt; '\\n';     } }   C. Contrast Value (0:55)  이 문제는 증가하는 부분, 감소하는 부분을 세는 문제로 바꿀 수 있다.  이를 알아내는 것이 그렇게 어렵지 않다..너무 직관적이기 때문이다.  나는 중간에 같은 부분을 처리하는데에서 이상하게 처리하여서 시간이 좀 걸렸다.  같은 원소는 그냥 가볍게 무시하면 된다.  예를 들어 1 2 2 3 3 3 4 4 4 5 5 3 1 이라는 배열이 있어도 이거는 1 5 1 로 줄일 수 있기 때문이다.  따라서 증가하는 부분 + 감소하는 부분 +1 이 정답이다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n; cin &gt;&gt; n;         vector&lt;ll&gt; a(n+1);         for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i];         a[0] = a[1];         int res = 0;         int state = 0;         for(int i=2;i&lt;=n;i++){             if(a[i]&gt;a[i-1]){                 if(state==1){                     continue;                 }else{                     res++;                 }                 state = 1;             }else if(a[i]==a[i-1]){                 continue;             }else{                 if(state==-1){                     continue;                 }else{                     res++;                 }                 state = -1;             }         }                  cout &lt;&lt; res+1 &lt;&lt; '\\n';     } }   D&amp;E. Red-Blue Operation(Upsolving)  이 문제를 1시간 정도 봤는데 못풀었다.  근데 중간에 내 문제를 발견한게….내가 집중을 못하고 있었다.  문제를 읽고 갑자기 침대에 눕질 않나… 물이나 따르러 나가질 않나….  뭔가 문제 이해를 제대로 못했을 때 머리속에 잡념이 생기며 시간을 축내고 있었던 것이다.  2시간은 온전히 집중할 수 있는 내가 될 수 있도록해야겠다. 요즘 집중을 너무 못한다.  공부도 1시간 이상 앉아있기가 힘들다. 이 문제를 고칠 수 있는 방법을 아는 사람은 연락 바란다.  문제는 hard를 기준으로 풀어보겠다.  쨋든 문제를 이해해보면  1부터 k까지 더하는 연산, 빼는 연산을 적절히 하여 최솟값을 가장 크게 만드는 것이다.  일단, 한 원소에 홀수번 연산을 하면 값이 줄어들고, 짝수번 연산을 하면 값이 늘어난다.  따라서 2k가 2n으로 나누어지면 모든 원소의 값을 늘릴 수 있겠지만 그 경우가 아니라면 홀수번 접근하여 -연산을 해야하는 경우가 생길 것이다.  그 때 $+1-2$ 를 하여 -1을 빼주는 것이 이득이다.  여기까지가 내가 떠올린 것이고 집중력이 다해 풀지 못했다. 이제 어떻게 해야할까?     배열을 정렬해준다.   k &lt; n일 때는 구하기 쉽다.        k ≥ n 인데 결국 빼는 연산이 필요한 경우는 제일 작은거랑 고루고루 -1씩 뺐을 때랑 비교해야한다.      제일 작은건 k&lt;n일 떄처럼 구하면 되는데 고루고루 -1씩 뺐을 때가 문제다.      고루고루 -1씩 뺏을 때 최선은 모든 경우가 다 같은경우이다. 그래서 연산을 했을 때 모든 원소를 합한 값을 n으로 나눠가지는 경우와 비교하면 된다.      예를 들어, 2 4 4 5 8의 원소들이 있고 k = 7이라고 해보자. 그러면 일단 각 원소에 7, 6, 5, 4, 3을 더할 것이다.  그리고 나머지 2, 1은 하나는 더하고 하나는 뺄 것이다.  다시 저 원소들에 k = 14라고 해보자. 그러면 14, 13, 12, 11, 10을 더하고 나머지 1부터 9로 생기는 경우는 한 원소에 2개씩 적용시켜 (남은 수+1)/2가 될 것이다.  즉 -5이다. 그러면  [2+4+4+5+8 (원래 원소합)+ 14+13+12+11+10(n개에 최대 수를 더하고) - \\frac{남은 수}{2}]  이런 식으로 된다.  위 수학 공식 블록의 논리를 이해하면 아래 코드도 이해할 수 있다 .  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const int INF = 1e9+1;  int main(){     fast_io     int n, q; cin &gt;&gt; n &gt;&gt; q;     vector&lt;ll&gt; a(n), pre(n+1, INF);     ll sum = 0;     for(int i=0;i&lt;n;i++){         cin &gt;&gt; a[i];         sum += a[i];     }     sort(a.begin(), a.end());     for(int i=0;i&lt;n;i++){         pre[i+1] = min(pre[i], a[i]-i);     }      for(int i=0;i&lt;q;i++){         ll k; cin &gt;&gt; k;         if(k&lt;n){                cout &lt;&lt; min(pre[k]+k, a[k]) &lt;&lt; ' ';             continue;         }            if(k%2 != n%2){             cout &lt;&lt; min(min(pre[n-1]+k, a[n-1]), (sum + (k-n+2+k)*(n-1)/2-(k-n+1)/2)/n) &lt;&lt; ' ';         }else{             cout &lt;&lt; min(pre[n]+k, (sum+(k-n+1+k)*n/2-(k-n)/2)/n) &lt;&lt; ' ';         }     } }"
  },
  
  {
    "title": "Heavy-Light decomposition",
    "url": "/posts/HLD/",
    "categories": "BOJ",
    "tags": "heavy-light분할, 트리",
    "date": "2023-05-12 00:00:00 +0900",
    "content": "HLD(Heavy Light Decomposition)   💡 트리에서 임의의 두 정점을 잇는 경로에 대한 쿼리가 궁금할 때.    구현과정  구현과정은 jinhan님의 블로그 를 참고하여 구현했다.     가중치가 있는 그래프라면 adj에 가중치 없는 그래프를 만들고, cost[정점]에 해당 정점으로 갈 때 드는 비용을 저장한다. 그리고 input[i] = {u, v}이런 식으로 정점에 번호를 붙여준다.(세그트리로 다루기 위함)   dfs1을 돌면서 각 정점의 깊이(dep), 각 정점의 부모 정점(par), 각 정점이 만드는 서브트리 크기(sz)를 저장한다. 이 때 adj[정점][0]에는 가장 무거운 간선이 되도록 한다.   dfs2를 돌면서 오일러투어 테크닉을 적용하고 정점이 무거운 간선을 지니는 정점인지를 체크한다. (top)   정리해보면     input[i] = i번째 정점은 {xx정점, yy정점}를 잇는 간선입니다.   inp[i] : 직접 입력 받은 가중치가 있는 인접 리스트 그래프   adj[i] : inp을 바꿔서 가중치를 떼어낸 그래프   cost[i] : i번 째 정점까지 가는데 드는 가중치(비용)   dep, par, sz는 위에 설명했고   in, out → 오일러 투어 테크닉(DFS ordering)하고 난 결과 in[어떤 정점]이  지칭하는 간선 번호   top[i] : i번 정점이 무거운 간선을 포함하면 0 아니면 무거운 간선을 포함하는 정점을 저장해둠.   이제 우리의 문제를 해결해보자!     두 정점을 잇는 경로에서 가장 큰 가중치를 가진 간선은 무엇일까?   이 때, 간선의 가중치는 변할 수 있다.  → 13510 트리와 쿼리   위의 문제를 해결할 것 이다.  //update 연산 , xst는 maxSegmentTree이다. // i 번 간선을 val로     void update(T i, T val){         if(dep[input[i].xx] &lt; dep[input[i].yy]) swap(input[i].xx, input[i].yy);         xst.update(in[input[i].xx], val, 1, 1, n);     }   위 코드를 보면 dep가 깊은 정점에 해당하는 간선을 val로 변화시킨다.  2번에 해당하는 코드이다.  //query 연산 //u, v위 가장 큰 가중치     T query(T u, T v){         T ret = 0;         while(top[u]!=top[v]){             if(dep[top[u]] &lt; dep[top[v]]) swap(u, v);             int st = top[u];             ret = max(ret, xst.xquery(in[st], in[u], 1, 1, n));             u = par[st];         }         if(u==v) return ret;         if(dep[u] &gt; dep[v]) swap(u, v);         T nxt = -1;         for(auto i : adj[u]) if(top[i]==top[u]) nxt = i;         ret = max(ret, xst.xquery(in[nxt], in[v], 1, 1, n));         return ret;     }   이는 1번 - 즉 경로에서 가장 큰 가중치를 구하는 쿼리이다.    top[어떤 정점]은 간선 분류의 맨 위로 올라간다는 뜻이다.  예를 들어 5 - 7로 간다고 하면     5랑 7의 깊이가 같으니까 u = 5, v = 7   u를 st = top[u] = 2이다.  파란 간선이 끝나는 정점까지 가고   이 때 세그먼트 트리로 경로 상 파란 간선을 모두 더한다(최대값을 찾는다).   다음엔 u = 7, v = 2가 될 것이고 top[u] = 1이다. → 경로 상 노란간선을 모두 더한다.(최대값을 찾는다)   다음엔 u = 2, v = 1이 될 것이고 top[2] = 1이다. → 경로 상 빨간 간선을 모두 더한다.(최대값을 찾는다)   이런 식으로 무거운 간선을 통해 분류한 간선으로 쭉쭉 이동하면서 처리하는 것이 HLD이다.  이때 이 간선의 종류가 $logN$개 이므로 세그먼트 트리를 하는 $logN$과 합쳐  총 시간 복잡도 : $O((logN)^2)$으로 각 쿼리를 해결 할 수 있는 것이다.  13309 트리  트리가 가중치 1로 모두 연결 되어있다고 하고 연결이 끊어지면 update연산으로 해당간선의 가중치를 0으로 바꿔준다. 그리고나서 구한 경로의 길이가 $dep[u] + dep[v] - dep[lca(u, v)]$ 와 같다면 경로가 존재하는 것이고 나머지 경우는 경로가 존재하지 않는 것이다.  코드는 아래와 같다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const int MAXSIZE = 2e5+1;  // 구간합 세그 template &lt;class T&gt; class Segtree{ public:     static const int TREESIZE = 4*MAXSIZE;     T* tree = new T[TREESIZE];      Segtree(){         for(int i=0;i&lt;TREESIZE;i++) tree[i] = 0;     }     ~Segtree(){         delete[] tree;     }     T update(T x, T v, T node, T S, T E){         if(S==E) return tree[node] = v; // 원소교체연산, 더하기면 +하셈                  T mid = (S+E)&gt;&gt;1;         if(x&lt;=mid) update(x, v, 2*node, S, mid);         else update(x, v, 2*node+1, mid+1, E);         return tree[node] = tree[2*node]+tree[2*node+1];     }     T kth(T node, T S, T E, T K){         if(S==E) return S;         T mid = (S+E)&gt;&gt;1;         if(tree[2*node]&gt;=K) return kth(2*node, S, mid, K);         else return kth(2*node+1, mid+1, E, K-tree[2*node]);     }     T query(T L, T R, T node, T S, T E){         if(L&gt;E||R&lt;S) return 0;         if(L&lt;=S&amp;&amp;E&lt;=R) return tree[node];         T mid = (S+E)&gt;&gt;1;         return query(L, R, 2*node, S, mid)+query(L, R, 2*node+1, mid+1, E);     } }; // 경로 중 최대값 찾기 template &lt;class T&gt; class HLD{ public:     int n;     T cost[MAXSIZE], sz[MAXSIZE], dep[MAXSIZE], par[MAXSIZE];     T top[MAXSIZE], in[MAXSIZE], out[MAXSIZE];     vector&lt;pair&lt;T, T&gt;&gt; input, inp[MAXSIZE];     vector&lt;T&gt; adj[MAXSIZE];          bool visited[MAXSIZE];          void dfs(int now = 1){         visited[now] = 1;         for(auto [ncost, nxt] : inp[now]){             if(visited[nxt]) continue;             adj[now].push_back(nxt);             cost[nxt] = ncost;             dfs(nxt);         }     }          void dfs1(int now = 1){         sz[now] = 1;         for(T&amp; nxt : adj[now]){             dep[nxt] = dep[now]+1;             par[nxt] = now;             dfs1(nxt);             sz[now] += sz[nxt];             if(sz[nxt]&gt;sz[adj[now][0]]) swap(nxt, adj[now][0]); //adj[now][0]에는 가장큰것 (heavy)         }     }          int tmp = 0;     void dfs2(int now = 1){         in[now] = ++tmp;         for(T nxt : adj[now]){             top[nxt] = (nxt==adj[now][0] ? top[now] : nxt);             dfs2(nxt);         }         out[now] = tmp;     }          Segtree&lt;T&gt; st;          // i 번 간선을 val로     void update(T i, T val){         if(dep[input[i].xx] &lt; dep[input[i].yy]) swap(input[i].yy, input[i].xx);         st.update(in[input[i].xx], val, 1, 1, n);     }          //u, v위 가장 큰 가중치     T query(T u, T v){         T ret = 0;         while(top[u]!=top[v]){             if(dep[top[u]] &lt; dep[top[v]]) swap(u, v);             int ST = top[u];             ret += st.query(in[ST], in[u], 1, 1, n);             u = par[ST];         }         if(u==v) return ret;         if(dep[u] &gt; dep[v]) swap(u, v);         ret += st.query(in[u], in[v], 1, 1, n);         int LCA = lca(u, v);         ret -= st.query(in[LCA], in[LCA], 1, 1, n);         return ret;     }          int lca(int u, int v) {         while (top[u] != top[v]) {             if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);             u = par[top[u]];         }         if (dep[u] &gt; dep[v]) swap(u, v);         return u;     }          void precal(){         input = vector&lt;pair&lt;T, T&gt; &gt; (n+1);         for(int i=2;i&lt;=n;i++){             int p; cin &gt;&gt; p;             input[i-1] = {p, i};             inp[p].push_back({1, i});             inp[i].push_back({1, p});         }         for(int i=1;i&lt;=n;i++){             st.update(i, 1, 1, 1, n);         }         top[1] = 1;         dfs(); dfs1(); dfs2();     } }; HLD&lt;int&gt; hld;  int main(){     fast_io     int n, q; cin &gt;&gt; n &gt;&gt; q;     hld.n = n;     hld.precal();     while (q--) {         int u, v, o; cin &gt;&gt; u &gt;&gt; v &gt;&gt; o;         bool ok = false;         if(hld.query(u, v)==hld.dep[u]+hld.dep[v]-2*hld.dep[hld.lca(u, v)]){             ok = true;             cout &lt;&lt; \"YES\\n\";         }else{             cout &lt;&lt; \"NO\\n\";         }         if(o){             if(ok) hld.st.update(hld.in[u], 0, 1, 1, n);             else hld.st.update(hld.in[v], 0, 1, 1, n);         }              } }   13512 트리와 쿼리3     1번 쿼리는 트리의 색을 바꾸는 연산은 XOR 1연산을 통해 해결 할 수 있을 것이다.   2번 쿼리는 1번 부터 해당 정점으로 가면서 가장 먼저 나오는 1을 찾으면 된다.   2번 쿼리를 처리하는 것이 문제인데…  가장 먼저 나오는 1을 구하는 방법은 이분 탐색을 이용하면 된다.  T bisearch(T L, T R){         if(!query(L, R, 1, 1, MAXSIZE)) return -1;         T lo = L-1 , hi = R;         while(lo+1&lt;hi){             T mid = (lo+hi)&gt;&gt;1; //L부터 검사하는게 중요!! lo는 off-by-one error땜에 1을 뺏음             if(query(L, mid, 1, 1, MAXSIZE)){                 hi = mid;             }else{                 lo = mid;             }         }         return hi;     }   이를 이용하여 구간에 1이 존재하지 않으면 바로 -1 리턴  구간에 존재하면 가장 먼저나오는 곳의 dfs order 번호를 리턴한다.  문제는 가장 먼저 1이 나오는 곳의 정점 idx를 출력하는 것이기 때문에 dfs ordering을 할 때 역함수를 구해놓는 것이 편하다.  나는 R이라는 배열을 이용했다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const int MAXSIZE = 1e5+1;  // 구간합 세그 template &lt;class T&gt; class Segtree{ public:     static const int TREESIZE = 4*MAXSIZE;     T* tree = new T[TREESIZE];      Segtree(){         for(int i=0;i&lt;TREESIZE;i++) tree[i] = 0;     }     ~Segtree(){         delete[] tree;     }     T update(T x, T v, T node, T S, T E){         if(S==E) return tree[node] ^= v; // 원소교체연산, 더하기면 +하셈                  T mid = (S+E)&gt;&gt;1;         if(x&lt;=mid) update(x, v, 2*node, S, mid);         else update(x, v, 2*node+1, mid+1, E);         return tree[node] = tree[2*node]+tree[2*node+1];     }     T kth(T node, T S, T E, T K){         if(S==E) return S;         T mid = (S+E)&gt;&gt;1;         if(tree[2*node]&gt;=K) return kth(2*node, S, mid, K);         else return kth(2*node+1, mid+1, E, K-tree[2*node]);     }     T query(T L, T R, T node, T S, T E){         if(L&gt;E||R&lt;S) return 0;         if(L&lt;=S&amp;&amp;E&lt;=R) return tree[node];         T mid = (S+E)&gt;&gt;1;         return query(L, R, 2*node, S, mid)+query(L, R, 2*node+1, mid+1, E);     }     T bisearch(T L, T R){         if(!query(L, R, 1, 1, MAXSIZE)) return -1;         T lo = L-1 , hi = R;         while(lo+1&lt;hi){             T mid = (lo+hi)&gt;&gt;1;             if(query(L, mid, 1, 1, MAXSIZE)){                 hi = mid;             }else{                 lo = mid;             }         }         return hi;     } }; // 경로 중 최대값 찾기 template &lt;class T&gt; class HLD{ public:     int n;     T cost[MAXSIZE], sz[MAXSIZE], dep[MAXSIZE], par[MAXSIZE];     T top[MAXSIZE], in[MAXSIZE], out[MAXSIZE];     T R[MAXSIZE]; //in의 역함수를 설정했음     vector&lt;pair&lt;T, T&gt;&gt; input, inp[MAXSIZE];     vector&lt;T&gt; adj[MAXSIZE];          bool visited[MAXSIZE];          void dfs(int now = 1){         visited[now] = 1;         for(auto [ncost, nxt] : inp[now]){             if(visited[nxt]) continue;             adj[now].push_back(nxt);             cost[nxt] = ncost;             dfs(nxt);         }     }          void dfs1(int now = 1){         sz[now] = 1;         for(T&amp; nxt : adj[now]){             dep[nxt] = dep[now]+1;             par[nxt] = now;             dfs1(nxt);             sz[now] += sz[nxt];             if(sz[nxt]&gt;sz[adj[now][0]]) swap(nxt, adj[now][0]); //adj[now][0]에는 가장큰것 (heavy)         }     }          int tmp = 0;     void dfs2(int now = 1){         in[now] = ++tmp;         R[tmp] = now;         for(T nxt : adj[now]){             top[nxt] = (nxt==adj[now][0] ? top[now] : nxt);             dfs2(nxt);         }         out[now] = tmp;     }          Segtree&lt;T&gt; st;          // i 번 간선을 val로     void update(T i, T val){         if(dep[input[i].xx] &lt; dep[input[i].yy]) swap(input[i].yy, input[i].xx);         st.update(in[input[i].xx], val, 1, 1, n);     }          //u, v위 가장 먼저나오는 1     T query(T u, T v){         T ret = -1;         while(top[u]!=top[v]){             if(dep[top[u]] &lt; dep[top[v]]) swap(u, v);             int ST = top[u];             int now = st.bisearch(in[ST], in[u]);             if(now&gt;0) ret = now;             u = par[ST];         }                      if(dep[u] &gt; dep[v]) swap(u, v);         int now = st.bisearch(in[u], in[v]);         if(now&gt;0) ret = now;         return ((ret==-1) ? ret : R[ret]);     }          int lca(int u, int v) {         while (top[u] != top[v]) {             if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);             u = par[top[u]];         }         if (dep[u] &gt; dep[v]) swap(u, v);         return u;     }          void precal(){         input = vector&lt;pair&lt;T, T&gt; &gt; (n+1);         for(int i=2;i&lt;=n;i++){             int u, v; cin &gt;&gt; u &gt;&gt; v;             input[i-1] = {u, v};             inp[u].push_back({1, v});             inp[v].push_back({1, u});         }         top[1] = 1;         dfs(); dfs1(); dfs2();     } }; HLD&lt;int&gt; hld;  int main(){     fast_io     int n, q; cin &gt;&gt; n;     hld.n = n;     hld.precal();     cin &gt;&gt; q;     while (q--) {         int op, v; cin &gt;&gt; op &gt;&gt; v;         if(op==1){             hld.st.update(hld.in[v], 1, 1, 1, MAXSIZE);         }else{             cout &lt;&lt; hld.query(1, v) &lt;&lt; '\\n';         }     } }   2927 남극탐험  우리는 트리 구조가 확정된 상태에서 HLD를 이용하여 문제를 풀었지만 이 문제는 트리 구조가 완성되어 있지 않다. 이런 경우 완성 되었을 때의 문제로 치환을 하는 것이 필요하다.  이 때 오프라인 쿼리를 이용할 수 있다.  일단, bridge연산은 Union Find를 떠올릴 수 있다. 그렇기 때문에 이 연산을 통해 만들어진 그래프는 무조건 트리 형태이다. 하지만 bridge연산이 정확히 n-1개의 yes가 나온다는 보장이 없기 때문에 여러 트리가 만들어 질 수 있다. 여러 트리를 합쳐서 하나의 트리를 만드는 아이디어를 떠올릴 수 있었다.  이제 excursion 연산에 대해 고민해보자.  excursion은 일단 길이 없으면 “inpossible”을 출력한다. 근데 이 경우는 그냥 순서대로 보면서도 해결 할 수 있다. 나머지 길이 있는 경우는 트리에서는 정점 u, v 사이의 길이 하나 밖에 없기 때문에 그냥 HLD이용하면 된다.  결론 :  → 순서대로 보면서 excursion중에 불가능한 거는 미리 골라 둔다.  → 이제 완성된 트리를 가지고 쿼리를 거꾸로 보면서 경로 쿼리로 길이 있는 경우를 계산한다.  → penguins 연산은 역으로 돌아가는 식으로 해야한다. (세그먼트 트리 update하면 된다. )     마지막으로 결과를 출력할 때            bridge라면                    미리 저장된 1 → yes 0 → no                       penguins라면                    continue                       excursion라면                    Unionfind로 평가했을 때 이미 -1 → “impossible”           그게 아니라면 query(a, b)                           자세한건 아래 코드에서 주석 처리로 보이겠다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const int MAXSIZE = 3e4+1; int P[MAXSIZE];  struct DisjointSet{     vector&lt;int&gt; parent, rank;          DisjointSet(int n):parent(n+1),rank(n+1, 0){         for(int i=0;i&lt;=n;i++){             parent[i] = i;         }     }          int find(int u){         if(u==parent[u]) return u;         return parent[u] = find(parent[u]);     }          bool merge(int u, int v){         u = find(u);         v = find(v);         if(u==v) return true;                  if(rank[u]&gt;rank[v]) swap(u, v);         parent[u] = v;         if(rank[u]==rank[v]) rank[v]++;         return false;     }     bool check(int u, int v){         u = find(u);         v = find(v);         if(u==v) return true;         return false;     } };  // 구간합 세그 template &lt;class T&gt; class Segtree{ public:     static const int TREESIZE = 4*MAXSIZE;     T* tree = new T[TREESIZE];      Segtree(){         for(int i=0;i&lt;TREESIZE;i++) tree[i] = 0;     }     ~Segtree(){         delete[] tree;     }     T update(T x, T v, T node, T S, T E){         if(S==E) return tree[node] = v; // 원소교체연산, 더하기면 +하셈                  T mid = (S+E)&gt;&gt;1;         if(x&lt;=mid) update(x, v, 2*node, S, mid);         else update(x, v, 2*node+1, mid+1, E);         return tree[node] = tree[2*node]+tree[2*node+1];     }     T kth(T node, T S, T E, T K){         if(S==E) return S;         T mid = (S+E)&gt;&gt;1;         if(tree[2*node]&gt;=K) return kth(2*node, S, mid, K);         else return kth(2*node+1, mid+1, E, K-tree[2*node]);     }     T query(T L, T R, T node, T S, T E){         if(L&gt;E||R&lt;S) return 0;         if(L&lt;=S&amp;&amp;E&lt;=R) return tree[node];         T mid = (S+E)&gt;&gt;1;         return query(L, R, 2*node, S, mid)+query(L, R, 2*node+1, mid+1, E);     } }; // 경로 중 최대값 찾기 template &lt;class T&gt; class HLD{ public:     int n;     T cost[MAXSIZE], sz[MAXSIZE], dep[MAXSIZE], par[MAXSIZE];     T top[MAXSIZE], in[MAXSIZE], out[MAXSIZE];     vector&lt;pair&lt;T, T&gt;&gt; input, inp[MAXSIZE];     vector&lt;T&gt; adj[MAXSIZE];          bool visited[MAXSIZE];          void dfs(int now = 0){         visited[now] = 1;         for(auto [ncost, nxt] : inp[now]){             if(visited[nxt]) continue;             adj[now].push_back(nxt);             cost[nxt] = ncost;             dfs(nxt);         }     }          void dfs1(int now = 0){         sz[now] = 1;         for(T&amp; nxt : adj[now]){             dep[nxt] = dep[now]+1;             par[nxt] = now;             dfs1(nxt);             sz[now] += sz[nxt];             if(sz[nxt]&gt;sz[adj[now][0]]) swap(nxt, adj[now][0]); //adj[now][0]에는 가장큰것 (heavy)         }     }          int tmp = -1;     void dfs2(int now = 0){         in[now] = ++tmp;         for(T nxt : adj[now]){             top[nxt] = (nxt==adj[now][0] ? top[now] : nxt);             dfs2(nxt);         }         out[now] = tmp;     }          Segtree&lt;T&gt; st;          // i 번 간선을 val로     void update(T i, T val){         if(dep[input[i].xx] &lt; dep[input[i].yy]) swap(input[i].yy, input[i].xx);         st.update(in[input[i].xx], val, 1, 0, n);     }          //u, v경로상 펭귄의 수     T query(T u, T v){         T ret = 0;         while(top[u]!=top[v]){             if(dep[top[u]] &lt; dep[top[v]]) swap(u, v);             int ST = top[u];             ret += st.query(in[ST], in[u], 1, 0, MAXSIZE);             u = par[ST];         }         if(dep[u] &gt; dep[v]) swap(u, v);         ret += st.query(in[u], in[v], 1, 0, MAXSIZE);         return ret;     }          int lca(int u, int v) {         while (top[u] != top[v]) {             if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);             u = par[top[u]];         }         if (dep[u] &gt; dep[v]) swap(u, v);         return u;     }          void precal(){         for(int i=1;i&lt;=n;i++){             inp[0].push_back({1, i});             inp[i].push_back({1, 0});         }                  top[0] = 1;         dfs(); dfs1(); dfs2();     } };  DisjointSet uf(MAXSIZE); HLD&lt;int&gt; hld;  class Data{ public:     string op;     int a, b ,idx, p,q; };  pair&lt;string, int&gt; ans[300005]; int main(){     fast_io     int n; cin &gt;&gt; n;     hld.n = n;     for(int i=1;i&lt;=n;i++) cin &gt;&gt; P[i];     int q; cin &gt;&gt; q;     vector&lt;Data&gt; Q(q+1);     for(int i=1;i&lt;=q;i++){         string op;         int a, b;         cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;         if(op==\"bridge\"){             if(uf.merge(a, b)){//이미 합쳐져있음                 ans[i] = {\"bridge\", 0};             }else{//합쳐야함                 ans[i] = {\"bridge\", 1};                 hld.inp[a].push_back({1, b});                 hld.inp[b].push_back({1, a});             }             Q[i] = {op, a, b, i, -1, -1};                      }else if(op==\"penguins\"){             Q[i] = {op, a, b, i, P[a], b};             P[a] = b;         }else{             if(uf.check(a, b)){ //이미 합쳐져 있음                 Q[i] = {op, a, b, i, a, b};             }else{                 ans[i] = {\"excursion\", -1};                 Q[i] = {op, a, b, i, -1, -1};             }         }     }          hld.precal();   //0이 루트인 하나의 트리     for(int i=1;i&lt;=n;i++){ //펭귄을 각 섬에 넣어줌         hld.st.update(hld.in[i], P[i], 1, 0, MAXSIZE);     }               for(int i=q;i&gt;=1;i--){         if(Q[i].op==\"bridge\") continue; \t        if(Q[i].op==\"penguins\"){             hld.st.update(hld.in[Q[i].a], Q[i].p, 1, 0, MAXSIZE);             ans[Q[i].idx] = {Q[i].op, 0};         }else{             if(Q[i].p==-1) continue;             ans[Q[i].idx] = {Q[i].op, hld.query(Q[i].a, Q[i].b)};         }     }          for(int i=1;i&lt;=q;i++){         if(ans[i].xx==\"bridge\"){             if(ans[i].yy) cout &lt;&lt; \"yes\\n\";             else cout &lt;&lt; \"no\\n\";         }else if(ans[i].xx==\"penguins\"){             continue;         }else{             if(ans[i].yy==-1) cout &lt;&lt; \"impossible\\n\";             else cout &lt;&lt; ans[i].yy &lt;&lt; '\\n';         }     } }"
  },
  
  {
    "title": "행렬 거듭제곱",
    "url": "/posts/%ED%96%89%EB%A0%AC%EA%B1%B0%EB%93%AD%EC%A0%9C%EA%B3%B1/",
    "categories": "BOJ",
    "tags": "행렬거듭제곱, matrix",
    "date": "2023-05-10 00:00:00 +0900",
    "content": "행렬 거듭 제곱   💡 DP 점화식이 선형 방정식인 경우    $ a_n = \\sum_{k=1}^{m}{c_k*a_{n-k}} $  위와 같은 형태의 점화식일 때 $O(m^3log(n))$ 에 n번째 항을 구할 수 있다.  분할정복을 이용한 행렬 거듭제곱 $O(log(n))$  예를 들어 피보나치 수를 생각해보자  [\\begin{bmatrix} F_2  F_1 \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 1  1 &amp; 0 \\end{bmatrix} \\begin{bmatrix} F_1  F_0 \\end{bmatrix}, \\begin{bmatrix} F_3  F_2 \\end{bmatrix} = {\\begin{bmatrix} 1 &amp; 1  1 &amp; 0 \\end{bmatrix}}^2\\begin{bmatrix} F_2  F_1 \\end{bmatrix} \\dots]  [\\begin{bmatrix} F_n  F_{n-1} \\end{bmatrix} = {\\begin{bmatrix} 1 &amp; 1  1 &amp; 0 \\end{bmatrix}}^{n-1}\\begin{bmatrix} F_{n-1}  F_{n-2} \\end{bmatrix}]  이렇게 정리할 수 있다.  그래프의 이동 경로 경우의 수  [ADJ= \\begin{bmatrix} 0 &amp; 1 &amp; 1  1 &amp; 0 &amp; 1  1 &amp; 1 &amp; 0\\end{bmatrix}]  인접 행렬이 이런 식으로 되어 있다면 삼각형을 떠올릴 수 있다.  [{\\begin{bmatrix} 0 &amp; 1 &amp; 1  1 &amp; 0 &amp; 1  1 &amp; 1 &amp; 0\\end{bmatrix}}^2 =  \\begin{bmatrix} 2 &amp; 1 &amp; 1  1 &amp; 2 &amp; 1  1 &amp; 1 &amp; 2\\end{bmatrix}]  제곱 한 결과는 2번 이동했을 때 1번 정점에 다시 돌아 오는 경우는 2개, 1→2는 1가지, 1→3은 1가지 이런식이다.  3번 이동한 결과는 어떻게 될까  [{\\begin{bmatrix} 0 &amp; 1 &amp; 1  1 &amp; 0 &amp; 1  1 &amp; 1 &amp; 0\\end{bmatrix}}^3 =  \\begin{bmatrix} 2 &amp; 3 &amp; 3 \\ 3 &amp; 2  &amp;3 \\ 3 &amp;3 &amp; 2\\end{bmatrix}]  3번 이동했을 때 다시 제자리로 오려면 한쪽 방향으로 쪽 가면 되니까 2가지  나머지 경우는 뒤를 -1 앞을 1이라고 하면 {-1, 1, 1} ,  {1, -1, 1}, {1, 1,- 1} 이런식으로 3가지 방식이 있다.  중요한 것은   💡 행렬 제곱을 하면 한 정점에서 다른 정점까지 가는 경우의 수를 알 수 있다.    12850 본대산책2  각 정점을 숫자는 알아서 설정하고 인정행렬을 만든다.  그리고 제곱을 한뒤에 $matrix[과학관정점][과학관정점]$ 을 하면 답이다.  시간 복잡도는 $O(8^3log(D))$로 풀 수 있을 것이다.  아래가 코드이다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const ll MOD = 1e9+7; class matrix{ public:     vector&lt;vector&lt;ll&gt;&gt; mat;          void initialize(int a, int b){         mat.assign(a, vector&lt;ll&gt;(b,0));     }          void input(){         mat = { {0, 1, 1, 0, 0, 0, 0, 0},                 {1, 0, 1, 1, 0, 0, 0, 0},                 {1, 1, 0, 1, 1, 0, 0, 0},                 {0, 1, 1, 0, 1, 1, 0, 0},                 {0, 0, 1, 1, 0, 1, 1, 0},                 {0, 0, 0, 1, 1, 0, 0, 1},                 {0, 0, 0, 0, 1, 0, 0, 1},                 {0, 0, 0, 0, 0, 1, 1, 0},         };     }          matrix operator*(matrix A){         matrix result;         result.initialize(mat.size(), A.mat[0].size());         for(int i=0;i&lt;mat.size();i++){             for(int j=0;j&lt;A.mat[0].size();j++){                 for(int k=0;k&lt;A.mat.size();k++){                     result.mat[i][j] += mat[i][k]*A.mat[k][j];                     result.mat[i][j] %= MOD;                 }             }         }         return result;     }      };  matrix mat;  matrix powMat(matrix &amp;mat, ll b){     if(b==1){         return mat;     }          matrix half = powMat(mat, b/2);     matrix ret = (half*half);     if(b&amp;1) return ret*mat;     return ret; }  int main(){     fast_io     ll D; cin &gt;&gt; D;     mat.input();     matrix res = powMat(mat, D);     cout &lt;&lt; res.mat[0][0]; }   1533 길의 개수  이 문제는 인접행렬에 가중치가 있다.  그래서 단순히 가중치를 포함하여 경우의 수를 구할 수는 없다.  그러면 아까 풀었던 문제로 치환 해야하는데 가중치를 없는 것 처럼 만드는 방법은 가중치만큼 반복하는 것이다.  예를 들어  [\\begin{bmatrix} 0 &amp; 1 &amp; 2  1 &amp; 0 &amp; 1  1 &amp; 2 &amp; 0\\end{bmatrix}]     다음과 같은 행렬이 있으면 1→3까지 가는데 2분이 걸린다.   그럼 1분후 다른 정점에 들렀다가   다시 1분후 원래 목적지에 도착한다.   이런 식으로 푼다면 1가지 경우의 수로 목적지에 잘 도착하되, 1분단위로 계산할 수 있게 되었다.  시간의 범위는 5이내 이니까 n개의 정점 이외 4개의 정점을 만들었다. n+1, n+2, n+3, n+4  만약에 시간이 3분 걸리면 n+3로 간다. (src → n+3 → n+4 → dest)  화살표가 3개있으니까 3분 걸리는게 맞다.  근데 이대로 구현하니까 값이 더 크게 나왔따. (틀렸단 뜻)  graph TD; \tA--&gt;C; \tB--&gt;C; \tC--&gt;D; \tC--&gt;E;   graph TD; \tA--&gt;C1; \tB--&gt;C2; \tC1--&gt;D; \tC2--&gt;E;   위 와 같은 그래프가 있다고 하면 당연히 경로의 수는 왼쪽은 4가지, 오른쪽은 2가지가 된다.  그리고 우리가 찾고 싶은 경로는 오른쪽이다. 그러면 각 정점마다 경유지를 설정해야한다는 뜻이다.  그러면 정점이 총 $N + 4*N = 5N$ 개가 있을 것이다.  시간복잡도는 $O((5N)^3log(T))$ 로 해결할 수 있다.  예를 들어, A번 정점에서 B번정점으로 가는데 시간이 2걸린다고 치자. 그러면 A에서 출발하여 B번 정점의 4번 경유지를 들렀다가가면 B까지는 2걸릴 것이다. 이 아이디어가 가장 중요하다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const ll MOD = 1e6+3; class matrix{ public:     vector&lt;vector&lt;ll&gt;&gt; mat;          void initialize(int a, int b){         mat.assign(a, vector&lt;ll&gt;(b,0));     }          void input(int n, int m){         mat = vector (5*n+1, vector&lt;ll&gt;(5*m+1));         for(int i=5;i&lt;=5*n;i+=5){             for(int j=4;j&gt;0;j--){                 mat[i-j][i-j+1] = 1;             }         }              }          matrix operator*(matrix A){         matrix result;         result.initialize(mat.size(), A.mat[0].size());         for(int i=0;i&lt;mat.size();i++){             for(int j=0;j&lt;A.mat[0].size();j++){                 for(int k=0;k&lt;A.mat.size();k++){                     result.mat[i][j] += mat[i][k]*A.mat[k][j];                     result.mat[i][j] %= MOD;                 }             }         }         return result;     }      };  matrix mt;  matrix powMat(matrix &amp;mat, ll b){     if(b==1){         return mat;     }          matrix half = powMat(mat, b/2);     matrix ret = (half*half);     if(b&amp;1) return (ret*mat);     return ret; }  int main(){     fast_io     ll n, S, E, T;     cin &gt;&gt; n &gt;&gt; S &gt;&gt; E &gt;&gt; T;     mt.input(n, n);     for(int i=1;i&lt;=n;i++){         string s; cin &gt;&gt; s;         for(int j=1;j&lt;=s.size();j++){             int t = s[j-1]-'0';             if(t){                 if(t==1){                     mt.mat[5*i][5*j] = 1;                 }else{                     mt.mat[5*i][5*j-t+1] = 1;                 }             }         }     }     matrix res = powMat(mt, T);     cout &lt;&lt; res.mat[5*S][5*E]; }   12728 n제곱 계산  그러면 좀 어려운 문제를 풀어 볼 것이다.  $(3 + \\sqrt(5))^n$의 소숫점 앞에 마지막 세자리를 구하는 문제이다. (정수부를 1000으로 나눈 나머지)  $a = (3 + \\sqrt(5))$, $b = (3 - \\sqrt(5))$ 라고 해보자     $a + b = 6, ab = 4$ 이다.   위 두개를 보면 $a, b$ 는$x^2-6x+4$의 2개의 해이다.   따라서 $a^2 = 6a-4, b^2 = 6b-4$로 나타낼 수 있다.   다시 돌아와서 $(3 + \\sqrt(5))^n$ 의 정수부는 어떻게 구할까?  먼저, $a^n + b^n$을 생각해보자. 이는 $6a^{n-1}-4a^{n-2} + 6b^{n-1}-4b^{n-2}$ 로 나타낼 수 있따.  이를 점화식 처럼 생각해보면  $f_n = 6f_{n-1}-4f_{n-2}$ $(f_1 = a+b = 6, f_2 = (a+b)^2-2ab= 28)$ 이다.  여기서 우리는 선형방정식을 하나 구한 것이다.  그리고 $a^n + b^n$이 정수라는 것도 알아냈다.  그런데 이 식이 문제랑 무슨 상관이냐고 생각이 될 수도 있다. 우리는 $a^n$만 필요한데…  근데 $b^n$을 가만히 생각해보면 $0&lt; b_n ≤ 1$ 이라는 것을 알 수 있다.  즉…이것은 소수정도 수준이라는 것이다.  즉, $a^n$에서 1보다 작은 수 $b^n$을 더했더니 $a^n + b^n$가 정수가 되었다. → $a^n+b^n-1$ 이 답이다.  그러면 이제 아까 구했던 선형 방정식의 해를 구해 보자.  [\\begin{bmatrix} f_{n}  f_{n-1}  \\end{bmatrix} = \\begin{bmatrix} f_{n-1}  f_{n-2}  \\end{bmatrix}\\begin{bmatrix} 6 &amp; -4  1 &amp; 0  \\end{bmatrix} = \\begin{bmatrix} f_{2}  f_{1}  \\end{bmatrix}{\\begin{bmatrix} 6 &amp; -4  1 &amp; 0  \\end{bmatrix}}^{n-2}]  이를 구하고 $(1, 1)요소 * f_2(28) + (1, 2)요소 * f_1(6)-1$을 1000으로 나누면 답이다.  이때 음수를 나오지 않게하기위해서 -4에 1000을 더해준다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const ll MOD = 1e3; class matrix{ public:     vector&lt;vector &lt;ll&gt; &gt; mat;          void initialize(int a, int b){         mat.assign(a, vector&lt;ll&gt;(b,0));     }          void input(){ \t//어짜피 1000으로 나누니까 음수 부분을 없애버린다.          mat = { {6, -4+MOD}, {1, 0} };     }          matrix operator*(matrix A){         matrix result;         result.initialize(mat.size(), A.mat[0].size());         for(int i=0;i&lt;mat.size();i++){             for(int j=0;j&lt;A.mat[0].size();j++){                 for(int k=0;k&lt;A.mat.size();k++){                     result.mat[i][j] += mat[i][k]*A.mat[k][j];                     result.mat[i][j] %= MOD;                 }             }         }         return result;     }      };  matrix mt;  matrix powMat(matrix &amp;mat, ll b){     if(b==0){// 단위 벡터 리턴         matrix ret; ret.mat = { {1, 0}, {0, 1} };         return ret;     }     if(b==1){         return mat;     }          matrix half = powMat(mat, b/2);     matrix ret = (half*half);     if(b&amp;1) return (ret*mat);     return ret; }  int main(){     fast_io     int tt; cin &gt;&gt; tt;     int ori = tt;     while (tt--) {         ll n; cin &gt;&gt; n;         mt.input();         matrix res = powMat(mt, n-2);         ll ans = (res.mat[0][0]*28+res.mat[0][1]*6-1)%MOD;         string ANS = to_string(ans);         cout &lt;&lt; \"Case #\" &lt;&lt; ori-tt &lt;&lt; \": \";         for(int i=ANS.size();i&lt;3;i++) cout &lt;&lt; '0';         cout &lt;&lt; ANS &lt;&lt; '\\n';     }  }"
  },
  
  {
    "title": "게임 리뷰 - It takes two",
    "url": "/posts/It-takes-two-%EA%B2%8C%EC%9E%84%EB%A6%AC%EB%B7%B0/",
    "categories": "Game Review",
    "tags": "잇텟투, It takes two, 게임리뷰",
    "date": "2023-05-02 00:00:00 +0900",
    "content": "2023-05-02-It takes two  개요  최근엔 몸이 바빠져서 그런지 게임을 많이 못했다.  바빠진 이유는 역시 학교를 가면서, 알바도 하면서, 연애도 하기 때문일 것이다.  그래도 게임만 하던 작년보단 더 생산적인 것 같기도하다.  It takes two는 내가 스토리가 예쁜 게임을 좋아하다보니 수민이와 꼭 같이 하고 싶은 게임이였다.  그래서 같이하자고 했는데 흔쾌히 같이 재밌게 즐겨준 수민이 너무 고마워~~  덕분에 멋진 게임을 하나 끝낸 것 같다.  게임정보  1. 개발 및 유통  헤이즈라이트 스튜디오 일렉트로닉 아츠  2. 장르 및 플랫폼, 플레이타임     장르            액션, 협동 어드벤쳐           플랫폼            PS5           플레이타임            난이도 Normal - 24시간 (둘 다 게임을 안해봤으면 더 걸릴 수도 있음)           3. 버전정보  4. 달점  🌕 🌕 🌕 🌕 🌗 4.5 / 5  4.5는 거의 만점이라고 페르소나 5 로얄 때 리뷰를 했는데 4.5를 주기에 충분한 게임이었다.  그러한 이유는 스토리도 훌륭했는데 게임 플레이도 너무 재밌었기 때문이다.  5. 플레이 방식  어드벤쳐 게임이기 때문에 결국 변해버린 자신의 몸을 되찾으러 떠나는 것이다.  이 때 각 스테이지 별로 능력이 바뀌고(이를 이용하여 협동을 함) 협력하여 앞에 놓인 퍼즐을 해결해야한다.  스토리 리뷰(스포 많음)  이야기는 부부관계에 소홀해진 부부와 그 아이에서 시작한다. 아이, 로즈는 부모가 이혼할 것을 직감하고 사랑을 기술한 책을 보며 소원을 빈다. 그 소원은 다시 엄마아빠가 부부관계를 회복하는 것이다. 그 순간 아이가 만들었던 인형에 부부의 영혼이 깃들게 된다. 이 부부는 관계가 회복 될 때까지 다시 돌아 올 수 없다. 그들이 다시 인간으로 돌아와 행복 할 수 있도록 도와주는 것이다.  이 게임의 주제는 상당히 인생에서 중요하다고 생각한다. 우리 부모님만 보더라도 손을 꼭 잡고 다니시지 않고, 어딜가도 애정행각을 하며 사랑을 외치는 중년은 본 적이 없다. 왜인지 아이를 낳고 나서 서로에게 소홀해지는 부부는 매우 흔하다. 이 게임의 시작을 보면 여자는 일에 지쳐있고 남자도 육아를 하느라 서로에게 신경쓰지 못한다. 이러면서 서로가 사랑했던 이유, 아니면 그 사랑 자체를 잊게 된다.  인형이 되어 여행을 하며 그들이 놓쳤던 것들을 다시 줍게 되고 예전을 추억하며 다시 행복을 느낀다.  나는 인생에서 제일 중요한 것은 행복, 기쁨 등의 감정이라고 생각한다. 인생은 100년도 안되어서 너무 짧기 때문에 행복과 기쁨을 느끼고 가는 것이 좋다고 생각하기 때문이다. 모든 사람이 행복을 느끼는 것은 각기 다르겠지만 사랑은 분명히 행복의 조건일 것이다. 그래서 인생동안 사랑을 놓치기 싫은 것이다. 누군가가 나를 잘 알아준다는 것은 참 기쁜일이다. 내 진짜 모습을 좋아해주는 것이 사랑인 것이다. 하지만 시간이, 상황이 그 모습들을 잊게 할 수 있다. 예를 들면, 식물을 가꾸던 멋진 모습, 노래를 잘하던 멋진 모습 등이 있다. 다시 생각해내면 되는 것이다. 잠시 하던일을 멈춰두고 사랑을 찾는 것은 협력한다면 쉽다. 하지만 혼자서는 할 수 없다.  이것이 이 게임의 매력이다. 실제로 한다면 더욱 감정이입을 할 수 있을 것이다.  부부관계의 답은 없지만 모범답안 비슷하게 쓴 느낌 아닐까?  플레이 리뷰          난이도      게임의 난이도부터 보자면 쉬운 편?이다.      일단 2인용 게임이기 때문에 혼자서는 깰 수가 없다. 한 명이 2개의 컨트롤러를 사용하는 것은 불가능 할 것이다. (초인적인 사람도 있긴하겠지만)      그래서 2명이 모두 잘하기는 어렵다. 잘할 확률이  $p_1$, $p_2$이면 둘다 잘하려면 $p_1*p_2$ 가 되기 때문에 어려울 것이다. 내 입장에서는 수민이가 생각보다 게임을 매우 잘했기 때문에 꽤 수월하게 플레이 했다.      예전에 엄마와 게임을 한적이 있는데 답답해 죽을 뻔했는데 수민이는 피지컬이 좋았다.(물론 나보단 못하지만)      퍼즐의 난이도는 어려워서 헤맨적이 거의없는데 이런 게임(언챠티드 같은느낌)을 해봤으면 쉽게 풀 수 있다.      피지컬이 필요한 경우는 보스전일텐데 보스전은 우리도 상당히 헤맸다. 하지만 한명이 무빙을 잘하면 다른 사람이 부활할 시간을 벌어줄 수 있어서 쉽다.           조작감, 음향      조작감은 당연히 명작이다. 컨트롤러에서의 진동과 화면의 일치감이 매우 좋아서 몰입하기가 너무 좋았다.      특히 기억에 남는 것은 스케이트를 타는 부분이다. 매우 생동감 있었고 로프를 이용한 액션, 자석을 이용한 액션들도 매우 재밌게 했다.      음향은 기억이 많이 남지는 않지만 좋았다. 게임을 할 때 좋은 브금은 그 음악의 기억이 남지 않는데 그 풍경이 기억이 난다면 성공했다고 생각한다. 풍경과 너무 잘 어우러져서 몰입할 수 있게 도와준 점을 높게 평가한다.      마무리  오랜만에 글을 썼다. 기록하는 것은 참 재밌고, 멋진일이지만 가끔은 귀찮음이 그것을 이긴다.  세상에 할 일이 너무 많다. 공부도 해야하고, 맛있는 것도 먹어야하고, 운동도 해야하고, 연애도 해야한다.  모두 즐거운 일이니 이 감정을 잊지 않고 열심히 해나가야 할 것이다.  이제는 글을 막 씨부려 볼까 생각 중이다. 너무 각잡고 쓰니까 귀찮아서 못하겠다.  이 게임은 사랑에 대한 게임이다. 나도 나중에 사랑에 대한 게임을 만들고 싶은데 많은 참고가 되었다.  나의 게임으로 많은 사람들이 사랑하고 싶은 마음을 가진다면 정말 행복할 것같다."
  },
  
  {
    "title": "코드포스 - 새로 시작",
    "url": "/posts/Codeforceround-868(Div2)/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2023-05-02 00:00:00 +0900",
    "content": "Codeforce round 868 (Div.2)  개요  이제 노션에 있는 내용을 마크다운으로 변환하여 올리기 때문에  수식 등을 더 잘 쓸 수 있을 것 같다. 코드포스를 잘하고 싶지만 항상 그렇게 잘하진 않는 것 같다(그냥 내 실력이 많이 딸린다). 실력이 부족한 만큼 앞으로는 업솔빙은 무조건 5문제를 할 것이다. 6월에는 알바를 그만두고 코드포스에 집중 할 것이다. 앞으로 화이팅!!  A. A-characteristic (0:15)  꽤나 오래 걸렸다. 하지만 쉬운 문제이기도 하다.  이 문제의 핵심은 아래와 같다.   💡 -1과 1의 각 순서는 상관이 없고 개수만 영향을 준다.       각 숫자의 갯수가 x라고 하면 조건을 만족하는 식의 개수는  $\\frac{x(x-1)}{2}$이다.   그러면 1의 개수를 p, -1의 개수를 r이라고 하면   $\\frac{p(p-1)}{2}+\\frac{r(r-1)}{2} = k$인 p, r이 있으면 정답인 것이다.   #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second   int main() {     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n, k; cin &gt;&gt; n &gt;&gt; k; \t\t\t\t//사실 이부분은 필요가 없다.          if(!k){             if(n==2){                 cout &lt;&lt; \"YES\\n\";                 cout &lt;&lt; \"1 -1\\n\";                 continue;             }else{                 cout &lt;&lt; \"NO\\n\";                 continue;             }         }         bool ok=false;         for(int i=0;i&lt;=n/2+1;i++){             int p = i;             int r = n-i;             if(p*(p-1)/2+r*(r-1)/2==k){                 cout &lt;&lt; \"YES\\n\";                 for(int i=0;i&lt;p;i++) cout &lt;&lt; \"1 \";                 for(int i=0;i&lt;r;i++) cout &lt;&lt; \"-1 \";                 cout &lt;&lt; \"\\n\";                 ok = true;                 break;             }         }         if(ok) continue;         else cout &lt;&lt; \"NO\\n\";     } }   B. Sort with Step (0:26)  A보단 빨리 컷을 냈다. 처음엔 순열이 나오고 swap연산이 나오길래 최근 공부를 한 순열 싸이클 분할이 나오는 줄 알았다. 하지만 훨씬 쉬운 내용이었다.  1, 1+k, 1+2*k  2, 2+k, 2+2*k  k-1, k-1 +k , k-1+2*k  의 규칙으로 확인했을 때 제자리에 없는 것의 개수를 센다.   💡 error가 난 것의 개수가 없으면 0, 2개면 1, 나머지면 -1을 출력한다.    #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second   int main() {     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n, k; cin &gt;&gt; n &gt;&gt; k;         vector&lt;int&gt; p(n+1);         for(int i=1;i&lt;=n;i++) cin &gt;&gt; p[i];                  int error = 0;         for(int i=1;i&lt;=k;i++){             for(int j=i;j&lt;=n;j+=k){                 if(!((p[j]-i)%k)) continue;                 error++;             }         }         if(!error) cout &lt;&lt; \"0\\n\";         else if(error==2) cout &lt;&lt; \"1\\n\";         else cout &lt;&lt; \"-1\\n\";     } }   C. Strongly Composite (0:55)  이 문제는 문제 이해는 빨랐는데 구현 과정에서 시간초과로 고생을 한 문제이다.     일단 a배열에 있는 모든 소인수를 구한다. → map에 각 소인수가 몇번 나왔는지 저장했다.   각 소인수가 2개 이상이라면 2개만 사용해도 b요소 하나를 만들 수 있다.   하지만 소인수의 종류가 다른것이 2개있으면 안되고 3개 있어야한다.   따라서 greedy하게 숫자가 같은 소인수의 개수는 2개씩 묶고 남은것은 3개씩(나머지는 버리고) 묶어서 처리한다.   소인수를 구하는 과정에서 소수를 미리 구해두고 모든 소수를 검사하니, 소수가 60만개가 넘어서 시간초과가 났다. 이를 $\\sqrt{a[i]}$의 시간 복잡도로 검사하도록 바꾸고 map을 이용하여 최적화하니 AC를 맞을 수 있었다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main() {     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n; cin &gt;&gt; n;         vector&lt;int&gt; a(n);         int rest = 0;         map&lt;ll, ll&gt; mp;         for(int it=0;it&lt;n;it++){             cin &gt;&gt; a[it];             int tmp = a[it];             for(ll i=2;i==2||i*i&lt;=tmp;i++){                 if(tmp%i) continue;                 if(!(tmp%i)) while(!(tmp%i)){                     tmp /= i;                     mp[i]++;                 }             }             if(tmp!=1) mp[tmp]++;         }         int res = 0;         for(auto it = mp.begin();it!=mp.end();it++){             ll k = it-&gt;second;             res += k/2;             rest += k%2;         }         res += rest/3;         cout &lt;&lt; res &lt;&lt; '\\n';     } }   D. Unique Palindromes(Upsolving)  나는 팰린드롬만 보면 지레 겁을 먹는다. 이제는 팰린드롬에 쫄지 않도록 열심히 공부를 해야겠다.  이 문제를 선택하지 않고 E번으로 넘어간 이유는 이 문제의 호흡이 꽤 길어서 해석하기 싫었기 때문이다. 그리고 당시 푼 사람 수도 200명 이내로 매우 적었따.ㅠ.ㅠ     문제이해 과정            p(t)는 string t의 서로다른 팰린드롬 substring의 개수이다.                p(s, m) = p(t) 라고 하면 t = s[1….m] 이다.          즉 , s의 크기가 m인 prefix가 t라는 뜻이다.              $p(s, x_i) = c_i$ 팰린드롬인 substring의 개수가 $c_i$ 이다.       위 식에서 $x_i$와 $c_i$의 쌍을 condition이라고 하는데       이 때, k개의 컨디션을 가진 string 을 찾는다.           위에서 본것 처럼 꽤나 문제 이해가 어려웠다. 하지만 차근차근 본다면 항상 할 수 있다는 생각을 가져야하는데 그게 잘 안된다. 시간 제한이 있기 때문에 그런 생각이 잘 안드는 것 같다. 사실 저렇게 천천히 쓰면서도 이해 하는데 5분~10분 밖에 안걸리는데 대회에서 지레 겁을 먹는 습관은 좀 고치는게 좋을 것 같다.  먼저 부분집합이 팰린드롬이 되는 경우를 관찰해보자.     자기 자신 a는 무조건 팰린드롬이니 1이다.   다른 것들이 모이면 abcd 글자수 만큼이 팰린드롬이다.   aaaaa같은 것들이 모이면 모든 부분집합이 팰린드롬이니까 $n$ 이 팰린드롬인 부분집합의 개수이다.            a, aa, aaa, aaaa, aaaaa이렇게 총 5개이다.           abaaba 이런식이면 팰린드롬인 것이 개수는 3+1+1+1이 된다.   위 내용을 통틀어 확인해보면 글자수가 $n$이라고하면 팰린드롬인 부분집합인 것의 개수 $x$는 $x ≤ n$이다.  //그래서 if (c[0] &lt; 3 || c[0] &gt; x[0]) {//n은 3보다 크기 때문에, 글자수가 x인곳에서 c가 더 클수는 없음       cout &lt;&lt; \"NO\\n\";       continue; }   2, 3번 특징 때문에 매번 다른 글자수를 쓸 필요없이 그냥 같은걸 추가하므로써 같은 효과를 낼 수 있다.  ex) C = 4 N = 6  abcdab 이런 식으로 만들 수 있음.  (a, b, c, d)  aabcab (a, aa, b, c) 이것도 가능     일단 n도 C도 3보단 크기 때문에 3보다 C-3개 만큼 a를 넣는다.   그다음엔 abc를 넣는다고 하면 3개의 팰린드롬 부분집합이 만들어진다.  +(….a,  c, d)   그다음엔 abcabc를 계속돌리면 아무것도 만들어지지 않는다. 따라서 정확히 C개를 맞출 수 있다.   #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main() {     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n, k; cin &gt;&gt; n &gt;&gt; k;         vector&lt;int&gt; x(k), c(k);         for(int i=0;i&lt;k;i++) cin &gt;&gt; x[i];         for(int i=0;i&lt;k;i++) cin &gt;&gt; c[i];         if(c[0]&lt;3||c[0]&gt;x[0]){             cout &lt;&lt; \"NO\\n\";             continue;         }         string res;         char cur = 'a';         for(int i=0;i&lt;c[0]-3;i++) res.push_back(cur);         for(int i=c[0]-3;i&lt;x[0];i++){             res.push_back(cur++);             if(cur=='d') cur = 'a';         }                  bool ok = true;         for(int i=1;i&lt;k;i++){             int dx = x[i]-x[i-1];             int dc = c[i]-c[i-1];                          if(dc &gt; dx){                 ok = false;                 break;             }                          for(int j=0;j&lt;dc;j++){  //새로운거 추가                 res.push_back('z'-i);             }             for(int j=dc;j&lt;dx;j++){                 res.push_back(cur++);                 if(cur=='d') cur = 'a';             }         }         if(ok){             cout &lt;&lt; \"YES\\n\";             cout &lt;&lt; res &lt;&lt; '\\n';         }else{             cout &lt;&lt; \"NO\\n\";         }              } }   상당히 어렵고 팰린드롬의 성질의 정수를 느낄 수 있었다. 다양한 팰린드롬의 성질을 모두 신경 써야한다.  E. Removing Graph (-4, Upsolving)  대회 때 D를 버리고 본 문제이다. 내가 백준에서 게임이론 관련 문제를 많이 풀어 봤기 때문에 꽤나 자신있었는데(실제로 잘 풀었다고 생각함) 이 문제는 내 생각보다 훨씬 더 어려운 문제였다. 그 이유는   💡 사이클이 있다가 없어지고 선형 정점모임이 생길 수 있다.    위의 이유가 이 문제를 , grundy수를 구하기 어렵게 만들었다. 처음에는 그냥 사이클에 포함된 정점의 개수에서 아무거나 뺄 수 있다고 생각을 하고 문제를 해결했다. 즉, 각 사이클을 님게임의 돌더미라고 생각을 한 것이다.  하지만 아쉽게도 위 사실을 간과한 덕분에 테스트 케이스 9번을 통과하지 못했다..  먼저 결론은 내가 푼 것보다 훨씬 쉬운데 아래와 같다.   💡 사이클의 크기 X가 r+l-1보다 작으면 $\\lfloor{\\frac{X}{l}}\\rfloor$, 나머지 경우는 0이 그런디수가 된다.    위 내용을 증명하기가 상당히 까다로웠는데  $cycle[x] = mex(chain[x-r], chain[x-r+1], — chain[x-l])$  위 처럼 되기 때문에  𝑐ℎ𝑎𝑖𝑛[𝑎]⊕𝑐ℎ𝑎𝑖𝑛[𝑏]≤𝑐ℎ𝑎𝑖𝑛[𝑎]+𝑐ℎ𝑎𝑖𝑛[𝑏]=⌊$\\frac{a}{l}$⌋+⌊$\\frac{b}{l}$⌋≤⌊$\\frac{a+b}{l}$⌋≤⌊$\\frac{x-l}{l}$⌋=⌊$\\frac{x}{l}$⌋−1  이런 식이 만들어진다. 따라서 r+l-1보다 작으면 무조건 $\\lfloor{\\frac{X}{l}}\\rfloor$, 나머지는 0이 되는 것이다.  chain과 cycle의 관계를 이해하는 것이 매우 중요한 문제였다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const int MAX = 2e5+1; vector&lt;int&gt; adj[MAX]; bool visited[MAX];  int dfs(int here){     int ret = 1;     visited[here] = true;     for(int nxt : adj[here]){         if(!visited[nxt]) ret += dfs(nxt);     }     return ret; }  int main() {     fast_io     int n, l, r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;     for(int i=0;i&lt;n;i++){         int u, v; cin &gt;&gt; u &gt;&gt; v;         adj[u].push_back(v);         adj[v].push_back(u);     }     vector&lt;int&gt; chunk;     for(int i=1;i&lt;=n;i++) if(!visited[i]) chunk.push_back(dfs(i));     int G = 0;     for(int X : chunk){         if(X&lt;=r+l-1) G ^= X/l;         else G ^= 0;     }          if(G) cout &lt;&lt; \"Alice\\n\";     else cout &lt;&lt; \"Bob\\n\"; }"
  },
  
  {
    "title": "SUAPC 연습",
    "url": "/posts/%EC%98%88%EC%A0%84%EC%97%90-%ED%96%88%EB%8D%98-%EC%97%B0%EC%8A%B5/",
    "categories": "대회",
    "tags": "대회, 알고리즘",
    "date": "2023-04-15 00:00:00 +0900",
    "content": "2월 11일 문제풀이   💡 목적 : **SUAPC 연습**     💡 문제집 : **SUAPC 2022 Winter**    2023 겨울 SUPAC 나가려고 연습했떤 문제 해설을 적어보았따.  이제는 노션을 이용하여 markdown을 만드려고 하기 때문에 형태가 조금은 변할 수 있다.  노션에서 markdown언어로 변환하는 프로그램을 만들면 좋겠다고 생각했는데 그냥 노션 그자체에 있을 줄은 몰랐다…. 어쨋든 그래서 2023 겨울 대회는 5솔인가? 4솔인가 하고 학교 2등상, 전체 16등인가? 15등인가 했다….ㅋㅋㅋ 사실 내가 잘했어야 했는데 m번에서 엄청 말려서 망했다. 그리고 게임dp 연습했던거라 충분히 풀수 있었는데 그것마저 실패한게 너무 아쉬웠따.  A. 튜터-튜티 관계의 수  dfs로 연결되어 있는 정점들을 모두 곱하면 답이다  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const int MAX = 2e5+1; const int MOD = 1e9+7; int n, m; vector&lt;int&gt; adj[MAX]; ll dp[MAX][2]; bool visited[MAX];  int dfs(ll here){     visited[here] = true;     int ret = 1;     for(ll next : adj[here]){         if(!visited[next]){             ret += dfs(next);         }     }     return ret; }  int main(){     fast_io     cin &gt;&gt; n &gt;&gt; m;     for(int i=0;i&lt;m;i++){         int u, v; cin &gt;&gt; u &gt;&gt; v;         adj[u].push_back(v);         adj[v].push_back(u);     }     ll res = 1;     for(int i=1;i&lt;=n;i++){         if(!visited[i]){             res *= dfs(i);             res %= MOD;         }     }     cout &lt;&lt; res; }   C. 카카오뷰 큐레이팅 효용성 분석  단순 구현  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main(){     fast_io     int n; cin &gt;&gt; n;     vector&lt;int&gt; a(n), b(n);     for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i];     for(int i=0;i&lt;n;i++) cin &gt;&gt; b[i];     ll sum= 0, res = 0;     for(int i=0;i&lt;n;i++){         sum += a[i];         if(!b[i]) res += a[i];     }     cout &lt;&lt; sum &lt;&lt; '\\n';     cout &lt;&lt; res &lt;&lt; '\\n'; }   D. Y  Y를 만드려면 각 정점에서 뻗어나가서 끝까지 가는거의 길이들을 알아둬야한다.     E. 도로 정보  상태를 27(T가 나온횟수%3)+9(G가 나온횟수%3)+3*(F가 나온횟수%3)+(P가나온횟수%3)으로 나타내면  i에서의 상태와 j에서의 상태가 같다면 i+1~부터 j까지가 흥미로운 구간이다 라고 생각할 수 있다.  따라서 dp[81]에 (81이 모든 경우의 수임) 상태가 나오면 그 상태가 이전에 나온 만큼 정답에 더해주고  +1을 해준다.  1~n까지 보면 정답 처음꺼는 dp[0] = 1에서 시작한다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  const int MAX = 1e5+1; int dp[81], state[MAX], T, G, F, P;  int main(){     fast_io     int n; cin &gt;&gt; n;     string s; cin &gt;&gt; s;     dp[0] = 1;     ll res = 0;     for(int i=0;i&lt;s.size();i++){         T += (s[i]=='T');         G += (s[i]=='G');         F += (s[i]=='F');         P += (s[i]=='P');         int k = 27*(T%3)+9*(G%3)+3*(F%3)+(P%3);         res += dp[k];         dp[k]++;     }     cout &lt;&lt; res; }   J. 일이 너무 많아..  11, 111 등을 약수로 하는 수를 포함배제 원리를 이용하여 구한다  import sys import math input = sys.stdin.readline  n = int(input())  def solve(X) :     p = []     k = 11     while k &lt;= X:         p.append(k)         k *= 10         k += 1     ret = 0     sz = len(p)      for i in range(1, 1&lt;&lt;sz):         L = 1         cnt = -1         for j in range (sz):             if(i&amp;(1&lt;&lt;j)) :                 cnt *= -1                 L = math.lcm(L, p[j])                 if(L&gt;n) :                     L = X+1                     break         ret += cnt*(X//L)     return ret  print(solve(n))   K. 올바른 괄호  누적합을 이용하는데  ps[i] : (를 1, )를 -1이라고 했을 때 누적합  pn[i] : 처음부터 i까지 최솟값  sn[i] : 끝에서부터 i까지 최솟값  일단 ps[n]은 무조건 1또는 -1이다. 1이면 (를 빼야하고 , -1이면 )를 빼야한다.  근데 i자리에 있는 괄호를 빼고 싶으면 i의 앞은 0보다 커야하고, i의 뒤는 (를 빼면 1보다, )를 빼면 -1보다 커야한다.  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main(){     fast_io     string s; cin &gt;&gt; s;     int n = s.size();     vector&lt;int&gt; a(n+1), ps(n+1);     for(int i=1;i&lt;=n;i++){         a[i] = (s[i-1]=='(') ? 1 : -1;         ps[i] = ps[i-1]+a[i];     }     int res = 0;     vector&lt;int&gt; pn(n+1), sn(n+1);     pn[1] = ps[1];     for(int i=2;i&lt;=n;i++){         pn[i] = min(pn[i-1], ps[i]);     }     sn[n] = ps[n];     for(int i=n-1;i&gt;0;i--){         sn[i] = min(sn[i+1], ps[i]);     }     for(int i=1;i&lt;=n;i++){         if(ps[n]==1&amp;&amp;a[i]==1&amp;&amp;pn[i-1]&gt;=0&amp;&amp;sn[i]==1) res++;         if(ps[n]==-1&amp;&amp;a[i]==-1&amp;&amp;pn[i-1]&gt;=0&amp;&amp;sn[i]==-1) res++;     }     cout &lt;&lt; res; }   L. 팰린드롬 게임  1의 자리는 무조건 팰린드롬 수 따라서 어떤 수가 있더라도 10의 배수를 만들 수 있다.  A의 차례에 10의 배수가 아닌 수가 있으면 무조건 10의 배수로 만들 수 있다.  10의 배수라면 다음 턴에 무조건 10의 배수가 아닌 수로밖에 못만든다. (팰린드롬 수는 마지막이 0일 수 없어서)  #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii; #define xx first #define yy second  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while(tt--){         ll n; cin &gt;&gt; n;         if(!n||!(n%10)) cout &lt;&lt; 1 &lt;&lt; '\\n';         else cout &lt;&lt; 0 &lt;&lt; '\\n';     } }"
  },
  
  {
    "title": "코드포스 - 블루 좀 가자",
    "url": "/posts/Codeforces-846,-TypeDB-Foreces-2023/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2023-01-30 00:00:00 +0900",
    "content": "Codeforces#846, TypeDB Foreces 2023, Codeforces#848 업솔빙  Codeforces#846, TypeDB Foreces 2023, Codeforces#848 업솔빙 정말 오랜만이다. 업솔빙을 하는 것이 저번 포스팅이 마지막이었으니 10월이다…       그 동안 코드포스를 안한 것도 아니다. 백준 스트릭도 꾸준히 유지했다.         이것의 패인은 2가지다. 첫번쨰는 알바다. 편의점 알바를 시작했는데 이것이 야간알바다 그래서 코포를 놓칠때가 많았다.        두번째는 연애다. 요즘 내가 너무 행복한 나날들을 보내고 있기에 알골 따위(?)의 중요성을 잠시 잊었다.        알고리즘을 할때와 또 다른 색다른 재미를 삶에서 찾았다보니 업솔빙을 잠시 멀리했던 것이다.        이러다가 블루 못찍는건 아닐까 모른다.(그건 정말 싫다)         어쨋든 블로그에도 글을 써야하니 3개를 한꺼번에 업솔빙을 해보도록 하겠다.      물론 아직 내가 E를 풀 실력은 안되니 D까지만 총 12문제의 업솔빙을 시작해보겠다.  846 A. Hayato and School(TLE) 846 셋을 망치게한 레전드 주범이다. 분명히 풀때는 통과했는데 시스텟에서 TLE로 터져버렸다.        이런 경험은 처음이라 눈물이 난다 ㅠㅠ n^3 풀이가 안되는건 명확한데 왜 깝치면서 brute force를 한건지..ㅠㅠ         이 문제는 그리디인데 짝수 2개, 홀수 1개 또는 홀수 3개가 있는지 확인하고 있다면 앞에서 부터 해당하는 것을 찾으면 된다.  구현은 간단한데 조금 기니까 생략하겠다.  846 B. GCD Partition(1:10) B는 상당히 어려웠따. 왜냐면 이게 돼? 싶었기 때문이다.  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n; cin &gt;&gt; n;         vector&lt;ll&gt; a(n+1);         ll sum = 0;         for(int i=1;i&lt;=n;i++){             cin &gt;&gt; a[i];             sum += a[i];         }         ll res = 0;         ll k = 0;         for(int i=1;i&lt;n;i++){             k += a[i];             res = max(res, gcd(k, sum-k));         }         cout &lt;&lt; res &lt;&lt; '\\n';     } }  구현을 모두하면 시간 초과니까 앞에서 부터 쭉 쓸고 오면서 구해야한다.   이때 sum을 구해놓고 앞에서 부터 2개로 나누어서 생각하면 편하다.  846 C. 문제오류 이 문제는 문제오류로 이 set전체가 unrated됐다.  어찌보면 다행이다.  846 D. Bit Guessing Game(WA) 인터랙티브 문제이고, 인터랙티브를 맞춘적은 단 한번도 없다.       열심히 풀었는데 참 아쉽다.     따라서 여기서 업솔빙을 잘해볼 것이다 .       먼저 내가 생각한 아이디어는 맞았따. 빼기를 하면 이전의 cnt에서 새로 생기는 1의 개수가 규칙적이다.      예를 들어 8 = 1000 , 2 = 10 이고 8이랑 2를 빼면 6 = 110 이런식으로 1의 개수가 2개로 늘어난다.       그러니까 1을 추가해서 개수 변화가 없으면 1자리에 있다는 거고 개수변화가 1이 많이 늘어나면 그 앞에 몇자리 앞에 1이 존재한다는 것이다.      따라서 에디토리얼 기반의 코드를 보면 다음과 같다. while (tt--) {     int cnt;     cin &gt;&gt; cnt;     int res = 0;     int was = 0;     while (cnt &gt; 0) {         res += 1;         int nw = ask(1 + was);         int back = nw - cnt + 1;         res += (1 &lt;&lt; back) - 1;         was = (1 &lt;&lt; back) - 1;         cnt = nw - back;     }     cout &lt;&lt; \"! \" &lt;&lt; res &lt;&lt; endl; }  나는 큰수부터 보면서 해결하려고 했는데 그것보다 1만 추가해서 ( 1의 개수가 최대 30개 정도니까 )해결하는 것이 인상깊었다.  TypeDB A. Exponential Equation(0:08) 꽤 잘본 셋이다. 나는 구성적 문제에 꽤 강한듯 하다.        이 문제는 홀수면 절대 불가능하고 짝수면 1과 n/2로 나누면 정답이다. int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         ll n; cin &gt;&gt; n;         if(n&amp;1){             cout &lt;&lt; -1 &lt;&lt; '\\n';         }else{             cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; n/2 &lt;&lt; '\\n';         }     } }   TypeDB B. Number Factorization(0:28) 소수를 이용하는, 소인수분해는 코포에 자주나온다. 다행히 그 테크닉을 아라서 이용했따.  소인수분해했을 때 그 소수가 몇개 나오는지도 저장해놓은 배열을 만들어두고 이를 등장횟수에 따라 정렬한다.      그 이후는 등장횟수가 적은 것 부터 보면서 결과 값을 갱신한다.      이게 뭐냐면 조금 조사를 하다보면 시그마(a*p)의 최댓값은 소인수분해를 하고 최대한 밑을 곱해서 크게 한 후에 지수를 곱해야한다.       이를 이용한 것이 아래 코드이다. int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         ll n; cin &gt;&gt; n;         ll tmp = n;         vector&lt;pii&gt; ap;         for(int i=2;i*i&lt;=n;i++){             int cnt = 0;             while(!(tmp%i)){                 tmp /= i;                 cnt++;             }             if(cnt){                 ap.push_back({cnt, i});             }         }         if(tmp!=1){             ap.push_back({1, tmp});         }         sort(ap.begin(), ap.end());         ll k = 1;         for(int i=0;i&lt;ap.size();i++){             k *= ap[i].second;         }         ll x = 0;         ll res = 0;         for(int i=0;i&lt;ap.size();i++){             res += k*(ap[i].first-x);             x = ap[i].first;             k /= ap[i].second;         }         cout &lt;&lt; res &lt;&lt; '\\n';     } }   TypeDB C. Remove the Bracket(1:15) 꽤 오래걸렸지만 매우 잘 풀었다고 생각한다.        나는 dp를 이용했는데 dp식 정의는 다음과 같다.  dp[i][k==2] : i번째까지 봤고 i번째가 k상태(0 그대로, 1은 swap)일때 최솟값. 정의 했다.  또한 최적이 되는 상태는 s를 기준으로 최대한 차이를 많이 벌려야하기 때문에 0, a[i], 나 s, a[i]-s로 나눠질 수밖에 없다. #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii;  const int MAX = 2e5+1; ll dp[MAX][2];  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         memset(dp, 0, sizeof(dp));         int n, s; cin &gt;&gt; n &gt;&gt; s;         vector&lt;int&gt; a(n);         for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i];         ll lp = 2e5+1, lq = a[0];         for(int i=1;i&lt;n;i++){             ll p, q;             if(s&gt;=a[i]){                 p = 0;                 q = a[i];             }else{                 p = s;                 q = a[i]-s;             }             if(p&gt;q) swap(p, q);             if(i==n-1) p = q = a[n-1];             dp[i][0] = min(dp[i-1][0]+lq*p, dp[i-1][1]+lp*p);             dp[i][1] = min(dp[i-1][1]+lp*q, dp[i-1][0]+lq*q);             lp = p;             lq = q;         }         cout &lt;&lt; min(dp[n-1][0], dp[n-1][1]) &lt;&lt; '\\n';     } }   D. Game on Axis(upsolving) 이 문제 또한 코포 단골 손님인 사이클이다.        이 것은 대회때 판단을 했고, dfs와 dsu를 이용하여 풀 수 있겠다는 생각은 했지만….       역시나 아직 나의 내공이 부족한지 1시간 반을 투자했는데 예제가 아슬아슬하게 안나오는 경지밖에 안되었다. ㅠㅠㅠ        그래도 튜토리얼을 보니 아이디어는 맞았으니 이것으로 위안을 삼아야겠따.     결국 이 게임의 목적은 게임을 끝내는 것이다. 그런데 사이클이 돌면 게임을 끝낼 수 없다.      따라서 배열 밖으로 나가는 것이 게임의 목적이다.          이 문제는 사이클을 세는 것이 더 빠르니까 전체 경우(n*(2n+1)) 에서 사이클이 생기는 경우를 빼는 것이 바람직하다.  848 A. Flip Flop Sum(0:05) A는 쉬웠다. -1이 두개 붙어있으면 그것을, 그 다음은 -1, 1, 그 다음은 1, 1 순으로 바꿀 수 있으면 바꾸고 끝낸다. int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n; cin &gt;&gt; n;         vector&lt;int&gt; a(n+1);         int ok = 0;         int sum = 0;         for(int i=1;i&lt;=n;i++){             cin &gt;&gt; a[i];             sum += a[i];             if(a[i]==-1&amp;&amp;a[i-1]==-1) ok = 1;             if(!ok&amp;&amp;a[i]+a[i-1]==0) ok = -1;         }         if(ok==1) cout &lt;&lt; sum+4 &lt;&lt; '\\n';         else if(ok==-1) cout &lt;&lt; sum &lt;&lt; '\\n';         else cout &lt;&lt; sum-4 &lt;&lt; '\\n';     } }  848 B. The Forbidden Permutation(upsolving) 아직도 잘 모르겠다. 이것을 어떻게 푸는 것인지…ㅠㅠ        B번에 올인했는데 결국엔 못풀었따. 그래서 C로 넘어갔따.       일단 이문제를 틀린 가장 큰 패인은 문제를 잘못 이해한 것이다.       나는 good array가 되려면 모든 부분이 다 good이어야하는 줄 알았는데 한 곳만 good이면 되는 것이다.       하… 정말 쉬운 문제였는데 매우 아쉽다.  848 C. Flexible String(1:45) 이 문제는 매우 쉽다.      그래서 C에 있는 것이 이상했다.  왜냐면 단순 브루트포스로 풀리기때문이다.      근데 시간복잡도가 애매하게 계산되어서 해볼까 말까 고민하게 만드는 문제였다.      이런 상황들이 대회때 매우 중요한데 참 아쉬운 문제 일 수도 있다.       그래도 실전에서 prev_permutation을 이용해서 조합을 계산하는 테크닉을 써먹었다는 것에 기분이 좋았다. #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; typedef tuple&lt;int, int, int&gt; tiii;   int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n, k; cin &gt;&gt; n &gt;&gt; k;         string a, b;         cin &gt;&gt; a &gt;&gt; b;         map&lt;char, int&gt; mp;         set&lt;char&gt; s;         int cnt = 0;         for(int i=0;i&lt;n;i++){             if(s.find(a[i])!=s.end()) continue;             mp[a[i]] = cnt++;             s.insert(a[i]);         }         vector&lt;int&gt; x, tmp;         for(int i = 0;i&lt;cnt;i++) x.push_back(i);         for(int i=0, c=0;i&lt;cnt;i++, c++){             if(c&lt;k) tmp.push_back(1);             else tmp.push_back(0);         }         ll res = 0;         do {             ll ret = 0;             int last = 0;             for(int i=0;i&lt;n;i++){                 if(a[i]==b[i]||tmp[mp[a[i]]]==1) continue;                 ll kk = i-last;                 ret += kk*(kk+1)/2;                 last = i+1;             }             ll kk = n-last;             ret += kk*(kk+1)/2;             res = max(res, ret);         } while (prev_permutation(tmp.begin(), tmp.end()));           cout &lt;&lt; res &lt;&lt; '\\n';     } }   848 D. Flexible String Revisit(upsolving) B번 때문에 당연히 못건드렸던 문제지만 내가 dp 연습을 꽤 많이 했기 때문에 생략한다."
  },
  
  {
    "title": "게임 리뷰 - 용과같이 제로",
    "url": "/posts/%EC%9A%A9%EA%B3%BC%EA%B0%99%EC%9D%B4-%EC%A0%9C%EB%A1%9C,-%EA%B7%B92/",
    "categories": "Game Review",
    "tags": "용과같이, 게임리뷰",
    "date": "2022-10-30 00:00:00 +0900",
    "content": "ps5 게임 : 용과같이 제로 리뷰  개요 저번에 1을 하고 제로를 했는데 제로가 너무 재밌어서 2까지 고속으로 달렸다.        시험기간인데도 게임을 2개나 엔딩을 봤다니…ㅠㅠ 반성도 조금 해야할듯하다.    2는 아주 조금의 챕터가 남아서 따로 포스팅을 할꺼고 오늘은 용과 같이 제로 후기를 써보겠다.  용과같이 제로    개발 및 유통      용과 같이 스튜디오            Sega   장르 및 플랫폼, 플레이타임            장르 : 액션 어드벤쳐 플랫폼 : PS5 플레이타임 : 난이도 Normal - 24시간 (서브퀘스트 많이 안함, 저번에 하드 빡세서 normal로 밀었다. 근데 노말은 너무 쉬움)           버전 정보       용과 같이 극 1 포스팅에 썼음   달점  🌕 🌕 🌕 🌕 🌑 4 / 5       용과 같이 극 1보다 더 재밌었다.      감동적이고, 멋있는 연출이 많이 추가가 되었고 스토리도 더 내 스타일이였다.      특히 마지마 스토리는 정말 최고다.   게임 플레이 방식       극1에서 바뀐 점은 경험치가 아니라 돈을 이용해서 능력을 강화한다는 것이다.       이 시스템이 좋았던 것은 돈을 퍼줘서 먹을것이나 아이템 살돈이 안 딸린다는 것이다.       근데 능력강화에 드는 돈이 너무 비싸서 돈이 딸린다…ㅠㅠ       약간 식당갔는데 맥주는 100원인데 메인요리가 10만원인 느낌이라 아쉬웠다.   스토리 리뷰(스포가 가득함) 이번에는 키류말고도 마지마의 이야기도 담겨있다.      그리고 극1보다 시간적으로 이전의 이야기다.       키류가 도지마의 용이 되었고 마지마가 시마노의 광견이라고 불리게 된 이유가 나온다.       저번 극1은 야쿠자의 추악한 모습, 그리고 남자의 싸움 등에 집중했던 것 같은데 제로는 거기에 사랑을 더해서 감동을 줬다.        카무로쵸가 재개발을 하려는 시대상에서 게임이 시작된다.      그리고 그런 시대에서 한 평의 공터의 주인을 두고 야쿠자들이 대립하는 내용이다.       한 평의 공터의 주인은 마키무라 마코토였고 마코토를 지키려는자들과 마코토를 죽이려는 자들이 대립을 한다.     마코토를 죽이려던 마지마와 마코토를 살리려는 키류, 그러다가 한 마음으로 마코토를 지키는 과정이 아주 잘 들어났다.  키류는 도지마조와의 대립이 메인이다.       도지마조의 간부 3인방과 릴레이식으로 싸우는데 쿠제는 맨날 쳐맞아서 불쌍하다.(그래도 쿠제가 3명중에는 젤 멋있다)          간부들은 마코토를 찾아내서 땅을 자기소유로 만들어야하는데 키류는 카자마의 명령에 따라 타치바나 부동산을 도왔기 때문에 대립한 것이다.        스토리상 납득이 안되었던 점은 없었지만 마지마 스토리에 비해 상대적으로 노잼이였다. ㅋㅋ  마지마는 마코토를 지켜주는 것이 메인스토리다.      죽이라는 명령을 받았지만 장님인 그녀를 보자마자 마음이 이상했다.      근데 이것이 연출이 좋아서 그런지 나도 마지마와 비슷한 마음이 들었다.       마코토를 지켜주고 싶게 만들었다.        근데 이것이 시마노의 설계였다는게 좀 어이없었다.(감동이 좀 깨짐)       유튜브 댓글 중에 시마노 연애 조작단이라는 댓글을 봤는데 웃겼다. ㅋㅋ         그래도 마지막 마코토 우는 장면이나 마코토의 눈이 치료되고 대면하는 장면은… 진짜 여운이 쎄게 남는다.  내가 좋아하는 스토리는 여운이 많이 남는 게임인데 이 점에서 극1보다 높게 평가했다.        여운이 남으니 극2도 빨리 달리고 싶어졌다.  게임플레이 리뷰 극1보다 훨씬 발전된 플레이라고 생각한다.      전투 방식은 비슷했지만 마지마라는 캐릭터가 추가되면서 총 7~8가지의 배틀 스타일을 쓸 수 있어서 그랬던 것 같다.       그래도 네모네모네모세모의 공식은 똑같긴하다.        나는 아쉽지만 너무 복잡하면 손이 잘 안가기 때문에 용과같이 전투 시스템은 참 좋은 것 같다.  서브퀘스트를 많이 하지는 않았지만 이 또한 캐릭터가 새로 생겨서 그런지 여러가지로 재미를 느낄 수 있었다.        특히 마지마의 물장사는 참 재밌다. 근데 이게 노가다라서 나는 스토리를 미는 입장이라 많이는 못했다.       이 게임을 순수하게 천천히 즐길땐 노가다 뛰는 것도 재밌을 것 같다.       용과 같이 7도 이치방 홀딩스라는 회사를 키우는게 재밌었는데 제로의 소텐보리 물장사도 시스템이 재밌다.       약간 전략겜으로 유닛을 키우고, 적절히 배치하고 성장하는 미니게임인데 만족스러웠다.  돈을 뿌리는 것이 생겨서 필요없는 전투를 피할 수 있다.         아까도 말했지만 돈을 굉장히 많이 줘서 아이템사는 돈이 매우 많이 남는다고 했다.       그래서 전투하기 싫을 때 돈 막 뿌리고 다녔다.  마무리 지금은 용과같이 극2 거의 다했다.        이게 끊을 수가 없다. ㅋㅋㅋ         사진도 넣고 싶은데 겜하면서 스크린샷 찍기도 힘들고 사진 넣기가 귀찮다 ㅋㅋ 블로그에 글쓰는 건 재밌긴한데 귀찮은게 신기하다.  페르소나 더 스크램블하고 용과같이 극2, 스트레이, 13기병방위권 같이 돌리고 있는데 빡세다.      그래도 빵먹으면서 게임하는건 세상 천국이다. 이대로 히키코모리가 될까봐 겁난다."
  },
  
  {
    "title": "Prefix Sum 문제",
    "url": "/posts/Prefix-Sum/",
    "categories": "BOJ",
    "tags": "PrefixSum, 누적합",
    "date": "2022-10-27 00:00:00 +0900",
    "content": "백준 23877번 Convoluted Intervals 문제풀이  [23877 Convoluted Intervals] https://www.acmicpc.net/problem/23877  .     누적합과 조합론 지식을 이용하여 문제를 푼다.  2학년 중간고사가 끝나서 다시 알고리즘 문제를 잡기 시작했다.         근데 뭔가…벌써 기말 대비를 해야할 것 같은 기분이 든다.ㅋㅋ         요즘은 USACO문제를 풀고 있는데…오..문제가 좋은 문제가 많은 듯하다.        코트포스 연습하기에도 좋은 문제들이다.         이 문제는 내가 꽤 고생했어서 풀이를 남겨보려고 한다.  문제상황 파악하기. 게임을 이길 수 있게 하는 i, j쌍의 수를 구한다.       i, j쌍의 개수는 N^2개가 있다.      조건을 만족하는 쌍을 구하는 것이다.  아이디어 얻기. 시작점과 끝점 합한 값을 직접 구하려고 하면 N^2이므로 이미 시간 초과다.      그래서 m이 5000이하라는 것을 이용해야한다.       먼저 시작점이 몇번 나왔는지, 끝점이 몇번나왔는지를 기록한다.     Ai+Aj = k라고 할때 시작점이 k값이 되는 값을 M^2에 구할 수 있다.      끝점도 마찬가지로 구하면 st[i] : i라는 숫자가 시작점인 쌍의 개수 ed[i] : i라는 숫자가 끝점이 쌍의 개수 로 정의 할 수 있다.        그러면 0부터 차례로 올라가며 시작점 쌍의 개수를 더하고 끝점 쌍의 개수를 빼면 된다.  주의할 점 쌍의 개수가 최대 N^2이니까 이것만 보고도 답은 int 형을 넘어간다는 것을 알 수 있다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long  ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const int MAX = 5001; ll ans[2*MAX+1]; int main(){     fast_io     int n, m; cin &gt;&gt; n &gt;&gt; m;     vector&lt;ll&gt; a(MAX+1, 0), b(MAX+1, 0), st(2*MAX+1, 0), ed(2*MAX+1, 0);     for(int i=1;i&lt;=n;i++){         ll x, y; cin &gt;&gt; x &gt;&gt; y;         a[x]++; b[y]++;     }     for(int i=0;i&lt;=m;i++){         for(int j=0;j&lt;=m;j++){             st[i+j] += a[i]*a[j];             ed[i+j] += b[i]*b[j];         }     }          for(int k=0;k&lt;=2*m;k++){         ans[k] = (k ? ans[k-1] : 0) +st[k];         cout &lt;&lt; ans[k] &lt;&lt; '\\n';         ans[k] -= ed[k];     }      }"
  },
  
  {
    "title": "코드포스 - 점수가 계속 하락 중",
    "url": "/posts/Codeforces-828,-EDU-137/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2022-10-18 00:00:00 +0900",
    "content": "codeforce round #828(div 3), EDU #137(div 2) 업솔빙  codeforce round #828(div 3), EDU #137(div 2) 업솔빙 으음.. 요즘 계속 점수가 떨어지고 있다. 이러다가 뉴비까지 간다면 정말 부끄러워서 죽고싶을 것 같다.        실력이 늘고 있다는 생각도 잘 안들고, 점수는 오히려 낙하하니 멘탈이 많이 안좋아졌다.       그래서 구글에 코드포스 잘하는 법 같은걸 쳐서 좀 봤다.ㅋㅋ        그 중에서 인상깊었던 내용은 shift님의 글 이었다.        표본에 따라서 못해보일 수도 있고 어쨋든 실력은 늘고 있다는 것에 뭔가 힘이 났다.       어쨋든 나는 코드포스랑 끝장을 볼꺼니까 못해도 계속할 것이다.       어쨋든 828은 div3라 무난했고 5솔을 하며 블루퍼포가 나오는 줄 알았지만 open hack 때 hack당했다.(TLE)… 완전 절망이었다.        그리고 에듀라운드 137은….할많하않이다.         나는 에듀라운드를 잘 본적이 없다. 뒤에서 업솔빙하며 왜 망했는지 분석을 해보도록 하겠다.  828 A. A. Number Replacement(0:05) 이 전에 나왔던 숫자를 map으로 저장해두고 중간에 모순이 생기면 “NO”를 출력하면 된다.  828 B. Even-Odd Increments(0:14)    짝수+짝수 = 짝수, 짝수 + 홀수 = 홀수, 홀수 + 홀수 = 짝수          위 성질을 이용하면 된다.   828 C. Traffic Light(0:25) 문제이해가 조금 까다로웠지만 그냥 정해진 패턴이 계속 반복되고 초록불일 때 건널 수 있다.        그 때 가장 긴 대기시간만 찾으면 된다.        주어진 색깔의 idx를 저장하는 스택을 만들어 이를 해결했다. #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long  ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n; char c;         cin &gt;&gt; n &gt;&gt; c;         string traffic; cin &gt;&gt; traffic;         traffic += traffic;         stack&lt;int&gt; s;         int res = 0;         for(int i=0;i&lt;traffic.size();i++){             if(traffic[i]==c) s.push(i);             if(traffic[i]=='g'){                 while (!s.empty()) {                     res = max(res, i-s.top());                     s.pop();                 }             }         }         cout &lt;&lt; res &lt;&lt; '\\n';     } }   828 D. Divisibility by 2^n(0:54) 문제는 꽤 간단한데 2의 거듭제곱의 순서가 까다로웠다. (예를 들면, 4가 6보다 먼저나옴)    2가 몇개 들어가는지 구한다.   내가 가진 수의 개수(i의 개수)에 2의 몇승 까지 들어갈 수 있는지 check한다.   아래 코드는 이 두가지 논리 중에 아랫부분만 썼다. int res = 0; int k = 1, c=-1; while (k&lt;=n) {     k &lt;&lt;= 1;     c++; } k &gt;&gt;= 1;          for(;k!=1;k &gt;&gt;= 1, c--){     int p = n/k-n/(k&lt;&lt;1);     for(int i=0;i&lt;p;i++){         cnt += c;         res++;         if(cnt &gt;= n) break;     }     if(cnt &gt;= n) break; }   828 E1. Divisible Numbers (easy version)(upsolving) E번은 꽤나 잘풀었는데 핵 당했다… 확인해보니 while문만 안썼어도 통과했을 것이다..          시간 복잡도가 nlogn으로 계산해서 넉넉할줄 알았는데 while문을 쓰면 안됐다 ㅠㅠ         내가 많이 하는 실수 중 하나인데 예를들어 9가 몇개 있어야 100을 넘어가냐 라고 한다면 9*(100/9+1)를 하면 되는데 이를 while문으로 찾다가 시간초과 나는 것이다.       아래 그 시간초과 난 코드를 기입했다.(여기서 while문만 빼면 답이다 ㅠㅠ) #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long  ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;   ll gcd(ll a, ll b){     if(a&lt;b) return gcd(b, a);     return (!b ? a : gcd(b, a%b)); }   int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         ll a, b, c, d;         cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;         ll p = a*b;         pll res = {-1, -1};         for(ll i=a+1;i&lt;=c;i++){             ll g = gcd(p, i);             ll k = p/g;             ll cnt = 1;             while (k*cnt&lt;=d) {                 cnt++;             }             cnt--;             if(k*cnt&gt;b){                 res = {i, k*cnt};             }         }         cout &lt;&lt; res.first &lt;&lt; ' ' &lt;&lt; res.second &lt;&lt; '\\n';     } }   828 F. MEX vs MED(upsolving) F인데 E2보다 쉬운것 같아서 풀다가 끝났다.      규칙은 찾아냈는데 0, 1, 2 이런식으로 원소들이 빠짐없이 있어야 MEX가 더 크다.     137 A. Password(0:03) 조합론 문제였다.       안쓰인 것 중 2개를 고르고 4자리 중 다시 2자리를 고르면 된다.       배열을 입력받은 것을 안쓰는게 낚시다.  137 B. Permutation Value(0:12) 1 n 2 n-1 3 n-2 .. 순으로 출력하면 된다. #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long  ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n; cin &gt;&gt; n;         vector&lt;int&gt; ans(n+1);         for(int i=1;i&lt;=(n+1)/2;i++){             ans[2*i-1] = i;         }         for(int i=n;i&gt;(n+1)/2;i--){             ans[2*(n-i+1)] = i;         }         for(int i=1;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' ';         cout &lt;&lt; '\\n';     } }   137 C. Save the Magazines(upsolving) 이것 땜에 나락갔는데 냅색 테크닉 처럼 풀면 바로 풀릴 줄 알았따.      근데 내가 dp를 하지 않고 냅색처럼해서 시간 초과가 났다.      근데 여기서 뇌절인게 dp로 바꿔서 풀어야하는데 내풀이를 최적화 하려다가 망했다.    아래는 dp풀이다. #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long  ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const int MAX = 2e5+1; int n, res; string s; vector&lt;int&gt; a; int dp[MAX][2]; //i번째의 상태가 state일 때 최댓값  int dfs(int idx, int state){     if(idx==n) return 0;     int &amp;ret = dp[idx][state];     if(ret!=-1) return ret;          if(state){         ret = max(ret, a[idx]+dfs(idx+1, s[idx+1]-'0'));     }else{         if(s[idx+1]=='1'){             ret = max(ret, dfs(idx+1, s[idx+1]-'0'));             ret = max(ret, a[idx]+dfs(idx+1, s[idx+1]-'0'-1));         }else{             ret = max(ret, dfs(idx+1, s[idx+1]-'0'));         }     }          return ret; }  int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         cin &gt;&gt; n &gt;&gt; s;         a = vector&lt;int&gt; (n);         for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i];         memset(dp, -1, sizeof(dp));         cout &lt;&lt;  dfs(0, s[0]-'0') &lt;&lt; '\\n';     } }   137 D. Problem with Random Tests(upsolving) 다음에 풀어 보려고 한다 ㅠㅠ 못건드린 문제다  137 E. FTL(upsolving) 나는 대회 중에는 이걸 잡았다.      냅색 테크닉으로 할 수 있을 것 같았기 떄문이다.        그런데 반례 찾기가 어려웠다.         마치 백준에서 유명한 라면사기 문제처럼 반례가 잘 안보이는 문제였다.       이런 문제는 뇌절하기가 참 쉽다.(뭔가 엄밀하게 생각하는 것도 좋을 것 같다 )    일단 내가 틀린 반례는 다음과 같다. 3 19 4 29 11 2  ans : 67 output : 77  무조건 둘을 같이 쏴야 이득이라고 생각했는데 충전시간이  짧은걸 쏘고 다른게 충전 되는동안 다시 충전해서 같이 쏘는 식으로 하는게  더 짧을 수 있다는 생각을 못했다.      이것은 한번에 계산하는게 아니라 1차적으로 같이 뎀지 넣어서 최솟값을 구하고 따로 최솟값을 구했던 것을 이용하여 구한다.       말이 좀 이상하다. #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const ll INF = 1e16; ll p1, p2, t1, t2, HP, S; ll dp[5001], dp2[5001];  int main(){     fast_io     cin &gt;&gt; p1 &gt;&gt; t1;     cin &gt;&gt; p2 &gt;&gt; t2;     cin &gt;&gt; HP &gt;&gt; S;     if(t1==t2){         ll dam = p1+p2-S;                  cout &lt;&lt; ((HP+dam-1)/dam)*t1;         return 0;     }          for(int i=1;i&lt;=HP;i++){         dp[i] = INF;         dp2[i] = INF;     }          for(int i=0;i&lt;=HP;i++){         for(int j=0;i+j&lt;=HP;j++){             if(i+j==0) continue;             ll time = max(t1*i, t2*j);             ll dmg = i*p1+j*p2-(i+j-(i&amp;&amp;j))*S; // dp[]에 댐지를 최대로 넣을수있는 상태를 저장             dmg = min(dmg, HP);             dp[dmg] = min(dp[dmg], time);         }     }          for(ll i=0;i&lt;HP;i++){         for(ll j=0;j&lt;=HP;j++){             if(dp[j]==INF) continue;             ll dmg = min(HP, i+j);             dp2[dmg] = min(dp2[dmg], dp2[i]+dp[j]);         }     }          cout &lt;&lt; dp2[HP]; }    요즘 너무 못해서 참 힘들다… 그래도 버티고 하다보면 늘어가는 CP지식!이 되었으면 좋겠다.         못한다고 해서 그만둘것도 아닌데 찡찡대는 것은 그만해야겠다.!!"
  },
  
  {
    "title": "코드포스 - 실력이 안늘어 ㅠㅠ",
    "url": "/posts/Codeforces-823,-824/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2022-10-03 00:00:00 +0900",
    "content": "codeforce round #823(div 2), #824(div 2) 업솔빙  Codeforces Round #823, #824 개요 최근 두 달간 코드포스 포스팅을 안올렸다. 그래도 꽤 열심히 참여했는데 822 때 한번 4솔하고 나머지는 또 2솔 수준이다. ㅠㅠ        살면서 머리가 나쁘다는 생각은 해본적이 없는데 이 쯤 되니 머리가 안따라주는 것 같다.(머리가 늙은건가)         내가 열심히만 하면 다 이겨라는 생각을 가지고 살았었는데 블루 가기가 이렇게 힘들다니 ㅠㅠ 알고리즘을 하면서 겸손을 배운다.       너무 대단한 사람들이 많다. 빨리 따라잡고 싶다.       824는 B번 풀다가 빡종해버렸다. 스트레스 때문에 문제를 볼 수가 없었다.      사실 떨어지면 떨어지나보다 라고 생각하는 것도 필요한데 한 문제 한 문제가 안풀릴때마다 너무 불안하다.        107점 시원하게 박았으니 다시 초심으로 돌아가서 열심히 풀어봐야겟다.  823 A. Planets(0:06) C로 묶음으로 파괴할 수 있다. 그니까 행성의 개수가 C보다 많으면 C로 한번에 파괴하는게 이득이고, 아니면 하나씩 파괴하는게 이득이다. int n, c; cin &gt;&gt; n &gt;&gt; c; vector&lt;int&gt; a(n); for(int i=0;i&lt;n;i++){     cin &gt;&gt; a[i];     orbit[a[i]]++; } int res = 0; for(int i=1;i&lt;=100;i++){     if(orbit[i]){         if(orbit[i]&gt;c) res += c;         else res += orbit[i];     } } cout &lt;&lt; res &lt;&lt; '\\n'; memset(orbit, 0, sizeof(orbit));   823 B. Meeting on the Line(upsolving) 이번엔 B를 못풀었다.      사람들이 어려웠다고는 했지만 그 사람들은 풀었고 난 못 풀었다.     그냥 실력차가 어마무시하다 ㅠㅠ        이분탐색으로 풀거나 그리디하게 풀 수 있다.        이분탐색으로 푼다면 만나는 시간을 찾아서 거기서 부터 계산한다.      그리디로 푼다면 나오는 시간을 기준으로 가장 작은 것과 가장 큰 것의 중간에서 만나는 것으로 풀 수 있다.       그 중간꺼는 어짜피 가면서 같이 갈 수 있다.       핵심은 음수 일 수도 있으니 처음 시작 최대, 최소를 잘 설정해줘야하고 precision()은 필수다. cout &lt;&lt; fixed; cout.precision(15); int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), t(n); for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i]; int mn = INF, mx = -INF; for(int i=0;i&lt;n;i++){     cin &gt;&gt; t[i];     mn = min(mn, a[i]-t[i]);     mx = max(mx, a[i]+t[i]); } cout &lt;&lt; double(mn+mx)/2.0 &lt;&lt; '\\n';   823 C. Minimum Notation(1:28) B 박살나고 한번 와봤는데 좀 쉬워보였다.       그래서 열심히 구현했는데 몇번 틀렸다.    1은 걍 가만히 놔두는게 이득이다   자신보다 앞에 있는데 크면 내 뒤로 보내는게 이득이다.   작은 것부터 보면서 그 뒤에 나오는게 인덱스가 더 앞이면 +1 해서 뒤로 보내는 것이다.   min(9, 어쩌구)를 해줘야한다 (이것땜에 틀렸다 ㅠ)   bool compare(pii p1, pii p2){     if(p1.first!=p2.first) return p1.first&lt;p2.first;     return p1.second &gt; p2.second; } int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         string str; cin &gt;&gt; str;         vector&lt;pii&gt; X(str.length());         for(int i=0;i&lt;str.length();i++){             X[i].first = str[i];             X[i].second = i;         }         sort(X.begin(), X.end(), compare);         int mi = 0;         for(int i=0;i&lt;str.length();i++){             int temp = X[i].second;             while(i&lt;str.length()-1&amp;&amp;X[i].first==X[i+1].first){                 if(mi&gt;X[i].second) cout &lt;&lt; min('9', (char)(X[i].first+1));                 else cout &lt;&lt; (char)X[i].first;                 i++;             }             if(mi&gt;X[i].second) cout &lt;&lt; min('9', (char)(X[i].first+1));             else cout &lt;&lt; (char)X[i].first;             mi = max(mi, temp);         }         cout &lt;&lt; '\\n';     } }   823 D. Prefixes and Suffixes(upsolving) 문제 이해는 문장이 짧고 간결해서 매우 쉽다.    바꿀 덩어리 크기를 고른다 k   s1의 앞에서 k, s2의 뒤에서 k를 바꾼다.  s1==s2인 상태를 만들 수 있는가? 없는가?  일단 s2를 뒤집어서 t를 만든다 그러면 각 대응 되는 쌍은 서로 뒤바꿀 수 있다.        이들을 움직여서 똑같이 만든다는 것은 s1이 팰린드롬이면 된다.       abc 와 pqr을 바꾼다고 하면 rqp cba 로 바뀐다. 이렇게 바뀌는 것을 이용하면 쌍만 적절히 있으면 무조건 팰린드롬을 만들 수 있다는 것이다.         그래서 문제가 팰린드롬을 만들 수 있는가 없는가로 바뀌게 된다.         따라서 쌍의 개수가 짝수면 양옆으로 흩뿌리면 되니까 ok고 쌍이 홀수면 두 문자가 같은 경우는 가운데 박으면 되니까 하나 정도는 있어도 된다.        이를 이용하면 코드는 아래와 같다.     int n; cin &gt;&gt; n; string s, t; cin &gt;&gt; s &gt;&gt; t; reverse(t.begin(), t.end()); map&lt;pii, int&gt; m; for(int i=0;i&lt;n;i++){ if(s[i]&gt;t[i]) swap(s[i], t[i]); m[make_pair(s[i], t[i])]++; } map&lt;pii, int&gt; ::iterator it; it = m.begin(); int cnt = 0; while (it!=m.end()) { if(it-&gt;second%2){     cnt += 1 +(it-&gt;first.first!=it-&gt;first.second); } it++; } cout &lt;&lt; ((cnt&lt;=1) ? \"YES\\n\" : \"NO\\n\");           824 A. Working Week(0:11) 은근히 빡셌다. 그리고 이게 이번 셋에서 처음이자 마지막으로 풀게된 문제일지도 몰랐다. ㅋㅋㅋ int n; cin &gt;&gt; n; if(n&lt;9) cout &lt;&lt; 0 &lt;&lt; '\\n'; else{     n -= 3;     cout &lt;&lt; (n/3)-1 &lt;&lt; '\\n'; }  3개의 구간으로 나누는게 중요하니까 이런식으로 나눌 수 있다.     벽세우는거 -3하고 3구간으로 쪼갰을 때 그 중 젤 작은건 균일하게 쪼개고 동일한거에서 -1한거다.  824 B. Tea with Tangerines(upsolving) 쉬운줄 알았는데 8틀을 박았다.     진짜 너무 화나서 이것만 풀고 끝낸다라고 생각하고 하다가 걍 던져버렸다.       지금 이순간에도 왜 틀렸는지 솔직히 모르겠다.(그냥 에디토리얼 보러갔다옴)       아, 보고 왔는데 비슷하게 한 것 같은데 그냥 틀려버렸다 ㄷㄷ. 반례를 찾는게 진짜 어렵다 ㅠㅠ      먼가 off-by-one 처럼 아슬아슬하게 빗나가는게 있나보다… 경계값도 다해봤는데 허무하다.      이것땜에 107점 떨궜다..하…      나는 하나를 못풀면 못넘어가겠다 ㅠ 계속 생각나서 뒤에 것도 못푼다.     나의 문제풀이 방식을 좀 바꿀 필요도 있겠다. int main(){     fast_io     int tt; cin &gt;&gt; tt;     while (tt--) {         int n; cin &gt;&gt; n;         vector&lt;ll&gt; a(n);         for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i];         ll res = 0;         for(int i=0;i&lt;n;i++){             res += (a[i]-1)/(2*a[0]-1);         }         cout &lt;&lt; res &lt;&lt; '\\n';     } }   824 C. Phase Shift(upsolving) 여기부터는 안풀었었다.(B 때문에 스트레스 받아서)        그래도 이 문제는 읽어는 봤다. 뭔가 짜증나보여서 걍 B에 올인한것이였다.        문제이해가 잘 안됐다. 대충은 알겠는데 조건이 좀 잡다해서 일단 이해한건 다음과 같다.    문자가 대응되는데 같은 문자로 대응되면 안된다.   대응되고 나서 그 문자로만 순환(시계처럼)되면 안된다.     뭔가 말이 애매한데….그건 내가 이해를 잘 못해서 그렇다.      그래서 하나씩 매치해나가고     bool check(int x, int j){  bool ok = true;  int cnt = 0;  while (E[j]!=-1) {      j = E[j];      cnt++;      if(j==x&amp;&amp;cnt!=25){          ok = false;          break;      }  }  return ok; }          위 처럼 쭉 따라갔을 때 일부만으로 원이 만들어지면 false를 준다.        cnt가 25라는 것은 원을 모든 알파벳을 이용하여 만든거니까 가능하다.      823 D. Meta-set(upsolving) 왜케 문제가 이해가 안되는지 모르겠다. 천천히 읽어봤는데 C도 그렇고 해석이 안된다 ㄷㄷ.        파파고 돌렸는데 더 모르겠다 ㅋㅋㅋ        문제를 정확히 이해하는 것도 중요한데 B번 풀었어도 C, D 이해 안되어서 못풀었을 것 같다. ㅠㅠ         수업시간에 열심히 보면서 겨우 이해했다.      3개의 세트는 무조건 포함을 해야한다. 그리고 나머지 2개는 상관없다.        그러니 한 세트 별로 그 세트를 제외한 나머지 부분에서 몇개를 고를 수 있는지 체크하면 된다.       모든 세트일때를 구해두고 정답을 구할 땐 문제에서 주어진 set에서만 계산하면 된다. #include &lt;bits/stdc++.h&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  int n, k;  int main(){     fast_io     cin &gt;&gt; n &gt;&gt; k;     vector&lt;vector&lt;int&gt; &gt; V(n);     for(int i=0;i&lt;n;i++){         vector&lt;int&gt; inV(k);         for(int j=0;j&lt;k;j++) cin &gt;&gt; inV[j];         V[i] = inV;     }     map&lt;vector&lt;int&gt; , int&gt; m;     for(int i=0;i&lt;n;i++){         for(int j=i+1;j&lt;n;j++){             vector&lt;int&gt; tmp(k);             for(int p=0;p&lt;k;p++){                 tmp[p] = (6-V[i][p]-V[j][p])%3;             }             m[tmp]++;         }     }     ll res = 0;     for(int i=0;i&lt;n;i++){         ll X = m[V[i]];         res += X*(X-1)/2;     }     cout &lt;&lt; res; }"
  },
  
  {
    "title": "앳코더 - 첫  앳코더",
    "url": "/posts/AtCoder-Beginner-Contest-270/",
    "categories": "Atcoder",
    "tags": "upsolving, 앳코더",
    "date": "2022-09-25 00:00:00 +0900",
    "content": "AtCoder Beginner Contest 270 업솔빙  AtCoder Beginner Contest 270 개요 앳코더는 처음 리뷰 및 업솔빙을 한다.       문제가 깔끔하고 UI도 코포보다 더 좋은것 같다.ㅋㅋ 근데 첫 앳코더라 그런지 망치긴했다.      아니 사실 망친건지 아닌지 기준도 잘모르긴한다. 첫 앳코더 결과는 3솔이였다.(3/8)      사실 이전에 참가신청 하고 안한적이 있는데 코포는 참가신청하고 안하면 점수가 안떨어지는데 이건 그냥 나락간다.       그래서 처음에 점수 0에서 5로 올랐다. ㅋㅋㅋㅋ 망한 아이디지만 계속 해서 실력을 키워보려고 한다.        바닥부터 시작해야 진짜 실력 올라가는게 체감되니까 재밌다.  A - 1-2-4 Test(0:3) 이 문제 풀고 뭐지 앳코더? 이렇게 쉬운걸 낸다고?했다.      그냥 bit OR 연산하면 된다… 아직도 뭔가 어이없다.  int a, b; cin &gt;&gt;a &gt;&gt; b;     cout &lt;&lt; (a|b);   B - Hammer(0:9) 솔직히 쉬운데 귀찮았다.       조건을 나누는 것이 실수하기 좋았지만 다행히 실수 안했다.      x, y 부호가 다르면 x로 가면 끝 같으면 이제 z, y를 같은 논리로 비교하면 끝. int x, y, z; cin &gt;&gt;x &gt;&gt;y &gt;&gt; z; if(x*y&lt;0){     cout &lt;&lt; abs(x); }else{     if(abs(x)&lt;abs(y)) cout &lt;&lt; abs(x);     else{         if(z*y&lt;0) cout &lt;&lt; abs(x)+2*abs(z);         else{             if(abs(z)&lt;abs(y)) cout &lt;&lt; abs(x);             else cout &lt;&lt; -1;         }     } }   C - Simple path(0:15) 여기까지 와 앳코더 문제 깔끔하고 쉽네 했다.(물론 다음부터 개털렸다.)        문제가 그냥 웰노운같은 느낌이였고 BFS또는 DFS로 풀 수 있겠다 싶었다.      sw(스위치)라는 bool형 변수를 전역으로 설정해두고 스위치가 켜지면 그때부터 올라오면서 답에 추가했다.        마지막에 출력할 때 답을 reverse해서 출력하면 끝. void dfs(int here, int parent){     if(here==y) sw = true;          for(int next : adj[here]){         if(next==parent||sw) continue;         dfs(next, here);     }          if(sw) ans.push_back(here); }   D - Stones (upsolving) 이 문제 때문에 앳코더 업솔빙을 하기로 마음먹었다.        정말 뒤통수를 얻어 맞은 느낌이였다.        왜냐면 너무 그리디같았는데 DP였기 때문이다. 사실 그리디로 3번 틀렸으면 DP로 접근할 수도 있었는데 반례가 진짜 너무   안보여서 계속 그리디로 하다가 망했다.        굉장히 도움이 되는 문제였다. 최근에 바텀업 DP만 연습했는데 실제로 만나서 못푼게 너무 아쉽다 ㅠㅠ cin &gt;&gt; n &gt;&gt; k; for(int i=0;i&lt;k;i++){     cin &gt;&gt;A[i];     dp[A[i]] = A[i]; } for(int i=1;i&lt;=n;i++){     for(int j=0;j&lt;k;j++){         // i를 다 가져가면 좋겠는데 A[j]가져가면 상대는 dp[i-A[j]]를 가져간다.                  // 그러니까 i-dp[i-A[j]]가 이번턴에 내가 가져갈 수 있는 최대다.         if(i&gt;=A[j]) dp[i] = max(dp[i], i-dp[i-A[j]]);     } } cout &lt;&lt; dp[n];   E - Apple Baskets on Circle(upsolving) 차라리 D말고 이걸 잡을걸 그랬나? 싶었다 그때는….         나머지 연산느낌이 나서 열심히 했는데 틀렸다 ㅠㅠ 반례 찾기도 힘들었다.       그리고 에디토리얼 보는데 이게 왜 이분탐색? 이분탐색으로 풀 수 있는 문제들은 좀 숨어있는 것 같다.       물론 웰노운인데 내가 모른걸 수도 있지만 ㅠㅠ 그냥 내 기준 원탑이다 어려운거…       일단 범위관찰만 해도 NlogN 또는 NlogK로도 풀 수있다는 걸 알 수 있다.       근데 나는 k가 워낙에 크니까 이를 log로 줄인다는 생각을 못했다 ㅠㅠ.        일단 k를 커버할라면 몇바퀴 돌아야 하는지를 계산하고 처리할 수 있을만큼 처리한 후에 n개를 쭉 돌면서 하나씩 빼주면 된다.       그 k cover를 위해 몇바퀴 돌아야하는지를 이분탐색으로 logK만에 찾을 수 있다. ll l = 0, r = 1e12+1; while (l+1&lt;r) {     ll mid = (l+r)&gt;&gt;1;     ll sum = 0;     for(int i=0;i&lt;n;i++){         sum += min(A[i], mid);     }     if(sum&lt;=k) l = mid;     else r = mid; }      for(int i=0;i&lt;n;i++){     k -= min(A[i], l);     A[i] -= min(A[i], l); } int i=0; while (k) {     if(A[i]){         A[i++]--;         k--;     }else i++; } for(int i=0;i&lt;n;i++) cout &lt;&lt; A[i] &lt;&lt; ' ';  몇 바퀴 돌지를 먼저 찾는게 중요했다…  F - Transportation(upsolving) 여기부터는 대회 땐 아예 건들지도 못했는데 맘에 드는 set이라서 풀어보려고 한다.       내가 코포를 하면 할 수록 느끼는 것은 엄청 어려운 알고리즘은 잘 안나온다는 것이다.        idea와 정확성이 정말 중요하다.       idea를 최대한 많이 배워가기 위해 업솔빙도 최대한 많이 하는게 좋을 것 같다!!  이 문제는 보니까 DP같았다. 하지만 아니였다 ㅋㅋㅋㅋ        이 문제도 너무 좋은 문제같다. 공항을 통해 가는 것은 N+1을 경유한다고 가정하고 다리로 가는건 N+2를 경유한다고 가정한다.       그러면 모든 관계를 그래프의 간선으로 표현할 수 있고 이 그래프에서 최소 스패닝 트리를 찾으면 되는 것이다 ㄷㄷ 재밌는 문제였다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;cassert&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const ll INF = 1e15; const int MAX = 2e5+4; ll n, m; vector&lt;int&gt; X, Y; vector&lt;ll&gt; Z, A, B; vector&lt;pll&gt; adj[MAX];  struct DisjointSet{     vector&lt;int&gt; parent, rank;     DisjointSet(int n) : parent(n+1), rank(n+1, 1){         for(int i=1;i&lt;=n;i++) parent[i] = i;     }     int find(int u){         if(parent[u]==u) return u;         return parent[u] = find(parent[u]);     }     void merge(int u, int v){         u = find(u); v = find(v);         if(u==v) return;                  if(rank[u]&lt;rank[v]) swap(u, v);         parent[v] = u;         rank[u] += rank[v];         rank[v] = 0;     } };  ll kruskal(){     ll ret =0;     vector&lt;pair&lt;ll, pll&gt;&gt; edges;     for(int i=1;i&lt;=n+2;i++){         for(pll next : adj[i]){             edges.push_back({next.second, {i, next.first}});         }     }     sort(edges.begin(), edges.end());     DisjointSet dset(n+2);     set&lt;ll&gt; ss;     for(int i=0;i&lt;edges.size();i++){         ll s = edges[i].second.first;         ll e = edges[i].second.second;         ll c = edges[i].first;                  if(dset.find(s)==dset.find(e)) continue;         dset.merge(s, e);         if(s&lt;=n) ss.insert(s);         if(e&lt;=n) ss.insert(e);         ret += c;     }     if(ss.size()&lt;n) ret = INF;          return ret; }  int main(){     fast_io     cin &gt;&gt; n &gt;&gt; m;     X = Y = vector&lt;int&gt; (n+1);     Z = A = B = vector&lt;ll&gt; (m+1);     for(int i=1;i&lt;=n;i++) cin &gt;&gt; X[i];     for(int i=1;i&lt;=n;i++) cin &gt;&gt; Y[i];     for(int i=1;i&lt;=m;i++){         cin &gt;&gt; A[i] &gt;&gt; B[i] &gt;&gt; Z[i];     }          ll res = INF;     for(int iter=0;iter&lt;4;iter++){         if(iter&amp;1) for(int i=1;i&lt;=n;i++) adj[i].push_back({n+1, X[i]});         if(iter&amp;2) for(int i=1;i&lt;=n;i++) adj[i].push_back({n+2, Y[i]});         for(int i=1;i&lt;=m;i++) adj[A[i]].push_back({B[i], Z[i]});         res = min(kruskal(), res);         for(int i=1;i&lt;=n;i++) adj[i].clear();     }          cout &lt;&lt; res; }    E - 포기 E도 해볼까 했는데 upsolving 하다가 지쳤다.. ㅋㅋ         곱창먹으러 가려고 한다. 내가 대회때 여기까지 풀 수 있는 실력이 빨리 됐으면 좋겠다~ ㅎㅎ"
  },
  
  {
    "title": "게임 리뷰 - 용과같이 극 1",
    "url": "/posts/%EC%9A%A9%EA%B3%BC%EA%B0%99%EC%9D%B4-%EA%B7%B91/",
    "categories": "Game Review",
    "tags": "용과같이, 게임리뷰",
    "date": "2022-09-18 00:00:00 +0900",
    "content": "ps5 게임 : 용과같이 극 1 리뷰  개요 이번에 PS5 plus 스폐셜 혜택으로 용과같이 극1, 제로, 2가 풀렸다.       용과 같이 7으로 입문을 했었던 사람이라서 키류 카즈마의 이야기를 보고 싶었다.       그래서 바로 다운 받아서 순식간에 엔딩을 봤다.      극 1 -&gt; 제로 - &gt; 극 2 순으로 하는것이 게임성이 진화하는 느낌이고, 스포가 없이 즐기 수 있다고 해서 이 순으로 플레이 하려고 했다.       지금은 극1을 깨고 제로를 하고 있다.(stray랑 13기병방위권이라는 게임도 하고 있어서 느리긴하다 ㅎㅎ)  용과같이 극 1    개발 및 유통      용과 같이 스튜디오        용과 같이 스튜디오가 따로 있는걸 처음 알았다.      처음에 나오는 한자가 회사 이름이였다니 ㅎㅎ        Sega      또가, 쨋든 한국도 잘 유통해줘서 고마워요   장르 및 플랫폼, 플레이타임            장르 : 액션 어드벤쳐 플랫폼 : 나는 PS5로 했다. 플레이타임 : 난이도 Hard - 22시간 (subquest 60퍼센트를 안했음 - 거의 스토리만 밀었다.)                버전 정보       극 1, 2는 옛날에 나왔던 용과같이 1, 2를 리메이크 한 것이다.      그래서 그래픽 같은 게임성이 향상된 용과 같이 1, 2이다.        스토리의 시간 순으로 본다면 제로  -&gt;  극1  -&gt;   극2이다.       하지만 제로에서 극1의 스포를 한다고 한다.(아직 제로 하는 중이라 잘 모르겠음)       따라서 발매순서(스토리의 발매) 극1 -&gt; 극2 -&gt; 제로 로 하는 것도 괜찮지만         제로에서 극2로 이어지는 것이 있다고 하니 극1 -&gt; 제로 -&gt; 극2가 국룰이라고 한다.      달점  🌕 🌕 🌕 🌗 🌑 3.5 / 5       솔직히 2016년 리메이크인 것을 따졌을 때 조금 아쉬운 부분도 많아서 3.5점 줬다.      물론 엄청 재밌게 했고 서브퀘스트들도 다 한 것은 아니지만 내 평가는 이렇다.        자세한 것은 아래 게임 플레이 리뷰에 적도록 하겠다.   게임 플레이 방식       용과 같이 7에서 전투 이외는 모두 동일 하다.       메인스토리를 따라가며 전투를 하고 서브퀘스트들로 자금을 모아서 힘을 키운다.     하지만 용과 같이 7보다는 RPG성향이 적다.     확실히 액션겜이라서 그냥 메인스토리만 쭉 미는 것이 가능하다.   스토리 리뷰(스포가 가득함) 대략적인 줄거리는 이러하다.       키류, 니시키야마, 유미 3명의 소꿉친구가 살인사건에 휘말리게 되고 유미는 이 사건 이후 기억을 잃고, 키류는 복역을 하게 된다.        10년 후 복역을 마치고 나온 키류는 유미와 사라진 100억의 행방을 찾고, 그 와중에 하루카라는 꼬마아이를 알게 된다.      찾는걸 하면 할 수록 하루카가 매우 중요한 아이라는 것을 알게 되고, 그 진실을 쫓아 니시키와 대립하는 내용이다.     난 사실 야쿠자와 사무라이를 별로 안좋아한다.(일본 애들 가오 잡는거 보는 것을 별로 안좋아하기 때문임 ㅋㅋ.)       그런 나에게도 키류는 꽤 멋있다라고 생각이 들게한 캐릭터이다.(난 고스트 오브 쓰시마도 주인공이 멋없어서 하다가 말았다.)        키류는 카스가(용과같이7의 주인공)과는 다른게 미친듯이 강한 인간적인 모습은 별로 찾아볼 수 없는 캐릭터지만 서브 퀘스트 들을 하다보면 어? 키류 좀 귀엽네 싶기도하고  메인 퀘를 할 때는 정말 멋있다.       그리고 제일 좋았던 점은 야쿠자를 생각보다 더 더럽게 그려냈다는 것이다.      용과 같이 7의 야쿠자는 걍 귀여웠고 그 악한면이 잘 안드러났다.     하지만 용과같이1은 생각보다 잔인하고 야쿠자의 더러운 모습을 잘 보여줘서 내가 더 키류에 감정이입 할 수 있었다.        스토리에서 가장 아쉬운점은(스포) 유미가 진구와 ….크흠 한 것이다.       인간의 사랑은 어떻게 될지 모르지만 키류를 좋아했던 유미인데. ㅜㅜ       소꿉친구들의 인연이 산산히 부서져버린 것은 좀 아쉽다.      물론 이 것이 나의 재미를 반감시키는 요소는 아니다. 다만 키류가 행복했으면 좋겠어서 그렇다.  게임플레이 리뷰 나는 생각보다 게임 플레이 쪽이 더 불편했다.      많은 사람들이 전투가 용과같이 7으로 가면서 턴제 전투로 바뀌어 아쉽다고 했었다.       그래서 나는 액션에 기대를 많이 했는데 생각보다 별게 없었다.       그냥 네모네모네모세모 후 세모 누르기만 반복하는 것이 조금 아쉬웠다.       물론 히트액션이 다양해서 액션 보는 맛은 있었지만 생각보다 내가 조종하는 싸움 모션이 그리 많지 않았다.       전투는 불한당, 도지마의 용, 파괴자, 러시 이렇게 4가지의 방식이 있는데 4개가 비슷비슷해서 그렇게 느끼는 것같다.        그나마 러시가 무빙하면서 싸우는 맛이 있어서 많이 썼다.(솔직히 파괴자 좀 답답하다)  그리고 서브퀘스트들이 생각보다 반복 요소가 많다.        그냥 얘기하다가 싸우고 얘기하다가 싸우는 식이다. (유머스러워서 꽤 재밌지만 반복되니 그마저도 귀찮아서 안하게 됐다.)       그리고 서브퀘 중 마지마를 찾아야하는 서브퀘들이 있는데 이게 상당히 어렵다.       마지마 고로를 찾으러 다니는게 공략을 안보면 쉽지 않아서 나는 고깔콘에 숨어있는 마지마를 너무 늦게 찾았다.        그래서 도지마의 용 모션이 너무 약했다.(거의 안씀ㅠㅠ)  물론 용과 같이 7과 비교해도(최근 겜인데도) 꿀리지 않을 정도로 재밌는 건 사실이지만 컨텐츠 측면에서 최근 작들보다는 아쉬운 것 같다.  아 그리고 인연을 쌓는 캐릭터들이 내 취향은 아니였다..ㅋㅋㅋ(난 캬바걸 싫어 ㅠㅠ)  음악은 훌륭했고(특히 오프닝곡 너무 좋다) 버그는 적었다.      버그가 하나 있었는데 저장 부스 앞에서 갑자기 멈춰버리는 버그였다.ㅠㅠ       이것 때문에 서브퀘스트 5개 날아갔다(그래서 더 섭퀘를 안하게 됨)       이건 좀 심각한 버그 같은데 다행히 한번만 그랬다.  마무리 지금 용과같이 제로를 하고 있는데 솔직히 제로가 더 재밌따. ㅋㅋㅋ         특히 마지마 형님 사랑해요😍"
  },
  
  {
    "title": "Sum Over Subsets",
    "url": "/posts/SOS/",
    "categories": "BOJ",
    "tags": "sos dp, DP, 부분집합의 합",
    "date": "2022-09-18 00:00:00 +0900",
    "content": "백준 18719번 Binomal 문제풀이  [18719 Binomal] https://www.acmicpc.net/problem/18719  .     SOS DP를 이용하여 부분집합의 합을 빠르게 구해보자.  다이아 문제를 탐색하던 중 5개월 전에 풀다가 ‘당연하게도’ 실패한 Binomal문제가 눈에 들어왔고 열심히 다시 풀어봤는데 안됐다 ㅠㅠ         블로그를 탐색해보니 SOS dp를 이용하는 것이라고 하여 이를 찾아봤다.      그랬더니 binomal문제가 아름답게 보였다 ㄷㄷ 이렇게 깔끔하게 홀수임을 판별하다니 ㅠㅠ       이에 대해서 알아보자  문제상황 파악하기. 배열이 주어지고 그 배열에서 한쌍 (i, j) 를 뽑아서 이항계수를 만들었을 때 그것이 홀수인 쌍의 개수를 구하는 문제이다.       이를 5개월 전(골드일때인가?) 시도 했을 때는 이항계수를 2로 나눈 값을 전처리해서 풀려고 했었고 지금 보니 O(n^2)으로 풀어서 당영히 시간초과다.         그럼 이 문제는 어떻게 풀어야 할까?  Sum Over Subsets가 뭐길래? 비트마스킹을 이용해서 부분 집합의 합을 바르게 구하는 방법이다.       예를 들어서 1011101의 부분집합의 개수를 구하고 싶으면 각자리 수를 포함하는지 안하는지를 보면서 가야한다.      일단 dp[i][k]는 i의 상태(state)와 k까지만 일치하는 것들의 부분집합의 개수이다.       말을 좀 이상하게 한 것 같은데 dp[1101][0]의 개수는 1101의 상태를 가진 것의 개수인 것이다.      dp[1101][1]은 110까지는 같은데 그 이후는 다를 수도 있는 것의 개수이다. 즉 1101또는 1100이 될 것이다.      그러니까 k-1번째 자리에서 0이면 그자리는 선택하면 안되니까    dp[i][k] = dp[i][k-1]이다.   근데 k-1번째 자리가 1이면 그 자리는 선택해도되고 안해도 되니까     dp[i][k] = dp[i][k-1] + dp[i-(1«k-1)][k-1]이 된다.   for(int i=1;i&lt;(1&lt;&lt;20);i++){     for(int j=1;j&lt;21;j++){         dp[i][j] = dp[i][j-1];         if(i&amp;(1&lt;&lt;(j-1))) dp[i][j] += dp[i-(1&lt;&lt;(j-1))][j-1];     } }   아이디어 얻기. 모든 자연수는 2로 나누면 0또는 1이다.     그리고 뤼카정리를 이용하면 이항계수를 이진수 이항계수의 곱으로 나타낼 수 있다.     이 때 하나라도 0이 있으면 곱셈이기때문에 총 0이되고 이는 짝수라는 것이다.       그러니까 부분집합이여야지만 홀수가 나온다.(15C6 같은걸로 해보자)       dp[i][0] : 배열에 i가 몇개 있음? dp[i][20] : 배열에 i보다 작거나 같은게 몇개 있음? 따라서 모든 홀수는 dp[i][0]*dp[i][20]을 곱한값을 모든 i에 대해 더해주면 된다.  주의할 점 Sum Over Subsets DP table을 잘 구했다면 아무 문제 없다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;cassert&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  int n; vector&lt;int&gt; a; ll dp[1&lt;&lt;20][21];  int main(){     fast_io     int tt; cin&gt;&gt;tt;     while (tt--) {         cin &gt;&gt; n;         a = vector&lt;int&gt; (n);         for(int i=0;i&lt;n;i++){             cin &gt;&gt; a[i];             dp[a[i]][0]++;         }         for(int i=1;i&lt;(1&lt;&lt;20);i++){             for(int j=1;j&lt;21;j++){                 dp[i][j] = dp[i][j-1];                 if(i&amp;(1&lt;&lt;(j-1))) dp[i][j] += dp[i-(1&lt;&lt;(j-1))][j-1];             }         }         ll res = 0;         for(int i=0;i&lt;(1&lt;&lt;20);i++){             res += dp[i][0]*dp[i][20];         }         cout &lt;&lt; res &lt;&lt; '\\n';                  memset(dp, 0, sizeof(dp));     } }"
  },
  
  {
    "title": "ETT + Segment Tree",
    "url": "/posts/ETT/",
    "categories": "BOJ",
    "tags": "세그먼트트리, ETT, 오일러투어테크닉",
    "date": "2022-09-18 00:00:00 +0900",
    "content": "백준 14288번 회사문화4 문제풀이  [14288 회사 문화 4] https://www.acmicpc.net/problem/14288  .     오일러 투어 테크닉으로 트리를 배열처럼 만들고 세그먼트 트리를 이용하여 쿼리를 처리한다.  오일러 투어 테크닉을 배우면 대부분 세그먼트 트리랑 연계가 된다.       오일러 투어 테크닉은 트리를 배열 처럼 일직선으로 잘 펴는 테크닉이고 여기서 세그먼트 트리와 연계하기 쉽기 때문이다.      회사 문화 4는 14268 회사문화2와 14287 회사문화3 두 문제를 정확하게 합친 문제나 다름이 없다.      그렇다면 문제를 풀어보자,  문제상황 파악하기. 먼저 한명이 칭찬을 받으면 부하쪽으로 칭찬이 가든가 상사 쪽으로 간다.       이는 switch하는 bool형 변수 하나 만들어서 처리했다.     부하 쪽으로 가는것은 서브 트리에 전부 칭찬을 하면 되어서 쉽다.       상사쪽은 어떻게 해야할까?  Euler Tour Technique(ETT)가 뭐길래?. 위에서 잠깐 언급했듯이 트리를 잘 펴서 배열 처럼 만드는 테크닉이다. int cnt = 0; void dfs(int here, int parent){     in[here] = ++cnt;     for(int next :adj[here]){         if(next ==parent) continue;         dfs(next, here);     }     out[here] = cnt; }  다음과 같이 루트에서 부터 dfs를 돌면서 in, out 배열에 들어가는 순서를 입력한다.      예를 들면 in[1] = 1, out[1] = 7이라면 1번 정점은 첫번째로 들어가서 7번째 턴에 나왔다는 뜻이다.      즉 2번째부터 6번째가 정점 1의 subtree가 되는 것이다.  아이디어 얻기. 부하 방향으로 칭찬 릴레이가 시작되면 쉽다. 서브트리에 전부 칭찬하면 되기 때문이다.      하지만 상사 방향은 조금 까다롭다. 구간 update를 하기에 배열에서 정확한 구간을 찾기가 쉽지 않기 때문이다.      이는 점 update + 구간 쿼리를 이용하여 해결했다.        위 그림 처럼 상사 관계가 되어있다고 치면 2번이 2만큼 칭찬받으면 2를 쓴다.      그 다음 3번이 4만큼 칭찬받으면 4를 쓴다. 또 4번이 6만큼 칭찬받으면 6을 쓴다.       그리고 2번이 칭찬 받은 양을 구하려면 2번부터 2번 이후 서브트리에 기록된 모든 수를 더한다 (2+4+6)그리고 2번 전에 기록된것을 빼면된다(0).        다시한번 예를 들어서 4번이 칭찬받은 양은 (2+4+6)-(2+4)==6이 되는 것이다.        이를 이용하여 세그먼트 트리 2개를 만든다.        1번세그는 부하방향, 2번 세그는 상사방향을 처리한다.  주의할 점 구간 update를 할때 이 아이디어를 이용하기 때문에 세그먼트 트리를 딱 배열의 크기까지만 보는게 아니라 배열의 크기 +1 만큼 봐줘야한다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;cassert&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const int MAX = 100001; int n, m; vector&lt;int&gt; adj[MAX]; int parent[MAX], in[MAX], out[MAX];  struct segTree{     int tree[4*MAX];          void update(int x, int val, int node, int S, int E){         if(S==E){             tree[node] += val;             return;                      }         int mid = (S+E)&gt;&gt;1;         if(x&lt;=mid) update(x, val, 2*node, S, mid);         else update(x, val, 2*node+1, mid+1, E);         tree[node] = tree[2*node] + tree[2*node+1];     }          int query(int L, int R, int node, int S, int E){         if(R&lt;S||L&gt;R) return 0;         if(L&lt;=S&amp;&amp;E&lt;=R) return tree[node];         int mid = (S+E)&gt;&gt;1;         return query(L, R, 2*node, S, mid)+query(L, R, 2*node+1, mid+1, E);     } };  int cnt = 0; void dfs(int here, int parent){     in[here] = ++cnt;     for(int next :adj[here]){         if(next ==parent) continue;         dfs(next, here);     }     out[here] = cnt; }  int main(){     fast_io     cin &gt;&gt; n &gt;&gt; m;     for(int i=1;i&lt;=n;i++){         cin &gt;&gt; parent[i];         if(i!=1) adj[parent[i]].push_back(i);     }     dfs(1, 1);     segTree st1, st2;     bool sw = true;     for(int i=0;i&lt;m;i++){         int o, emp; cin &gt;&gt; o;         if(o==1){             int w;             cin &gt;&gt; emp &gt;&gt; w;             if(sw){                 st1.update(in[emp], w, 1, 1, n+1);                 st1.update(out[emp]+1, -w, 1, 1, n+1);             }else{                 st2.update(in[emp], w, 1, 1, n+1);             }         }else if(o==2){             cin &gt;&gt; emp;             cout &lt;&lt;st1.query(1, in[emp], 1, 1, n+1)+st2.query(1, out[emp], 1, 1, n+1)-st2.query(1, in[emp]-1, 1, 1, n+1) &lt;&lt; '\\n';         }else{             sw ^= 1;         }     } }"
  },
  
  {
    "title": "Segment Tree+KMP",
    "url": "/posts/Segtree+KMP/",
    "categories": "BOJ",
    "tags": "세그먼트트리, KMP, 문자열",
    "date": "2022-09-04 00:00:00 +0900",
    "content": "백준 3308번 Matching 문제풀이  [3308 Matching] https://www.acmicpc.net/problem/3308  .     문자열에서 패턴을 찾을 때 KMP를 이용하는데 세그트리와 접목한 문제를 풀어보자!  내 블로그에 포스팅할때도 KMP랑 Segment tree를 비슷한 시기에 올린 것 같은데 그 둘을 접목한 문제가 있다는 것을 배웠다.      ICPC신촌 캠프할 때 접한 20298 파인애플피자로 이런 유형을 알게 되었다.      이걸 풀어내니 23576 Stock Price Prediction도 풀수 있게 되었다.     결국 KMP를 할때 문자가 같은지 확인하는 부분에서 같은 꼴(비슷한 형태)인지 확인하는 형태로 바꾸면 되는 문제이다.  문제상황 파악하기. 위에서 소개한 두 문제와 정확히 동일하지만 입력의 형태가 좀 다르다.      패턴이 주어지는데 작은 순서대로 인덱스를 주기 때문이다.     예를 들어 2 1 5 3 4처럼 주어지면 2번이 젤 작고 1번, 5번, 3번, 4번 순이라는 뜻이다.         위 그림과 같은 대소관계를 가진 그래프를 찾으면 된다.      이를 그래프 같은 모양의 숫자를 설정해서 파인애플 피자 풀듯이 풀면 끝이다.  아이디어 얻기. 파인애플 피자 풀듯이 풀면 끝이라고는 했지만 파인애플 피자도 포스팅을 안했다. ㅎㅎ      푸는 아이디어는 다음과 같다.     먼저 KMP의 매칭 부분을 잘 보자. for(int i=0, j=0;i&lt;n+k-1;i++){         while (j&amp;&amp;H[i]!=P[j]) j = ff[j-1];  //다르면 failure function에 따라 다시 매칭시작                  if(H[i]==P[j]){             if(j==M-1){                 ret++;      //완벽하게 매칭 됨                 j = ff[j];             }else{                 j++;    //계속 매칭해나감             }                          }     }     return ret;  저기서 Hay 문자열과 Pattern 문자열을 비교하는 부분을 바꾸면 된다.     지금 매칭하는 것은 문자열에서의 rank이다.     그니까 1과 100이 같은 rank일지도 모른다는 것이다.     예를 들면 다음과 같은 것이다.      1 2 3 4 5 와 100 200 300 400 500에서 1과 100은 같은 것이다.      그 이유는 1보다 큰게 패턴에서 4개, 100보다 큰게 4개로 같기 때문이다.     그니까 비교를 할 때 비교대상보다 작은것의 개수, 큰 것의 개수를 세어서 그게 일치하면 같은 문자로 보는 것이다.      세그먼트 트리는 구간에 원소가 몇개 있는지를 Log시간에 셀 수 있으니 이를 이용한다.     근데 이문제는 세그트리 안쓰고 O(N+M)에 풀 수 있다.     중복되는 문자(패턴)가 없기 때문에 25008 문자열 찾기이 문제 처럼 풀 수 있기 때문이다.     하지만 연습삼아 세그트리로 풀꺼다.(근데 시간초과 한번 떴음 ㅠㅠ)      논리는 다음과 같다.    입력을 받아서 패턴(needle)을 만든다.   좌표압축을 통해 패턴(needle)과 hay문자열을 만든다.   자기보다 작은 것의 개수 자기보다 큰것의 개수가 같으면 계속 매칭해나간다.   매칭이 다 됐으면(패턴의 길이와 같으면) 결과에 idx를 추가한다.   주의할 점 일단 나는 재귀 세그를 짰더니 시간초과가 떴다 ㅠㅠ 비재귀 세그로 다시 짜서 내보니 됐다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;cassert&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const int MAX = 1000001;  struct Fenwick{     int n;     int t[2 * MAX];          void modify(int p, int value) {  // plus value at position p       for (t[p += n] += value; p &gt; 1; p &gt;&gt;= 1) t[p&gt;&gt;1] = t[p] + t[p^1];     }          int query(int l, int r) {  // sum on interval [l, r)       int res = 0;       for (l += n, r += n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {         if (l&amp;1) res += t[l++];         if (r&amp;1) res += t[--r];       }       return res;     }          void clear(){         for(int i=0;i&lt;2*MAX;i++) t[i] = 0;     } };   int m, n; vector&lt;int&gt; x, y, X, Y, res, front, back, temp; Fenwick fwt;  bool Match(int i, int j, int sz){     if(front[j]!=fwt.query(0, i)) return false;     if(back[j]!=fwt.query(i+1, MAX)) return false;     return true; }  vector&lt;int&gt; getFail(vector&lt;int&gt; &amp;P){     int sz = P.size();     vector&lt;int&gt; Fail(sz);     for(int i=0;i&lt;sz;i++){         front[i] = fwt.query(0, P[i]);         back[i] = fwt.query(P[i]+1, MAX);         fwt.modify(P[i], 1);     }          fwt.clear();     for(int i=1, j=0;i&lt;sz;i++){         while (j&amp;&amp;!Match(P[i], j, sz)) {             for(int k=i-j;k&lt;i-Fail[j-1];k++) fwt.modify(P[k], -1);             j = Fail[j-1];         }         if(Match(P[i], j, sz)){             Fail[i] = ++j;             fwt.modify(P[i], 1);         }     }     return Fail; }  void KMP(vector&lt;int&gt; &amp;H, vector&lt;int&gt; &amp;P){     int hsz = H.size(), psz = P.size();     vector&lt;int&gt; ff = getFail(P);     fwt.clear();          for(int i=0, j=0;i&lt;hsz;i++){         while (j&amp;&amp;!Match(H[i], j, hsz)) {             for(int k=i-j;k&lt;i-ff[j-1];k++) fwt.modify(H[k], -1);             j = ff[j-1];         }         if(Match(H[i], j, hsz)){             if(j==psz-1){                 res.push_back(i-psz+2);                 for(int k=i-j;k&lt;i-ff[j]+1;k++) fwt.modify(H[k], -1);                 fwt.modify(H[i], 1);                 j = ff[j];             }else{                 j++;                 fwt.modify(H[i], 1);             }         }     } }  void compress(){     sort(x.begin(), x.end());     x.erase(unique(x.begin(), x.end()) ,x.end());     for(int i=0;i&lt;m;i++) X[i] = lower_bound(x.begin(), x.end(), X[i])-x.begin()+1;          sort(y.begin(), y.end());     y.erase(unique(y.begin(), y.end()), y.end());     for(int i=0;i&lt;n;i++) Y[i] = lower_bound(y.begin(), y.end(), Y[i])-y.begin()+1; }  int main(){     fast_io     cin &gt;&gt; m &gt;&gt; n;     x = vector&lt;int&gt; (m); X = vector&lt;int&gt; (m);     y = vector&lt;int&gt; (n); Y = vector&lt;int&gt; (n);     temp = vector&lt;int&gt; (m);     for(int i=0;i&lt;m;i++){         cin &gt;&gt; temp[i];         x[temp[i]-1] = X[temp[i]-1] = i+1;     }     for(int i=0;i&lt;n;i++){         cin &gt;&gt; y[i]; Y[i] = y[i];     }     compress();     front = vector&lt;int&gt; (m);     back = vector&lt;int&gt; (m);     fwt.n = MAX;     KMP(Y, X);     cout &lt;&lt; res.size() &lt;&lt; '\\n';     for(int i=0;i&lt;res.size();i++) cout &lt;&lt; res[i] &lt;&lt; ' ';      }"
  },
  
  {
    "title": "Greedy",
    "url": "/posts/Greedy/",
    "categories": "BOJ",
    "tags": "Greedy, 그리디",
    "date": "2022-09-04 00:00:00 +0900",
    "content": "백준 18186번 라면사기(large) 문제풀이  [18186 라면사기(large)] https://www.acmicpc.net/problem/18186  .     그리디하게 문제를 해결해보자!  사람들이 많이 푼 다이아 문제 중 하나라서 언젠가 꼭 풀어봐야지 했던 문제다.      좀 보면 그리디라는 건 쉽게 알아차릴 수 있다.     근데 다른사람들도 많이 그랬던데 단순히 3개를 사는 걸 먼저하면 틀린다.      그리디를 어떻게 해야할지가 꽤 까다로운 문제였다.  문제상황 파악하기. 위에서 얘기 했던대로 라면 사는 걸 7원으로 사는게 가장 이득이니까 단순히 그것부터 하면 틀린다.     대표적인 반례는 B = 3, C = 2일 때 1 2 1 1이 있고 이는 0 1 1 1 로 바꾸고 0 0 0 0으로 바꾸는게 이득이다.      단순히 0 1 0 1로 바꾸면 곤란해진다.      이렇게 되는 이유는 1 2 1 에서 2가 마지막 1보다 크기 때문이다.     이를 어떻게 해결해야 할까?  아이디어 얻기. i+1번째 라면 공장에서 라면을 살때 i-1, i, i+1 중에서 i가 i+1보다 크면, i를 먼저 처리하는 게 중요하다.     근데 사실 i+1번째 공장에서 사야할 라면이 더 많아도 i를 먼저 처리해주면 된다.     그러니 B로 산 행위를 B+C로 바꾸는 걸 먼저해줘도 된다는 뜻이다.    등차수열이니 이렇게 된다.    이게 더 이득인 이유를 대충 말해보면 그 다음 i+2로 가면 B로 따로 사는 것보다 B+C를 B+2C로 바꾸는게 이득이니까 그 가능성을 더 늘리는 것이다.      따라서 아래와 같이 내 구입목록 클래스를 만들었다. class purchase{ public:     //first = B로 산거 다음에 B+C로 업글     //second = B+C로 산거 다음에 B+2C로 업글     // third = B+2C로 산거.     int first= 0, second= 0, third=0;     ll res = 0; };  이전에 first 행동을 second행동으로 바꾸는 걸 제일 먼저,     그 다음에 second 행동을 third 행동으로 바꾸는게 두번째,  마지막은 그냥 낱개로 사는 first행동을 하는게 세번째 순으로 i+1번째의 최소 비용을 계산하면 된다.  주의할 점 당연히 메모리와 시간을 주의해야한다.     이전에 샀던 현황으로 이번에 살꺼를 정하는 과정에서 while문을 사용하여 하나씩 처리하면 시간초과고 한번에 계산하면 된다. O(N^2) -&gt; O(N)      small에서는 while문으로 해도 통과했는데 large는 n의 제한이 커지니 당연히 통과하지 않았따.      난 C가 B보다 클때를 고려하지 않아서 한번 틀렸다.      그냥 C가 B보다 크면 C를 B로 바꾸는 문장 하나 넣으니까 맞았다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;cassert&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  class purchase{ public:     //first = B로 산거 다음에 B+C로 업글     //second = B+C로 산거 다음에 B+2C로 업글     // third = B+2C로 산거.     int first= 0, second= 0, third=0;     ll res = 0; }; int n; ll B, C; vector&lt;int&gt; a;  int main(){     fast_io     cin &gt;&gt; n &gt;&gt; B &gt;&gt; C;     C = min(C, B);  //C가 B보다 크면 다 B롤 사는게 이득이잖아 ㅋㅋ     a = vector&lt;int&gt; (n+1);     for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i];     purchase myP[2];     for(int i=1;i&lt;=n;i++){         if (myP[0].first&amp;&amp;a[i]) {             int diff = min(myP[0].first, a[i]);             myP[1].second += diff;             myP[0].res -= 1LL*B*diff;             myP[1].res += (B+C)*diff;             a[i] -= diff;         }         if(myP[0].second&amp;&amp;a[i]) {             int diff = min(myP[0].second, a[i]);             myP[1].third += diff;             myP[0].res -= 1LL*(B+C)*diff;             myP[1].res += 1LL*(B+2*C)*diff;             a[i] -= diff;         }         if (a[i]) {             myP[1].first += a[i];             myP[1].res += 1LL*B*a[i];             a[i] = 0;         }         myP[1].res += myP[0].res;         myP[0] = {0, 0, 0, 0};         swap(myP[0],myP[1]);     }     cout &lt;&lt; myP[0].res; }"
  },
  
  {
    "title": "SCC",
    "url": "/posts/SCC/",
    "categories": "BOJ",
    "tags": "SCC, 그래프",
    "date": "2022-08-22 00:00:00 +0900",
    "content": "백준 4196번 도미노 문제풀이  [4196 도미노] https://www.acmicpc.net/problem/4196  .     SCC를 이용하여 서로 영향을 미치지 않는 것의 개수를 구해보자!  SCC를 배우니까 플레 문제들이 쓱삭 풀린다.       SCC구하는 알고리즘으로는 타잔 알고리즘, 코사라주 알고리즘이 대표적인데 나는 아직 코사라주밖에 다루지 못한다.      공부할라면 하는데 귀찮쓰.. ㅋㅋㅋㅋ        코사라주 알고리즘은 SCC구하고 위상정렬 순으로 되어있어서 개꿀이다.  문제상황 파악하기. 매우 직관적인 문제이다.       x, y가 주어지는데 x가 쓰러지면 y도 쓰러진다는 것이다.      방향그래프로 나타낼 수 있고, 방향그래프 하면 SCC가 떠오른다.         SCC 중에서 indegree가 0인, 즉 SCC의 시작점이라고 할 수 있는 것의 개수만 구하면 된다.  SCC가 뭐길래? Strongly Connected Component(강한 연결 요소)이다.     방향 그래프에서 사이클(cycle)이 있다면 그 사이클안에서는 맘껏 돌아 다닐 수 있다.       그 때 그 사이클 한 덩이를 SCC라고 한다.      즉, 모든 정점이 서로 이동 할 수 있는 상태 하나라는 것이다.  아이디어 얻기. 일단 SCC를 구하면 그 SCC들 사이에는 DAG(사이클이 없는 방향그래프)가 된다.      그러면 1번 SCC부터 dfs를 돌면서 dfs를 돌때마다 cnt해주면 답이된다.      1번부터 검사해도 되는 이유는 코사라주가 위상정렬 순으로 SCC를 내놓기 때문이다.  주의할 점 난 이거 메모리초과가 계속 나서 뭐지? 했는데 알고보니 DFS2함수에서 here에서 next로 가야하는데  here에서 here로 갔다 ….ㄷㄷ 시간 초과또는 틀렸습니다면 빨리 발견했을 것 같은데 메모리 초과라서 발견하는데 오래걸렸다.      오타는 항상조심하자 ㅠㅠ        테스트케이스마다 그래프를 잘 초기화 해주는 것말고는 주의 할 것이 별로 없다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;cassert&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const int MAX = 100001; int n, m; vector&lt;int&gt; G[MAX], R[MAX],DAG[MAX], C, order; vector&lt;bool&gt; visited;  void DFS1(int here){     C[here] = -1;     for(int next : G[here]){         if(!C[next]) DFS1(next);     }     order.push_back(here); }  void DFS2(int here, int color){     C[here] = color;     for(int next : R[here]){         if(C[next]==-1) DFS2(next, color);     } }  int SCC(){     C = vector&lt;int&gt; (n+1,0);     for(int i=1;i&lt;=n;i++) if(!C[i]) DFS1(i);     reverse(order.begin(), order.end());     int cnt = 0;     for(int i : order) if(C[i]==-1) DFS2(i, ++cnt);     return cnt; }  void dfs(int here){     visited[here] = true;     for(int next : DAG[here]){         if(!visited[next]){             dfs(next);         }     } }  int main(){     fast_io;     int tt; cin &gt;&gt; tt;     while (tt--) {         cin &gt;&gt; n &gt;&gt; m;         for(int i=0;i&lt;m;i++){             int u, v; cin &gt;&gt; u &gt;&gt; v;             G[u].push_back(v);             R[v].push_back(u);         }         int SCCcnt = SCC();         for(int i=1;i&lt;=n;i++){             for(int next : G[i]){                 if(C[i]==C[next]) continue;                 DAG[C[i]].push_back(C[next]);             }         }         int res = 0;         visited = vector&lt;bool&gt; (SCCcnt+1, false);         for(int i=1;i&lt;=SCCcnt;i++){             if(!visited[i]){                 dfs(i);                 res++;             }         }                      cout &lt;&lt; res &lt;&lt; '\\n';         for(int i=0;i&lt;MAX;i++){             G[i].clear();             R[i].clear();             DAG[i].clear();         }         order.clear();     } }"
  },
  
  {
    "title": "LCA",
    "url": "/posts/LCA/",
    "categories": "BOJ",
    "tags": "LCA, 그래프",
    "date": "2022-08-22 00:00:00 +0900",
    "content": "백준 3176번 도로 네트워크 문제풀이  [3176 도로 네트워크] https://www.acmicpc.net/problem/3176  .     LCA를 구하고 그 때 Sparse table을 이용해보자!  구간 최대, 최소를 구할 때 놀랍게도 전처리를 해두면 O(1)에 구할 수 있는 방법이 있다.       그것이 바로 sparse table이고 최대, 최소는 겹치는 구간이 있어도 상관없기 때문에 겹치는 구간 2개를 이용하는 것이다.  문제상황 파악하기. 도시와 도로가 트리형태로 주어져있고 한 도시에서 다른 도시로 가는 쿼리가 주어지면 경로 상의 가장 짧은 도로와 가장 긴 도로를 출력하면 된다.      K가 최대 10만이므로 최대 O(N(logN)^2))정도에 해결할 수 있다.      한 도시에서 다른 도시로 간다고 하면 둘의 최소 공통 조상을 무조건 지나기 때문에 LCA를 이용할 수 있다.  LCA가 뭐길래 lowest common ancester(최소 공통 조상)이다.     제일 가까운 부모라는 것이다.      구하는 방법은 간단하다. 만날 때까지 위로 올리면 된다.    u, v의 깊이가 다르면 깊은 것을 올린다.   깊이가 같아지면 u==v가 될때까지 동시에 올린다.   위 논리를 이용한 것이 아래 코드이다. int LCA(int u, int v){     if(depth[u]&lt;depth[v]) swap(u, v);       //u가 더 깊은거라고 하자     int diff = depth[u]-depth[v];     for(int i=0;i&lt;20;i++) if(diff&amp;(1&lt;&lt;i)) u = P[i][u];      //차이 만큼 올라간다.(1번 과정)     if(u==v) return u;     for(int i=19;i&gt;=0;i--) if(P[i][u]!=P[i][v]){        //같아질 떄까지 u, v를 동시에 옮긴다.               u = P[i][u];         v = P[i][v];     }     return P[0][u];     //같아진것을 리턴한다.       }   아이디어 얻기. 일단 두 정점사이 길이 하나밖에 없고 LCA는 무조건 지난다.      따라서 sparse table로 최대 최소를 미리 전처리 해두면 LCA를 구하는 과정에서 최대 최소를 구할 수 있을 것이다.        sparse table은 3개를 만들것이고 다음과 같이 정의한다.    P[j][i] : i번 정점에서 2^j 위의 조상   N[j][i] : i번 정점에서 2^j 위의 조상까지 갈 동안 최솟값   X[j][i] : i번 정점에서 2^j 위의 조상까지 갈 동안 최댓값   주의할 점 위의 코드로 LCA를 구하면 최종적으로 u, v가 같은 상태일때가 아니라 LCA바로 이전 정점들이 된다.     따라서 마지막에 리턴전에 최대, 최소를 한번 더 갱신해 줘야한다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;cassert&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const int INF = 987654321; const int MAX = 100001; int n, k; int P[20][MAX], N[20][MAX], X[20][MAX], depth[MAX]; vector&lt;pii&gt; adj[MAX];  void dfs(int here, int parent, int d){     depth[here] = d;     P[0][here] = parent;     for(pii next : adj[here]){         if(next.first==parent) continue;         N[0][next.first] = next.second;         X[0][next.first] = next.second;         dfs(next.first, here, d+1);     } }  pii LCA(int u, int v){     pii ret;     ret.first = INF;     ret.second = 0;     if(depth[u]&lt;depth[v]) swap(u, v);     int diff = depth[u]-depth[v];     for(int i=0;i&lt;20;i++) if(diff&amp;(1&lt;&lt;i)){  // 깊이를 맞추는 과정         ret.first = min(ret.first, N[i][u]);         ret.second = max(ret.second, X[i][u]);         u = P[i][u];     }              if(u==v){         return ret;     }     for(int i=19;i&gt;=0;i--) if(P[i][u]!=P[i][v]){    // 거슬러 올라가는 과정         ret.first = min(ret.first, N[i][u]);         ret.second = max(ret.second, X[i][u]);         u = P[i][u];         ret.first = min(ret.first, N[i][v]);         ret.second = max(ret.second, X[i][v]);         v = P[i][v];     }     //마지막에 갱신을 하고 리턴해야함     ret.first = min(ret.first, N[0][u]);     ret.second = max(ret.second, X[0][u]);     ret.first = min(ret.first, N[0][v]);     ret.second = max(ret.second, X[0][v]);     return ret; }  int main(){     fast_io     cin &gt;&gt; n;     for(int i=1;i&lt;n;i++){         int u, v, c;         cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;         adj[u].push_back({v, c});         adj[v].push_back({u, c});     }     dfs(1, 1, 1);          N[0][1] = INF;     for(int j=1;j&lt;20;j++){          //전처리 과정 O(NlogN)         for(int i=1;i&lt;=n;i++){             P[j][i] = P[j-1][P[j-1][i]];             N[j][i] = min(N[j-1][i], N[j-1][P[j-1][i]]);             X[j][i] = max(X[j-1][i], X[j-1][P[j-1][i]]);         }     }          cin &gt;&gt; k;     for(int i=0;i&lt;k;i++){       //O(KlogN)         int u, v; cin &gt;&gt;  u &gt;&gt; v;         pii res = LCA(u, v);         cout &lt;&lt; res.first &lt;&lt; ' ' &lt;&lt; res.second &lt;&lt; '\\n';     } }"
  },
  
  {
    "title": "2-SAT",
    "url": "/posts/2-SAT/",
    "categories": "BOJ",
    "tags": "2-SAT, SCC, 그래프",
    "date": "2022-08-22 00:00:00 +0900",
    "content": "백준 16367번 TV Show Game 문제풀이  [16367 TV Show Game] https://www.acmicpc.net/problem/16367  .     문제를 2-SAT문제로 변환해서 풀자!  2-SAT를 이용해서 여러 논리 관계들이 모순이 있는 지 없는지 알 수 있다.  문제상황 파악하기. 참가자들이 각각 3개의 추측을 낼 수 있고, 그 중 2개가 맞아야한다.     모든 사람들이 2개 이상 맞을 수 없다면 -1,  그럴 수 있다면 그렇게 만드는 전구 배치를 생각해내자!  2-SAT가 뭐길래? 2-Satisfiability로 충족가능성 문제이다.      2개의 항으로 이루어진 절 : (A+B) -&gt; 요건 부울대수      그 절들의 논리곱으로 이루어진 식의 해를 구할 수 있다.      예를 들면, (A+B)(C+~A)(~D+B)가 참이 가능하도록 만드는 값을 구할 수 있는 것이다.      이때 , (A+B)를 그래프의 간선으로 ~A -&gt; B, ~B -&gt; A로 나타낼 수 있다.     A가 거짓이면 B는 참이어야하고, B가 거짓이면 A는 참이어야하기 때문이다.      그래프의 SCC를 구해서 A와 ~A가 같은 SCC에 있다면 이것은 모순이다.      그리고 A가 위상정렬 상 앞에 있다면 A -&gt; ~A꼴이므로 ~A가 참이고,       위상정렬 상 뒤에 있다면 ~A -&gt; A꼴이므로 A가 참이다.  아이디어 얻기. 가장 중요한 아이디어는 3개중 2개 이상을 성공한다는 것은 아무거나 2개를 고르면 그 중 하나는 성공한다는 뜻이다.       이를 이용하여 참가자가 각각 고른 3개의 선택 중 2개를 고른것이 무조건 참이다를 해결하면 된다.     R이나 B중 하나를 참이라고 생각하고 해결해야하므로 그래프의 정점은 최대 10000개가 된다.  주의할 점 2-SAT문제를 풀 때 주의점은 정리를 잘해서 간선이 하나라도 이상하게 된것이 없는지 잘 봐야한다.     그리고 참과 거짓 둘다 나타낼 때 음수로 나타낼 수가 없어서 별도의 연산으로 공간을 만들어야하는데  그 때 OutOfBounds나 중복으로 접근하게 되는 것을 주의하자.      나는 모든 2-SAT문제를 풀때 1의 역은 1+k, 2의 역은 2+k 처럼 해결했다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;cassert&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const int MAX = 10001; int k, n; vector&lt;int&gt; G[MAX], R[MAX], C, order;  void DFS1(int here){     C[here] = -1;     for(int next : G[here]){         if(!C[next]) DFS1(next);     }     order.push_back(here); }  void DFS2(int here, int color){     C[here] = color;     for(int next : R[here]){         if(C[next]==-1) DFS2(next, color);     } }  void SCC(){     C = vector&lt;int&gt; (2*k+1, 0);     for(int i=1;i&lt;=2*k;i++) if(!C[i]) DFS1(i);     reverse(order.begin(), order.end());     int cnt = 0;     for(int i : order) if(C[i]==-1) DFS2(i, ++cnt); }  int main(){     fast_io;     cin &gt;&gt; k &gt;&gt; n;     int l[3]; char c[3];     int notl[3];     for(int i=0;i&lt;n;i++){         for(int j=0;j&lt;3;j++){             cin &gt;&gt; l[j] &gt;&gt; c[j];             notl[j] = l[j]+k;             if(c[j]=='R'){                 l[j] += k;                 notl[j] = l[j]-k;             }         }         // 0&amp;1         G[notl[0]].push_back(l[1]);         R[l[1]].push_back(notl[0]);         G[notl[1]].push_back(l[0]);         R[l[0]].push_back(notl[1]);         // 1&amp;2         G[notl[1]].push_back(l[2]);         R[l[2]].push_back(notl[1]);         G[notl[2]].push_back(l[1]);         R[l[1]].push_back(notl[2]);         // 0&amp;2         G[notl[0]].push_back(l[2]);         R[l[2]].push_back(notl[0]);         G[notl[2]].push_back(l[0]);         R[l[0]].push_back(notl[2]);     }     SCC();          bool ok = true;     for(int i=1;i&lt;=k;i++){         if(C[i]==C[i+k]) ok = false;     }          if(ok){         for(int i=1;i&lt;=k;i++){             if(C[i]&gt;C[i+k]) cout &lt;&lt; 'B';             else cout &lt;&lt; 'R';         }     }else cout &lt;&lt; -1; }"
  },
  
  {
    "title": "게임 리뷰 - 페르소나 5 더 로열",
    "url": "/posts/Persona-5/",
    "categories": "Game Review",
    "tags": "페르소나5, 게임리뷰",
    "date": "2022-08-07 00:00:00 +0900",
    "content": "ps5 게임 : 페르소나 5 더 로열 리뷰  개요 알고리즘 공부를 시작한지 6개월이 되어가고 블로그에도 글이 한 30개 정도 쌓였다.(굳굳)      해보고 싶은건 내 블로그도 꾸며보고 싶고, 앱도 개발해보고 싶고, 게임도 개발 해보고 싶고, 알고리즘도 많이많이 풀고 싶었지만….      실상은 알고리즘 한 문제에 끙끙대다가 한문제 풀고나면 에이 힘들다하고 플스나 붙잡았던게 대다수다.     그러다보니 게임하나 클리어했고 너무 재밌게 플레이해서 내 블로그에 삭막한 알고리즘문제만 있는 것보다 심심풀이로 읽어볼만한 글도 있으면 좋겠다 싶어서 게임리뷰를 남겨볼까 한다.  페르소나 5 더 로열    개발 및 유통      ATLUS        아틀러스 게임은 무거운 분위기가 많다고 한다. 페르소나5는 대체로 밝은 분위기지만 꽤나 진중한 이야기도 많이한다.     아틀러스 게임 다른것도 많이 해보고 싶었다.      Sega      아무래도 나는 세가의 개가 맞다.     저지아이즈 사신의 유언, 용과같이 7, 프로젝트 세카이 등 세가 덕분에 아싸의 삶의 질이 높아지긴했다.      하여간 일본애들 게임 진짜 잘만든다.   장르 및 플랫폼, 플레이타임            장르 : JRPG, 턴제 RPG     플랫폼 : 나는 PS5로 했다. 플레이타임 : 난이도 상 - 82시간 (근데 재밌어서 챌린지 난이도로 한번 더 할꺼임ㅋㅋ)           버전 정보       페르소나 3, 4와는 다른 별개의 내용이고, 페르소나5 스크램블의 스토리상 이전 작품이다.      페르소나5 본편의 내용을 전부 담았다고 생각하면 된다.      구매를 하려는 사람은 참고하시길~   달점  🌕 🌕 🌕 🌕 🌗 4.5 / 5       너무너무 만족해서 만점이나 다름이 없다.(0.5점은 혹시 몰라서 남겨놓는 습성이 있다)       마지막에 여운이 아주 조금 부족하다는 아쉬움은 남긴한다.   게임 플레이 방식       일상과 전투로 나뉘는데 일상은 사람들을 만나며 코옵(협력 포인트)을 올리거나 자신의 능력치를 강화할 수 있다.      전투는 메인 이벤트인 팰리스 공략과 메멘토스 노가다가 있고 팰리스는 하루 안에 클리에 해야 얻는 이득이 크다!      따라서 메멘토스 노가다를 좀 뛰다가 팰리스에 가는 것이 플레이에 정석? 같은 느낌이다.     게임의 주인공 이름과 괴도단 이름을 설정할 수 있는데 난 주인공이름을 전설의 한남충 괴도단 이름을 독도는 한국땅이라고 했다.(당연히 장난이다 ^^ 한국땅은 진심이고)          스토리 리뷰(스포가 가득함) 기본적인 스토리는 어느 날 비뚫어진 마음을 훔칠 수 있게된 주인공과 친구들이 낮에는 학교에서 성실한 활동을 밤에는 악인들의 마음을 훔치는 괴도단이 되어 세상을 구하는 내용이다.      처음 목적은 단지 악인들을 개심시키고 주변 사람들을 구하는 것이였다.      하지만 점점 말도 안되는 현실과 마주하고 신과 싸우게 된다.      옛날부터 나는 말도 안되는 싸움을 하는 내용을 좋아한다.     예를 들면 일제강점기에 정말 어렵고 힘든 싸움을 하는 독립 투사들, 모든 사람들이 미쳐있지만 자신 정상일 때 모두를 구하기 위한 싸움, 신이 나빠서 그 신과의 싸움 등등  이 게임에서의 싸움도 그렇다 너무나 강력한 존재, 포기할 수 있지만(실제로 포기하는 선택지도 있었음 ㅋㅋ) 포기하지 않고 싸우는 그런 스토리다.      근데 나 혼자서는 절대 이길 수 없다. 류지, 안 같은 친구들과 소지로, 사에 같은 조력자가 있었기 때문에 그런 무모한 싸움을 할 수 있었던 것이다.      약 60시간 동안 키워온 내 인연들이 알바다오트와의 전투에서 함께할 때 너무 멋있어서 눈물이 막 나왔다. ㅠㅠ       신념을 함께 지키는 친구가 있다는건 참 멋진 일이라고 느껴진다.      방구석에서 혼자 하는 히키 게임이 이런 메시지를 담는다는게 웃기긴한데 연대는 멋진 능력이긴 하다.     이 게임이 시사하는 바는 위에 말했듯이 연대와 강한 마음(정의, 신념)이라고 생각한다.      이를 녹여내는 게임 플레이와 스토리텔링이 일품이다…      특히 시민들이 괴도단을 응원하는 장면과 현실을 잃었던 괴도단이 주인공을 찾아오는 장면은 미쳤다.(울었다. ㅠㅠ)       현실의 문제도 많이 담았는데 각 에피소드 들이 긴밀하게 연결되어 있고 마지막 에피소드에서는 내 삶도 되돌아 볼 수 있었다.(진짜 괴도단이 있었다면 이랬을 것 같기도 했다)     정말 좋은 대사, 반전 등이 있지만 여기 담기엔 혹시모를 예비 플레이어를 방해하는 듯해서 스토리 리뷰를 마칠까 한다.    결론은 미친 스토리, 꿀잼.(씹덕맞음)  게임플레이 리뷰 스토리 리뷰에서 말했듯이 스토리를 플레이 안에 아주 잘 녹여냈다.       일상 플레이와 전투 플레이에 모두 메인 스토리를 잘 녹여냈고, 둘다 재미있었다.      아쉬웠던 점은 모든 사람과 코옵을 하는 것이 사실상 불가능하다.(1회차 플레이에서)      좋아하는 캐릭터의 코옵을 빨리 올리길 추천한다.       크리스마스, 발렌타인 등 여러 이벤트는 연인과 함께하니까 빨리 올려놓는게 좋다. ㅎㅎ      특히 난 마코토랑 하루를 좋아했는데 별로 못보고 끝나버렸다(하루의 비중이 넘 적다 ㅠㅠ)             마코토 배드엔딩은 보지말자..(가슴아프다..)      아 그리고 카스미는 코옵 올리기가… 거의 불가능하다 ㅋㅋ  상대적으로 인간력보다는 코옵이 중요한 느낌이라 그리고 할 일이 너무 많아서 여유롭게 놀러가거나, 메이드카페, 재즈카페, 당구, 낚시 등의 활동은 안하게 되는건 좀 아쉽다.      코옵을 스토리를 다 밀고 나서 올릴 수 있는 구조가 아니라서 할일을 좀 바쁘게 마쳐야하는 건 아쉽지만 게임 스토리 상 어쩔 수 없다.  BGM은 아주 훌륭했다. 일단 신나고 가슴이 웅장해지는 브금이 많다!  난이도는 상당히 높다고 생각한다. 나는 dlc로 90렙 페르소나가 처음부터 있어서 쉽게 전투를 깰 수 있었지만 아무것도 없는 상태라면 마나가 엄청 딸릴 것이다.       팰리스에 한번 입장하면 한번에 깨는게 유리하고 그러려면 그 동안 섀도들을 처리할 마나가 필요한데 항상 부족하다.      그러면 쉽게 깨기 위해 메멘토스 노가다를 해야하는데 거기서도 마나가 딸려서 쉽지는 않을 것이다. ㅋㅋㅋ  버그도 없었고, 자막도 훌륭했다.     ps5 입문 또는 페르소나 입문 하는 사람에게 강력추천하는 게임이다.  마무리 82시간이 아깝지 않은 게임이였고 더욱 더 나만의 게임을 만들어보고 싶어졌다!!      당분간은 나의 현실에 신경좀 써봐야겠다 ㅋㅋ 게임캐릭터 대사하나 던지며 마무리하겠다~  인간에겐 세계를 바꿀 힘이 있어. 지금은 아주 잠시 잊고 있을 뿐 - 모르가나"
  },
  
  {
    "title": "코드포스 - 3솔의 벽 깼다!",
    "url": "/posts/Codeforces-811,-812,codeTon/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2022-08-07 00:00:00 +0900",
    "content": "codeforce round #811(div 3), #812(div 2), CodeTon round 2 업솔빙  Codeforces Round #811, #812, #CodeTon 개요 너무 귀찮아서 3개를 한꺼번에 포스팅한다.     기술 블로그 쓰는 분들이 정말 대단하다.     공부하기도 바쁜데 기록까지… 최근 라운드들은 그래도 그린퍼포나 민트퍼포가 나왔다.     그래도 블루 퍼포는 안나오네 ㅠㅠ     코드톤(7월 31일), 811(8월 1일), 812(8월 6일)에 쳤고, 812에 드디어 div2 3솔을 처음해봤다. ㅎㅎ     물론 C가 그리 어렵진 않았지만 앞으로 잘할 수 있을거란 생각이 든다!!  CodeTon A. Two 0-1 Sequences(0:24) 꽤나 까다로웠다.    이 문제 풀다가 탈주할까 고민했다.     근데 조금만 관찰하니 뒤에 부분만 잘 비교해도 되겠다는 걸 알아차렸고 구현은 쉬워서 24분 걸렸다.  cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; a &gt;&gt; b; bool ok = false; for(int i=0;i&lt;=n-m;i++){     if(a[i]==b[0]) ok = true; } for(int i=1;i&lt;m;i++){     if(a[i+n-m]!=b[i]) ok = false; } if(ok) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\";   CodeTon B. Luke is a Foodie(0:42) 코드포스에 많이 나오는 유형 같았고 최근에 공부했던 큐나 덱을 이용하면 풀 수 있을 것 같았다.     그래서 최대값을 관리하는 덱, 최솟값을 관리하는 덱 두개를 만들어서 해결했다.     신촌 ICPC 하길 잘했다 ㅎㅎ ndq.clear(); xdq.clear(); cin &gt;&gt; n &gt;&gt; x; piles = vector&lt;int&gt; (n+1); int res = 0; for(int i=1;i&lt;=n;i++) cin &gt;&gt; piles[i]; for(int i=1;i&lt;=n;i++){                 while (!ndq.empty()&amp;&amp;ndq.back()&gt;=piles[i]) {         ndq.pop_back();     }     ndq.push_back(piles[i]);     while (!xdq.empty()&amp;&amp;xdq.back()&lt;=piles[i]) {         xdq.pop_back();     }     xdq.push_back(piles[i]);                 if(xdq.front()-ndq.front()&gt;2*x){         res++;         while (ndq.size()&gt;1) ndq.pop_front();         while (xdq.size()&gt;1) xdq.pop_front();     }             } cout &lt;&lt; res &lt;&lt; '\\n';   CodeTon C. Virus(upsolving) 솔직히 이 문제는 풀 수 있을 줄 알았다.     관찰을 제대로 했고 집 사이 차이가 큰 쪽부터 막아야겠다는 생각은 바로했다.     근데 계속 구현을 못했다.ㅠㅠ     에디토리얼 봐도 아이디어는 똑같은데 참 아쉽다.    푸신분들을 살펴보니 전체에서 안걸린 집을 빼는 식으로 하셨다.    난 처음에 걸린집을 직접 구하려니까 힘들었다. cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;i++) cin &gt;&gt; arr[i]; sort(arr+1, arr+1+m); for(int i=1;i&lt;m;i++) d[i] = arr[i+1]-arr[i]-1; d[m] = arr[1]+n-1-arr[m]; sort(d+1, d+1+m); int res = 0; for(int i=m;i&gt;0;i--){     if(d[i]-4*(m-i)==1) res++;     else res += max(0, d[i]-4*(m-i)-1); } cout &lt;&lt; n-res &lt;&lt; '\\n';   CodeTon D. Magical Array(upsolving) 코포에 많이 나오는 스타일 같아서 공부겸 업솔빙한다.     작업 1 : i, j골라서 1빼고 그 전에 꺼에 1 더함(평범한 배열에 쓰임)        작업 2 : i, j골라서 1빼고 i 전에꺼 j+2에 1 더함(특별한 배열에 쓰임)      c1, c2, c3배열이 주어졌을 때 특별한 배열이 뭐인지 맞추고 작업 2가 어디서 쓰였는지 맞춰라     역추적하는 문제는 항상 어렵다….     사고의 흐름이 조금 다른것 같아서 이다.      근데 이 문제는 그것과는 별개로 좀 수학적인 문제라 어려웠다.      연산을 해보면 작업 1을 하면 Aii가 남는다.     작업 2를 하면 sigma(Aii)+1이다. 따라서 sigma(Ai*i)를 구해서 답을 낼 수 있다.     정말 어려웠다…. cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++){     a[i] = 0;     for(int j=1;j&lt;=m;j++){         ll k; cin &gt;&gt; k;         a[i] += j*k;     }     b[i] = {a[i], i}; } sort(b+1, b+n+1); cout &lt;&lt; b[n].second &lt;&lt; ' ' &lt;&lt; b[n].first-b[1].first &lt;&lt; '\\n';   811 A. Everyone Loves to Sleep(0:23) 꽤 오래 걸린 문제 시계 문제였는데… 좀 헤맸다.. 연습좀 해야지 ㅋㅋ  811 B. Remove Prefix(0:34) 코드포스에서 많이 본 듯했고 너무 쉬웠다.     A보다 쉬웠던 것 같다.    나는 맵으로 마지막 인덱스를 관리했고 마지막 인덱스만 출력하면 끝이다.  811 C. Minimum Varied Number(1:05) 증명이 쉽지 않아서 꽤 오래걸렸다..  먼가 큰 수 부터 넣으면 수가 짧아지니까 될 것같았다.    그래서 넣어보니까 틀렸다?? 근데 생각해보니 젤 작은 수니까 뒤집어야하는데 안뒤집었다 ㅋㅋㅋㅋ      그래서 reverse 해주니까 바로 AC  803 D. Color with Occurrences(upsolving) 업솔빙도 실패함 담에 풀어보겠슴 ㅠㅋㅋ  811 E. Add modulo 10(2:05) D같은 문제는 항상 못풀었어서(코포에 많이나오는데도 못풂ㅋㅋ)     E로 도망왔는데 더 할만해 보여서 잡았다.     실제로도 E가 푼사람이 더 많았음 ㅋㅋ      써보니까 규칙성이 20기점으로 계속 바뀌는 게 보였고 나는 이를 다루기 위해  10의 자리와 일의 자리를 생각했다.    10의 자리가 2로 나눠지면 어쩌구~ 그에 따른 일의 자리가 어쩌구~ 근데 푼 사람들 보니 그냥 %20을 했다…또르륵..ㅠㅠ     나는 분리집합까지 다뤄서 분리했는데 그냥 %20해서 케이스워크 하면 끝…  812 A. Traveling Salesman Problem(0:06) 처음에 초기화를 0, 0으로 해주는 거빼고 딱히 주의 할 것도 없는 문제.  812 B. Optimal Reduction(0:28) 문제를 조금 관찰해보니 쭉 증가하거나 쭉 감소, 그리고 증가하다가 감소하는 경우 가능하다.    근데 나는 감소하다가 증가하는 것도 했다가 2번 틀렸다.     조금 더 신중하고 정확했어야했는데 성급했다.         이거 사실 10분컷했으면 많이 올랐을텐데 아쉽다.  812 C. Minimum Varied Number(1:11) 드디어 3솔을 해내서 너무 기쁘다 ㅠㅠ      근데 생각보다 쉽긴했다.(30분만에 풀었음 ㅋㅋ B랑 비슷..)      증명은 제대로 못했지만 이 문제도 811의 C와 비슷하게 큰것부터 처리하면 될 것같다는 관찰이 있었다.     실제로 예제를 보면 큰 제곱수가 뒤에 쭉있다.     큰 제곱수부터 처리하기 위해 스택을 이용했다~ vector&lt;bool&gt; used(n, false); int biga = 0; stack&lt;int&gt; s; s.push(0); while (biga*biga&lt;n){     biga++;     s.push(biga); } vector&lt;int&gt; ans; bool ok = true; for(int i=n-1;i&gt;=0;i--){     if(s.empty()){         ok = false;         break;     }     int usenum = s.top()*s.top()-i;     while (usenum&gt;=n||(!s.empty()&amp;&amp;usenum&gt;0&amp;&amp;used[usenum])) {         s.pop();         usenum = s.top()*s.top()-i;     }     if(usenum&lt;0){         ok =false;         break;     }     used[usenum] = true;     ans.push_back(usenum); } if(ok){     for(int i=ans.size()-1;i&gt;=0;i--){         cout &lt;&lt; ans[i] &lt;&lt; ' ';     }     cout &lt;&lt; '\\n'; }else cout &lt;&lt; -1 &lt;&lt; '\\n';   812 D. Tournament Coundown(upsolving) 인터랙티브는 아직도 뭐하라는지 잘 모르겠다..      문제는 이해했지만 뭔가 막막해서 계속해맸다.     이런건 대체로 이분탐색인데…하다가 그냥 포기했다~ ㅋㅋ      답을 보니 꽤 어려웠다… 일단 4명씩 보면서 판단한다.    1번 3번이 비겼으면 그 둘은 우승자가 아니다.   1번이 3번보다 더 이겼으면 2번과 3번은 우승자가 아니다.   1번보다 3번이 더 이겼으면 1번과 4번은 우승자가 아니다.   라는 관찰이 필요하다. 그리고 여까진 충분히 초딩도 생각할만하다(근데 난못함 ㅋㅋ)      그리고 이를 위해서 그냥 4개씩 모아서 ask하면 된다.      그리고 승자들끼리 또 해준다. 그러면 4명에서 1명으로 후보가 계속 줄어들어서 금방한다.      근데 인터랙티브 문제의 어러움은 디버깅이 어렵다는 것이다.     디버깅을 어떻게 해야하는지 모르겠다~"
  },
  
  {
    "title": "Hashing",
    "url": "/posts/Hash/",
    "categories": "BOJ",
    "tags": "Hashing, 해시",
    "date": "2022-08-07 00:00:00 +0900",
    "content": "백준 21162번 뒤집기 K 문제풀이  [21162 뒤집기 K] https://www.acmicpc.net/problem/21162  .     해시를 이용해 접두어가 같은 부분을 빠르게 찾아내자!  신촌 ICPC 알고리즘 캠프를 이번 방학에 신청했다.     강사님이 필수과제로 내준 문제이고 솔직히 풀이를 안들었으면 못풀었을 것같다.     jhnah917님이 만드신 문제이고 풀이도 거의 비슷하게 따라 풀었다.     좋은 문제같아서 배운 내용을 정리할겸 포스팅해보려고 한다.  문제상황 파악하기. 뒤집어서 생기는 배열은 총 n-1개가 생긴다.(0~1사이, 1~2사이 …. n-2~n-1사이)       그렇다면 직접 배열을 만들면 최대 200000*200000의 공간이 필요해서 메모리가 부족할 것이다.     배열을 하나하나 만들지 않고 배열을 표현해야한다.     여기서는 cyclic shift 형태를 이용하여 거꾸로 된 배열을 2개 붙여서 이를 해결했다.    그리고 나서는 2개 이어붙여서 생긴 그 배열을 이용하여 거기서 제일 사전순으로 작은걸 찾아야한다.  해시 구현 코드는 대부분 jhnah917님이 구현하신 것을 참고했다.      누적합느낌으로 해시를 만든다.    그리고 사이의 해시값을 구할 때는 그 전의 것부터 빼야하니까 1부터 구현하는게 편하다. const int MOD = 1000000007; template&lt;ll P, ll M&gt; struct Hashing{     vector&lt;ll&gt; H, B;     void build(const vector&lt;ll&gt; &amp;S){         H.resize(S.size()+1);         B.resize(S.size()+1);         B[0] = 1;         for(int i=1;i&lt;=S.size();i++){             H[i] = (H[i-1]*P+S[i])%M; //누적합 느낌으로         }         for(int i=1;i&lt;=S.size();i++){             B[i] = (B[i-1]*P)%M;         }     }     ll get(int s, int e){         ll res= (H[e]-H[s-1]*B[e-s+1])%M;         return res &gt;= 0 ? res : res+M;     } };   아이디어 얻기. 거꾸로 된 배열을 붙여서 만들 배열을 보면 1~n이 시작점인 부분만 보면된다.      그러면 어느 시작점이 사전순으로 젤 작은지를 판단해야하고 문제는 K번째를 구하는 것이므로 정렬을 해야한다.     정렬하는데에는 NlogN만큼 걸리니까 이 문제를 시간안에 해결하려면 사전순으로 더 작은지 판단하는 과정을 logN만에 해야한다.      여기서 이분탐색의 아이디어를 떠올릴 수 있다.    그리고 이분 탐색 과정에서 prefix를 비교하는데 이도 오래걸리면 안된다.     따라서 해시를 이용하여 미리 배열의 해시 값들을 저장해두고 해시 값이 달라지는 시작점을 찾아서 비교를 해야한다.  주의할 점 해시를 할때 너무 작은 M으로 나누면 안된다.    해시 충돌이 일어나기 때문이다.(해시충돌 확률은 1/M) 나는 적당히 큰 소수 P를 616327, M을 1000000007로 설정했다.      이분 탐색과정에서 Off-by-One error를 조심하자..     나는 저것때문에 2시간 가까이 고전했다…ㅠㅠ     이분탐색은 넘 어렵다.~~~  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;cassert&gt; #define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  const int MOD = 1000000007; template&lt;ll P, ll M&gt; struct Hashing{     vector&lt;ll&gt; H, B;     void build(const vector&lt;ll&gt; &amp;S){         H.resize(S.size()+1);         B.resize(S.size()+1);         B[0] = 1;         for(int i=1;i&lt;=S.size();i++){             H[i] = (H[i-1]*P+S[i])%M; //누적합 느낌으로         }         for(int i=1;i&lt;=S.size();i++){             B[i] = (B[i-1]*P)%M;         }     }     ll get(int s, int e){         ll res= (H[e]-H[s-1]*B[e-s+1])%M;         return res &gt;= 0 ? res : res+M;     } };  Hashing&lt;616327, MOD&gt; ht; int n, k; vector&lt;ll&gt; arr;  bool compare(int n1, int n2){   //접두어가 처음으로 다른 부분 이분탐색으로 찾기     int l = -1 , r = n-1;     while (l+1&lt;r) {         int mid = (l+r)&gt;&gt;1;         int v1 = ht.get(n1, n1+mid);         int v2 = ht.get(n2, n2+mid);         if(v1==v2) l = mid;         else r = mid;     }     if(l==n-1) return false;    //모두다 같음     return arr[n1+r] &lt; arr[n2+r];   //처음으로 다른부분 비교 }  int main(){     fast_io;     cin &gt;&gt; n &gt;&gt; k;     arr = vector&lt;ll&gt; (n);     for(int i=0;i&lt;n;i++) cin &gt;&gt; arr[i];     reverse(arr.begin(), arr.end());     for(int i=0;i&lt;n;i++) arr.push_back(arr[i]); //거꾸로 된거 2개 이어붙임          ht.build(arr);     vector&lt;int&gt; idxs(n-1);     for(int i=0;i&lt;n-1;i++) idxs[i]= i+1;    // i번째 부터 n-1개     // compare(2, 6);     stable_sort(idxs.begin(), idxs.end(), compare);     for(int i=0;i&lt;n;i++){         cout &lt;&lt; arr[idxs[k-1]+i] &lt;&lt; ' ' ;     } }"
  },
  
  {
    "title": "코드포스 - 업솔빙 몰아서 함",
    "url": "/posts/Codeforces-808/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2022-07-17 00:00:00 +0900",
    "content": "codeforce round #808(div 2), #803(div 2, virtual) 업솔빙  Codeforces Round #808, #803 개요 일단 지금 808 보고 난 직후 이고 역시나 2솔ㅠㅠ    c, d만 몰아서 업솔빙 해볼 것이다. 이번 808은 너무 힘들었다.     A가 잟안 풀려서 B를 해야하나 A를 해야하나 고민도 많이 됐고, 낼 때마다 WA를 받아서 내 멘탈도 Wa르르였다.     다행이 1시간 넘긴했지만 풀어서 다행이지 안그랬으면 100점이상 떨굴뻔했다. ㅠㅠ      원래 809를 진행하고 몰아서 할라고 했지만.. 건강검진 이슈로 809를 못봐서 버추얼로 803을 해보았다.    허나 의지가 박약하여 A, B 풀고 C풀다가 안되니깐 걍 포기했다 ㅋㅋㅋ     단식 중이라 배고파서 집중이 안된다(핑계임)  808 A. Difference Operations(1:25) B보다도 늦게 풀었따. ㅋㅋㅋ     진짜 멘탈이 중요하단 걸 느꼈다.    A를 못풀면 다른게 안잡힌다.     600점 짜리를 맞았는데 150점이 오르는 기적같은 일이 일어났다. ㅋㅋㅋ     처음에는 인접한 배열을 뺀 값을 저장해서 관리했는데 그게 답이 없었나보다.     1시간 뒤에 그냥 배열 자체를 조작해보니 첫번째 배열요소만 중요하단걸 알았다. int n; cin &gt;&gt; n; arr  = vector&lt;ll&gt; (n+1); bool ok = true; for(int i=1;i&lt;=n;i++){     cin &gt;&gt; arr[i];     if(i!=1&amp;&amp;!arr[i-1]&amp;&amp;arr[i]) ok = false;     if(arr[i-1]&gt;0&amp;&amp;arr[i]%arr[i-1]) ok = false;     if(arr[i-1]) arr[i] = arr[i-1]; } if(ok) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\";   808 B. Difference of GCDs(1:18) 이건 직관은 빨리 얻었는데 구현하다가 잔실수가 너무 많았다.     배수인것만 확인하면 되는데 이상한 gcd를 구했다.(제목에 낚인건가..?)     머리와 손이 따로 논것이다.     그래도 이문제를 AC받으면서 멘탈이 조금 회복된듯 하다. bool ok = true; for(int i=1;i&lt;=n;i++){     int a = (l/i);     int b = a*i;     while(b&lt;l) b+=i;     if(b&gt;r){         ok = false;         break;     }     res.push_back(b); }   808 C. Doremy’s IQ(upsolving) A, B를 푸니 30분남았었고 이건 아이디어라도 떠올려보자 하고 열심히 봤다.     규칙은 참 쉬운데.. 정렬로 일단 접근했다.    공짜로 참여할 수 있는건 대부분 참여하는게 이득이니까 대충 정렬 후 그리디 아닐까? 한것이다.    얼마전에 #805 에서 풀었던 good key, bad key문제랑 은근히 비슷해 보였기 때문이다.     결론은 뒤에서 부터 그리디하게 해결이 가능하다.    iq가 0인것부터 거꾸로 거슬로 올라가는 것이다… 아 그리디는 어렵고 재밌다. int n, iq; cin &gt;&gt; n &gt;&gt; iq; for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i]; int Q= 0; for(int i=n;i&gt;=1;i--){     if(a[i]&lt;=Q) res[i] = 1;     else if(Q&lt;iq){         Q++;         res[i] = 1;     }else res[i] = 0; } for(int i=1;i&lt;=n;i++) cout &lt;&lt; res[i]; cout &lt;&lt; '\\n';   808 D. Difference Array(upsolving) 문제 그대로 구현한다고 하면 인접한거 다 빼고(N)* 정렬하고(NlogN) * 그걸 N번 반복하니까  N^3logN의 시간복잡도가 걸릴것이고 이는 당연히 시간 초과다.      모든 구간을 정렬하는게 아니라 일부분만 정렬해서 한번의 연산에 끝내는게 중요하다. for(int i=1; i&lt;=n;i++) cin &gt;&gt; arr[i]; for(int i=n-1;i&gt;=1;i--){     int last = arr[i+1];     bool ok = false;     for(int j=i;j&gt;=1;j--){         if(arr[j]==0) ok = true;         arr[j] = last-arr[j];         last -= arr[j];         if(ok){             sort(arr+j, arr+i+1);             break;         }     }     if(!ok) sort(arr+1, arr+i+1); } cout &lt;&lt; arr[1]&lt;&lt;'\\n';   803 A. XOR Mixup(0:04) XOR 연산은 재밌다.    내가 좋아하는 문제고 전체 다 XOR한거에 하나씩 XOR하면서 비교하면 끝.    모든 문제에 XOR연산만 나오면 좋겠다.  803 B. Rising Sand(0:22) 꽤 오래걸린 문제이다.     10분 넘게 생각하고 나서야 k가 1이 아니라면 연산을 통해 결과를 바꿀 수 없다는 걸 알아냈다.    따라서 k=1인 경우만 예외처리하면 된다.  cin &gt;&gt; n &gt;&gt; k; sands = vector&lt;int&gt; (n+1); for(int i=1;i&lt;=n;i++) cin &gt;&gt; sands[i]; int res = 0; for(int i=2;i&lt;=n-1;i++){     if(sands[i]&gt;sands[i-1]+sands[i+1]) res++; }          if(k==1){     cout &lt;&lt; (n-1)/2 &lt;&lt; '\\n'; }else{     cout &lt;&lt; res &lt;&lt; '\\n'; }   803 C. 3SUM closure(upsolving) 모든 경우를 검사하기는 당연히 무리고 계속 해보니 양수인게 3개가 넘어가면 절대 안된다.     왜냐면 그것만으로 계속해서 새로운 뭔가가 생기니까 문제가된다.    여기까진 알아냈는데.. 그래서 어쩌지 하다가 버추얼이라서 생각하기가 귀찮아져서 걍 플스하러 갔다.ㅠㅠ     에디토리얼 보니까 생각은 맞았더라 근데 여기서 범위를 줄여서 브루트포스를 했다.     난 뭔가 딱 떨어지는 문제들만 많이 풀어서 그런지 이런식으로 범위를 줄여서 검사하는 생각을 잘 못하는것같다.     음수 최대 2개 양수 최대 2개 0도 최대 2개로 6개를 모두 검사하면 된다 해봐야 6의 3승이다. int n, iq; cin &gt;&gt; n &gt;&gt; iq; for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i]; int Q= 0; for(int i=n;i&gt;=1;i--){     if(a[i]&lt;=Q) res[i] = 1;     else if(Q&lt;iq){         Q++;         res[i] = 1;     }else res[i] = 0; } for(int i=1;i&lt;=n;i++) cout &lt;&lt; res[i]; cout &lt;&lt; '\\n';   803 D. Fixed Point Guessing(upsolving) 코드포스를 할거라면 interactive문제는 알아둬야할 것 같다.       이건 그냥 어떻게 해야할 지 몰라서 답을 봤다.      interactive문제는 그냥 믿고 입력을 받으면 되는 구나 싶었다.      assert문의 필요성도 배웠다.      대충 문제는 이해했는데 idleness limit error가 떠서 빡쳐서 접었다."
  },
  
  {
    "title": "코드포스 - 또 3솔의 벽",
    "url": "/posts/Codeforces-807/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2022-07-16 00:00:00 +0900",
    "content": "codeforce round #807(div 2) 업솔빙  Codeforces Round #807 개요 하… 진짜 미칠 것 같다 이번엔 A, B를 20분 만에 풀어서 2시간동안 한 문제만 풀어도 3솔의 벽을 깨는 건데…     그걸 못했다. 2시간동안 C,D하나 풀기를…ㅠㅠ      이쯤 되면 이번 방학 목표를 코드포스 3솔로 바꿔야 할 것 같다.(원래 블루였음ㅋㅋ)     내 생각보다 블루, 퍼플이 엄청 대단한 사람들이란걸 몸소 느낀다.  A. Mark the Photographer(0:05) 정렬하고 반 나눠서 연산하면 바로 끝이다.    근데 n이 주어지고 n/2가 주어지는게 아니라 이미 절반을 한 값을 준다는 특징이 있었다.    그래서 좀 어버버하다가 5분에 AC int n, x; cin &gt;&gt; n &gt;&gt; x; vector&lt;int&gt; height(2*n+1); for(int i=1;i&lt;=2*n;i++) cin &gt;&gt; height[i]; sort(height.begin(), height.end()); bool possible = true; for(int i=1;i&lt;=n;i++){     if(height[i+n]-height[i]&lt;x) possible = false; } if(possible) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\";   B. Mark the Dust Sweeper(0:18) 이 문제까진 꽤 느낌이 좋았다.    왜냐면 내가봐도 좀 잘풀었기 때문이다.    먼지를 뒤로 모는 문제고 0이 중간에 껴있는경우 턴을 좀 더 써야한다.   그래서 스위핑으로 끝점 빼고 먼지+추가적인 턴을 더해서 단 3줄로 끝냈다.  int n; cin &gt;&gt;n; rooms = vector&lt;ll&gt; (n+1); ll res = 0; for(int i=1;i&lt;=n;i++){     cin &gt;&gt; rooms[i];     if(i!=n) res += rooms[i];     if(!rooms[i]&amp;&amp;res&amp;&amp;i!=n) res++; } cout &lt;&lt; res &lt;&lt; '\\n';   C. Mark and His Unfinished Essay(upsolving) 마크한테 실망했다. substr문제인가 하고 보니 쿼리의 범위가 long long형까지 갔다..     당연히 메모리 초과 날걸 알았지만 해봤고 역시 메모리 초과가 났다.     그렇다면 연산으로 역추적? 을 해야하는데 그게 생각이 1도 안났다.    string이 계속 바뀌는데 어케 역추적을 해야하지..라는 생각을 하다가 시간 다쓰고 망했다.    첫 글자랑 위치만 저장해볼까 했는데 그게 string이 바뀌니깐 너무 곤란했다. ㅠㅠ    에디토리얼 보니 비슷하다..다만 왼쪽 오른쪽 복사된 idx만 저장하는게 아니라 diff라는 이름의 배열로 왼쪽 시작점-왼쪽 쿼리시작점을 뺀것을 저장한다.    이것의 의미는 바로 이전 시작점인것이다.    왜 이걸 못했을까…?    솔직히 좀 좋은 문제였다. for(int i=0;i&lt;q;i++){     ll k; cin &gt;&gt; k;     k--;     for(ll j=c;j&gt;=1;j--){         if(k&lt;left[j]) continue;         k -= diff[j];     }     cout &lt;&lt; str[k] &lt;&lt; '\\n'; }   D. Mark and Lightbulbs(upsolving) C보다 이게 더 나을 것 같아서 꽤 오래 본 문제이지만 어..이건가?? 하는데 반례가 계속 나왔다 ㅠㅠ       일단 하나의 전구를 바꿀 수 있어서 그걸 바꾸면 그 양옆의 상태가 변한다는 특징이 있었다.    모든 상태를 변화시킬 수 없을 때   양 끝은 어짜피 바꿀 수 없는데 양끝이 다를 때  이 두 경우가 -1을 출력하는 경우라고 생각하고 문제를 풀었다.     핵심은 구간을 한칸씩 옮길 수 있다는 것이고 이를 계산 할 때            abs(l-l’)+abs(r-r’)           이런 식으로 계산 할 수 있다는 것이다. ll n, c,q; int main(){     fast_io;     int test; cin &gt;&gt; test;     while (test--) {         int n; cin &gt;&gt; n;         string s1, s2;         cin &gt;&gt; s1 &gt;&gt; s2;         bool ok = true;         if(s1[0]!=s2[0]||s1[n-1]!=s2[n-1]) ok = false;         vector&lt;int&gt; pos1, pos2;         for(int i=0;i&lt;n-1;i++){             if(s1[i]!=s1[i+1]) pos1.push_back(i);             if(s2[i]!=s2[i+1]) pos2.push_back(i);         }         if(pos1.size()!=pos2.size()) ok = false;                  if(ok){             ll res = 0;             for(int i=0;i&lt;pos1.size();i++){                 res += abs(pos1[i]-pos2[i]);             }             cout &lt;&lt; res &lt;&lt; '\\n';         }else{             cout &lt;&lt; -1 &lt;&lt; '\\n';         }     } }"
  },
  
  {
    "title": "Segment Tree 응용",
    "url": "/posts/Segment-Tree3/",
    "categories": "BOJ",
    "tags": "DnC, 분할정복, 세그먼트트리",
    "date": "2022-07-16 00:00:00 +0900",
    "content": "백준 10167번 금광 문제풀이  [10167 금광] https://www.acmicpc.net/problem/10167  .     세그먼트트리 대표 다이아 금광을 풀어보자!      연속합과 쿼리      위 문제를 풀고 나니 금광도 풀 수 있다고 해서 호다닥 달려왔다.     근데 뭐가 풀 수 있다는 건지 짱짱 어려웠다.     좌표압축도 같은 값 처리 어떡하지? 이러다가 이상하게 짜고 세그트리를 어떻게 해야하지 하면서 얼탔다.     이 문제가 워낙 유명해서 다른 블로그에 정리가 잘 되어있어서 다행이다.     역시 사람들은 대단하다.  문제상황 파악하기. 연속합과 쿼리를 풀어봤다면 연속하는 최대 합을 구하는 테크닉을 배웠을 것이다.(분할 정복느낌으로다가)     그렇다면 금광문제도 그 문제처럼 치환해야하고 그렇다면 좌표간의 관계. 즉 정렬이 필요하다.    하지만 좌표값이 최대 10억까지 가니까 이를 다 커버하기에는 메모리가 부족하다.    따라서 좌표 압축을 통해 처리해야한다.    좌표압축은 여러 블로그에 좋은 테크닉이 있어서 참고했다.(좌표압축이라고 치면 많이 나온다)  아이디어 얻기. 좌표 압축 까지 했다면 어떤식으로 자료들을 관리 할지 보자!     먼저 나는 Mine(광산)클래스를 다음과 같이 만들었다/ class Mine{ public:     int x, y;     ll value;          bool operator &lt; (const Mine &amp;m)const{         if(this-&gt;y != m.y) return this-&gt;y &lt; m.y;         else return this-&gt;x&lt;m.x;     } };  연산자 오버로딩은 y값을 기준으로 정렬하도록 만들었다.     이는 x값으로 해도 되지만 y값이 위에서 부터 내려오는 모습(2차원 배열을 기준으로 본것이다.)이 우리의 직관에 더 부합한다.     좌표압축까지 완료 했다면 이제 모든 점을 기준으로 검사해야하는데 작은 점부터 내려가면서 검사한다.    그러니 자신보다 y값이 작은 건 다시 안봐도 된다.    y값을 기준으로 검사하며 x좌표기준 세그트리에 값을 넣으면 된다.     이 때 주의 해야할 점은 y값이 같은 점을 검사 할때 앞에것, 뒤에것 따로 하는게 아니라 한번에 넣어놓고 검사해야한다.     당연하다 네모를 그리면 같이 들어가니까 말이다.     트리는 다음과 같은 Data class를 이용했다. class Data{ public:     ll lmax, rmax, fmax, tmax; };   주의할 점 y값이 같으면 같이 검사해야하는데 나는 갑자기 x값하고 헷갈렸다.     x도 같이 검사 해야하는거 아니야? 했는데 아니다.    조금만 그려보면 알 수 있다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #define fast_io cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll;  int n; class Mine{ public:     int x, y;     ll value;          bool operator &lt; (const Mine &amp;m)const{         if(this-&gt;y != m.y) return this-&gt;y &lt; m.y;         else return this-&gt;x&lt;m.x;     } };  class Data{ public:     ll lmax, rmax, fmax, tmax; };  vector&lt;Mine&gt; mines; vector&lt;Data&gt; tree; vector&lt;int&gt; xcoord; vector&lt;int&gt; ycoord;  void compress(){    //좌표 압축함     sort(xcoord.begin(), xcoord.end());     xcoord.erase(unique(xcoord.begin(), xcoord.end()), xcoord.end());     sort(ycoord.begin(), ycoord.end());     ycoord.erase(unique(ycoord.begin(), ycoord.end()), ycoord.end());     for(int i=1;i&lt;=n;i++){         mines[i].x = (int)(lower_bound(xcoord.begin(), xcoord.end(), mines[i].x)-xcoord.begin())+1;         mines[i].y = (int)(lower_bound(ycoord.begin(), ycoord.end(), mines[i].y)-ycoord.begin())+1;     }     sort(++mines.begin(), mines.end()); }  Data update(int x, ll v, int node, int S, int E){     if(x&lt;S||x&gt;E) return tree[node];     if(S==E){         tree[node].lmax += v;         tree[node].rmax += v;         tree[node].fmax += v;         tree[node].tmax += v;         return tree[node];     }     int mid = (S+E)&gt;&gt;1;     Data left = update(x, v, 2*node, S, mid);     Data right = update(x, v, 2*node+1, mid+1, E);     Data &amp;ret = tree[node];     ret.fmax = left.fmax+right.fmax;     ret.lmax = max(left.lmax, left.fmax+right.lmax);     ret.rmax = max(right.rmax, right.fmax+left.rmax);     ret.tmax = max({left.tmax, right.tmax, left.rmax+right.lmax});     return ret; }  int main(){     fast_io;     cin &gt;&gt; n;     mines = vector&lt;Mine&gt; (n+1);     xcoord = vector&lt;int&gt; (n);     ycoord = vector&lt;int&gt; (n);     for(int i=1;i&lt;=n;i++){         cin &gt;&gt; mines[i].x &gt;&gt; mines[i].y &gt;&gt; mines[i].value;         xcoord[i-1] = mines[i].x;         ycoord[i-1] = mines[i].y;     }     compress();  //좌표 압축     ll res = 0;     for(int i=1;i&lt;=n;i++){         if(mines[i].y==mines[i-1].y) continue;  //y값이 동일하면 뒤에거만 검사한다. 왜냐면 밑에서 처리 하는걸보면안다.         tree = vector&lt;Data&gt; (4*n+1, {0,0,0,0});   //0이상임 최대값은         for(int j=i;j&lt;=n;j++){             int hx = mines[j].x; ll hv = mines[j].value;             update(hx, hv, 1, 1, n);             // y값이 동일한것은 업데이트를 다 해놓고 마지막만 연산한다.             // 왜냐면 다 같이 네모 안으로 들어가니까             if(j==n||mines[j].y!=mines[j+1].y) res = max(res, tree[1].tmax);         }     }     cout &lt;&lt; res; }"
  },
  
  {
    "title": "코드포스 - 익숙해지는 중",
    "url": "/posts/Codeforces-805-806/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2022-07-15 00:00:00 +0900",
    "content": "codeforce round #805(div 3), #806(div 4) 업솔빙  Codeforces Round #805, #806 개요 +97점, -10점 했다.    그래도 긍정적인 부분은 이제 코포 유형이 뭔지 감이 잡히고 있다.     코포는 코포로 공부하는게 맞는것같다.     그래도 버추얼은 귀찮아서 안하지만 ㅋㅋㅋ       div 4는 다 풀어야하는데 정말 슬프다.. 빨리 더 수련을 해야겠다.      div 3, div 4 둘다 4솔했고 틀린 문제만 업솔빙 해보려고 한다.  805 E. Split into Two Sets 이때 당시 멀티셋에 빠져있던터라 멀티셋 썼는데 왜틀렸는지 당시에는 진짜 몰랐다.     끝나고 푼 사람들을 보니 싸이클이 있는지 확인해서 푼 사람들이 많았다.     에디토리얼은 맵을 이용했다.     맵을 이용한 풀이는 나랑 같았지만 여기서 추가적으로 결과적으론 사이클을 판별해야했다.   두 그룹으로 나눈다는게(Split into Two Sets) 그림으로 그려보면 고등학교 때 함수 개념 배울 때 사용하는 모양이 나오니까  Bipartite Graph(이분그래프)를 떠올리는 건 자연스럽다.    같은 숫자가 주어지면 NO   map에 넣을 때 크기가 2가 넘어가면 NO   홀수 사이클이 판별되면 NO      cin &gt;&gt; n;      for(int i=0;i&lt;n;i++){          int num; cin &gt;&gt; num;          while (!(num&amp;1)) num &gt;&gt;= 1;          m1.insert(num); //m1은 multiset이다.      }      multiset&lt;int&gt; :: iterator iter;      for(int i=0;i&lt;n;i++){          int num; cin &gt;&gt; num;          iter = m1.find(num);          while (iter==m1.end()&amp;&amp;num!=1){              num &gt;&gt;=1;              iter = m1.find(num);          }          if(iter!=m1.end()) m1.erase(iter);      }      if(m1.empty()) cout&lt;&lt;\"YES\\n\";      else cout &lt;&lt; \"NO\\n\";               m1.clear();  }           805 F. Equate Multisets 코포에 많이 나오는듯한 느낌의 문제였다.     관찰은 해봤지만 내가 생각한 방법에대한 시간복잡도 땜에 쫄아서 그런지 아무 생각이 안났다.    핵심은 »1 과  «1 밖에 안쓰니까 비트연산으로 접근해도 된다는 것이다.     그러면 같은 숫자가 될 수 있는 것은 비트연산에서 마지막 0들을 뗀 값일 것이다.    예를 들면, 3 = 11, 24 = 11000 이러면 3번 연산 필요하다는 것을 0세번 떼면서 알 수 있다. 그래서 첫번재 배열은 0들을 다 뗀 값을 넣어주고 두번쨰 배열을 입력받을 때 하나하나 쉬프트 연산 해주면서 있는 지없는지 확인한다.  805 G. Passable Paths 귀찮아서 생략!  806 D. Double string &lt; algorithm &gt;에 있는 find함수가 그냥 무지성으로 왼쪽에서부터 검사하는지 몰랐다.       그냥 이럴줄 알았으면 멀티셋으로 끝내버리는건데…하..substr으로 문자열 잘 나눠서 푸는건 잘했지만…..      많이 배웠다..  멀티셋으로 하면 문제점이 크기 순으로 정렬하니까 idx를 관리 할때 힘들다.     그래서 algorithm을 건드렸지만 잘모르고 건드리면 안된다는 걸 확실히 배웠다.  F. Yet Another Probelm About Pairs Satisfying an Indquality 이건 문제 이름이 왜케 긴건지 ㅋㅋㅋ 해석이 잘 안된다.    이분탐색의 직관은 잡을 수 있었는데 못풀었다. ㅎㅎ     이분탐색 문제들은 다 넘 어려웡 ㅠㅠ      arr[i]&gt;i를 이용해서 arr[i] &lt; i ,arr[j] &lt; j 를 다 해결하는 것이 인상깊었다.  vector&lt;int&gt; arr; int main(){     fast_io;     int test; cin &gt;&gt; test;     while (test--) {         int n; cin &gt;&gt; n;         arr = vector&lt;int&gt; (n+1);         for(int i=1;i&lt;=n;i++) cin &gt;&gt; arr[i];         vector&lt;int&gt; v;         ll res =0;         for(int i =1;i&lt;=n;i++){             if(arr[i]&gt;=i) continue; //i, j 둘다 거름             res += (ll)(lower_bound(v.begin(), v.end(), arr[i])-v.begin()); //arr[j]보다 작은 i의 개수 세기             v.push_back(i);         }         cout &lt;&lt; res &lt;&lt; '\\n';     } }   G. Good Key, Bad key F같은 유형에서 도망가서 사실 G를 더 많이 봤다.     솔직히 그리디라는 걸 눈치채지 못했다.     Bad key가 이름만 들어도 좀 쓰면 안좋을 것 같은 기분이긴 했는데 ㅋㅋㅋ      나의 감각에 어느정도 기대도 될 것 같기도 했다.     결론은 Good Key를 앞에서 몰아서 쓰는게 이득이라는 것이다.     Bad key를 사용해야 하는 개수는 정해져 있고 good key를 앞에서 몰아서 쓰자는 것이다. ll res=0, sum=0;    //sum은 goodkey를 앞에서 쓰는 것이다. for(int i=0;i&lt;=n;i++){     ll now = sum;     for(int j=i+1;j&lt;=min(n, 32+i);j++){  //bad키를 쓰는 모든 경우를 check         ll copy = arr[j];           //bad key를 32번 넘게 쓰면 10^9을 0으로 만들고 더 줄이는 꼴이라 의미가 없음         copy &gt;&gt;= j-i;               // i=0 -&gt; bad키를 n번씀, i=n -&gt; bad키를 안씀         now += copy;     }     res = max(res, now);     if(i==n) continue;     sum += arr[i+1]-k; } cout &lt;&lt; res &lt;&lt; '\\n';"
  },
  
  {
    "title": "Divide & Conquer",
    "url": "/posts/Divide&Conquer/",
    "categories": "BOJ",
    "tags": "DnC, 분할정복",
    "date": "2022-07-15 00:00:00 +0900",
    "content": "백준 18253번 최단경로와 쿼리 문제풀이  [18253 최단경로와 쿼리] https://www.acmicpc.net/problem/18253  .     쿼리를 한번에 계산하는 테크닉을 배워보자.   처음으로 풀게된 다이아 문제이고 참 좋은 문제라는 생각이 들어서 포스팅한다.  문제상황 파악하기. 문제상황은 간단하다 일단 Naive하게 짠다고 하면 각 쿼리마다 다익스트라를 하는 방법이고 이는 당연히 시간초과다.      그래도 다익스트라를 이용하여 최단거리를 구할 수 있다는 것을 생각할 수 있다.  아이디어 얻기. 처음에는 각 쿼리를 빠르게 계산하는 방법을 떠올렸다.    하지만 그러려면 쿼리가 최대 10만이므로 각연산을 로그시간만에 끝내야한다.     쿼리 구간이 크게 주어진다면 다익스트라를 하면서 쿼리 각 연산을 로그시간안에 끝내기가 까다로웠다.     쿼리마다 연산을 하는 것이 아니라 한번에 모든 쿼리를 연산해야했다.     이를 위한 가장 중요한 아이디어는 N이 작다는 것이다.(최대 5)      N이 작고 어느 지점에서 다른 지점으로 가기 위해서는 그 사이에 있는 한 줄(세로줄)을 무조건 건너야만 한다.     그래서 가운데 세로줄에 대해 다익스트라를 하면 n번의 다익스트라로 구간 최소를 구할 수 있다.      한번의 분할 정복을 하면서 모든 쿼리를 연산해두는 것이다. class Query{ public:     int y1, x1, y2, x2, idx;     Query(){}     Query(int a, int b, int c, int d, int e){         y1 = a; x1 = b; y2 = c; x2 = d;         idx = e;     } };  위와 같이 쿼리 클래스를 만들고 배열에 저장해뒀다.  주의할 점 이 문제는 위와 같은 아이디어로 구현을 한다고 하더라도 최적화에 꽤 많은 신경을 써야한다.     그 중에서 나의 문제는    다익스트라를 할 때 그 구간만 연산하는 것은 알고 있었지만   다익스트라의 dist함수를 초기화 할때 전체 구간을 초기화해서 시간초과가 계속 났다.   실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #define fast_io cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii;  class Query{ public:     int y1, x1, y2, x2, idx;     Query(){}     Query(int a, int b, int c, int d, int e){         y1 = a; x1 = b; y2 = c; x2 = d;         idx = e;     } };  const int dy[] = {-1, 1, 0, 0}; const int dx[] = {0, 0, 1, -1}; const ll INF = 500000000000001; int n, m;               //STL이 느려서 그런가... Query query[100001];   //push_back이 느려서 그런가?? ll grid[6][100001]; ll res[100001]; ll dist[6][100001];  void dijkstra(int sy, int sx, int range1, int range2){     for(int i=1;i&lt;=n;i++){         for(int j=range1;j&lt;=range2;j++) dist[i][j] = INF;     }     priority_queue&lt;pair&lt;ll, pii&gt;&gt; pq;     dist[sy][sx] = grid[sy][sx];     pq.push({-dist[sy][sx], {sy, sx}});     while (!pq.empty()) {         int hy = pq.top().second.first, hx = pq.top().second.second;         ll nowcost = -pq.top().first;         pq.pop();                  if(dist[hy][hx]&lt;nowcost) continue;         for(int i=0;i&lt;4;i++){             int ny = hy+dy[i], nx = hx+dx[i];             if(ny&lt;1||ny&gt;n||nx&lt;range1||nx&gt;range2) continue;             ll nextcost = nowcost+grid[ny][nx];             if(dist[ny][nx]&gt;nextcost){                 dist[ny][nx]= nextcost;                 pq.push({-nextcost, {ny, nx}});             }         }     } }   void solveDNC(int L, int R, Query qu[], int qusize){     if(!qusize||L&gt;R) return;     int mid = (L+R)&gt;&gt;1;     for(int i=1;i&lt;=n;i++){  // (i, mid)에서 다익스트라를 해서 쿼리 중 이곳을 지나는 최솟값을 갱신한다.(n번 다익스트라함)         dijkstra(i, mid, L, R);         for(int j=0;j&lt;qusize;j++){             res[qu[j].idx] = min(res[qu[j].idx], dist[qu[j].y1][qu[j].x1]+dist[qu[j].y2][qu[j].x2]-grid[i][mid]);         }     }     Query left[qusize];     Query right[qusize];     int lsize= 0, rsize =0;     for(int i=0;i&lt;qusize;i++){   //mid를 안지나도 되는 경우를 넣는다         if(qu[i].x1&lt;mid&amp;&amp;qu[i].x2&lt;mid) left[lsize++] = qu[i];   // 쿼리범위가 mid보다 작을 때         else if(qu[i].x2&gt;mid&amp;&amp;qu[i].x1&gt;mid) right[rsize++] = qu[i];  //쿼리범위가 mid보다 클 때     }     solveDNC(L, mid-1, left, lsize);     solveDNC(mid+1, R, right, rsize); }   int main(){     fast_io;     cin &gt;&gt; n &gt;&gt; m;     for(int i=1;i&lt;=n;i++){         for(int j=1;j&lt;=m;j++){             cin &gt;&gt; grid[i][j];         }     }          int q; cin &gt;&gt; q;     for(int i=0;i&lt;q;i++){         int r1, c1, r2, c2;         cin &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2;         if(c1&gt;c2){             swap(r1, r2);             swap(c1, c2);         }         Query q(r1, c1, r2, c2, i);         query[i] = q;     }          for(int i=0;i&lt;q;i++) res[i] = INF;     solveDNC(1, m, query, q);  //한번에 모든 쿼리를 계산     for(int i=0;i&lt;q;i++){         cout &lt;&lt; res[i] &lt;&lt; '\\n';     } }"
  },
  
  {
    "title": "코드포스 - 나는 바보다",
    "url": "/posts/Codeforces-131Edu/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2022-07-09 00:00:00 +0900",
    "content": "에듀 라운드 131 업솔빙  Educational Codeforces Round 131 개요 이쯤 되면 컨디션 문제도 아닌것같다.   내가 그린은 어케 갔었는지도 의문이다.ㅋㅋㅋㅋㅋ      코포는 시간이 생명인데 영어에서 자꾸 절어서 시간이 오래걸리고 여전히 3솔을 못한다.ㅠㅠ      이제부턴 진짜 버추얼이라도 돌아봐야겠다.  A. Grass Field 너무 쉬웠는데 한번 틀렸다.     영어를 잘못 이해했다. 자신을 포함해서 총 3개의 칸이 지워지는건데 왜 2개라고 읽었는지 모르겠다.    바보 같은 실수로 절고 7분 걸렸다. int cnt=0; for(int i=0;i&lt;2;i++){     for(int j=0;j&lt;2;j++){         cin &gt;&gt; board[i][j];         if(board[i][j]) cnt++;     }  } if(cnt==4) cout &lt;&lt; 2 &lt;&lt; '\\n'; else if(cnt==0) cout &lt;&lt; 0 &lt;&lt; '\\n'; else cout &lt;&lt; 1 &lt;&lt; '\\n';   B. Permutation 이거는 해석을 오히려 잘해서 헷갈렸다.    해석한 걸로 따지면 d가 2일 때가 최적이고 그냥 그걸 출력하면 된다.    그러면 d가 의미가 있나 싶어서 말도 안되는 증명하다가 시간 다 보냈다.     그래서 2틀하고 에라이 그냥 d가 2인걸로 하자 했더니 AC나옴..ㅡㅡ  cout &lt;&lt; 2 &lt;&lt; '\\n';  //d는 무조건 2가 최적 for(int i=1;i&lt;=n;i++){     if(visited[i]) continue;     for(int j=i;j&lt;=n;j*=2){         if(visited[j]) continue;         cout &lt;&lt; j &lt;&lt; ' ';         visited[j] = true;     } }    C. Schedule Management 솔직히 많이 배운 문제이다.    처음에는 dp인가 하다가 아닌것같아서 다시 생각해보니     [이중 우선순위 큐] https://www.acmicpc.net/problem/7662  .   가 생각났다. 그래서 우선순위 큐 2개로 다뤄봤는데 디버깅하다가 우선순위큐가 중복을 허용하지 않는다는 걸 알았다.     그래서 멘붕왔는데 내 풀이를 버리질 못하고 서성대다가 끝나버렸다.    다른분들중에 나랑 같은 생각하신 분은 multiset을 이용하여 풀었더라…      멀티셋을 활용하는걸 잘 알아둬야겠다.   에디토리얼에는 이분탐색으로 푸는 방법이 나와있고 내가 이분탐색을 매우 못한다는 것을 깨달았다.   bool check(int t){     ll fr =0, need = 0;     for(int i=1;i&lt;=n;i++){         if(t&gt;=nums[i]) fr += (t-nums[i])/2; //자기 일 끝내고 남는 시간         else need += nums[i] -t;    // 자기 일을 못끝내서 남는 시간     }     return need&lt;=fr;    //시간이 여유로우면 참을 리턴 }  int l = 0, r = 2*m; // 모든일을 2시간이 걸려서 하면이 최대고         int res = -1;         while (l&lt;=r){   //이분탐색으로 제일 여유로운 시간중 최솟값을 찾는다             int mid = (l+r)&gt;&gt;1;             if(check(mid)){                 res = mid;                 r = mid-1;             }else{                 l = mid+1;             }         }         cout &lt;&lt; res &lt;&lt; '\\n';   D. Permutation Restoration 나에겐 넘 어려웠다 어떤 상황인지는 알겠는데 아이디어가 진짜 안 떠올랐다.    그래서 10분보고 그냥 버렸던 것 같다.    핵심은 수학적으로 처음 배열과 수정된 배열의 관계를 알아내는 것이다.    그러면 범위가 나오고 그 범위의 시작점이 작으면서 끝점도 작은 것 부터 해결한다.     에디토리얼을 보고도 굉장히 까다로웠던 문제였다. original = vector&lt;int&gt; (n+1); modify = vector&lt;int&gt; (n+1); seg = vector&lt;pii&gt; (n+1, make_pair(-1, -1)); for(int i=1;i&lt;=n;i++) cin &gt;&gt; modify[i]; for(int i=1;i&lt;=n;i++){     seg[i] = make_pair(i/(modify[i]+1)+1,i);   //i번째 idx의 수는 i/modift[i]+1 이상이다 } sort(seg.begin(), seg.end()); int j =1; set&lt;pii&gt; s; for(int i=1;i&lt;=n;i++){     while (j&lt;=n&amp;&amp;seg[j].first==i){         int idx = seg[j++].second;         s.insert(make_pair(modify[idx]?idx/modify[idx]:n, idx));    //idx번째 수는 first이하이다.     }     original[s.begin()-&gt;second] = i;     s.erase(s.begin());              } for(int i=1;i&lt;=n;i++) cout &lt;&lt; original[i] &lt;&lt; ' '; cout &lt;&lt; '\\n';"
  },
  
  {
    "title": "Tree DP",
    "url": "/posts/Tree-DP/",
    "categories": "BOJ",
    "tags": "Tree, Dynamic Programming",
    "date": "2022-07-05 00:00:00 +0900",
    "content": "백준 1949번 우수 마을 문제풀이  [1949 우수 마을] https://www.acmicpc.net/problem/1949  .     트리에서 dp를 수행한다.  문제상황 파악하기.    정점의 합이 최대여야한다.   고르는 정점들이 인접하면 안된다.   안 고른 정점 옆에는 최소한 한 개는 고른 정점이 있어야한다.    이것도 3번이 낚시인데 사실 그리디 하게 생각해보면 무조건 고르는게 이득이다.     왜냐면 주민 수는 항상 양수 이기 때문이다.   Tree에서 DP를 어떻게 하는가? 그래프 탐색을 하면서 dp를 쌓아 올리는 것이다.    dfs로 깊게 들어간다음 leaf에서 dp값을 초기화하고 올라오면서 그 dp값을 이용하여 계산한다.  아이디어 얻기. 가장 깊게 들어가면 leaf는 0or 1이다. 이말은 이것을 포함 안하냐 하냐의 문제이다.    따라서 dp[k][bool] bool이 0이면 k를 안골랐을 때, bool이 1이면 k를 골랐을 때 우수마을의 최대 주민 수 이다.  주의할 점 3번 조건이 낚시인 점?  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #define fast_io cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll;  int n, V[10001]; vector&lt;int&gt; adj[10001]; int dp[10001][2];   //N번 정점이 우수마을 일때/아닐때 최대 주민수 bool visited[10001];  void dfs(int here, int parent){     visited[here] = true;     dp[here][0] = 0;     dp[here][1] = V[here];      for(int next : adj[here]){         if(next==parent) continue;         if(!visited[next]) dfs(next, here);          dp[here][0] += max(dp[next][1], dp[next][0]);         dp[here][1] += dp[next][0];     } }  int main(){     fast_io;     cin &gt;&gt; n;     for(int i=1;i&lt;=n;i++) cin &gt;&gt; V[i];     for(int i=1;i&lt;n;i++){         int u, v; cin &gt;&gt; u &gt;&gt; v;         adj[u].push_back(v);         adj[v].push_back(u);     }     dfs(1, 0);     cout &lt;&lt; max(dp[1][0], dp[1][1]); }"
  },
  
  {
    "title": "Topological Sort",
    "url": "/posts/Topological-Sort/",
    "categories": "BOJ",
    "tags": "DFS, 위상정렬",
    "date": "2022-07-05 00:00:00 +0900",
    "content": "백준 3665번 최종 순위 문제풀이  [3665 최종 순위] https://www.acmicpc.net/problem/3665  .     그래프를 모델링하고 BFS 위상 정렬을 한다.  문제상황 파악하기. 작년순위가 모두 주어지고 그 다음에는 올해 등수가 바뀐 팀이 주어진다.    이 때 올해 순위를 확정하여야한다.    1등 부터 자식으로 방향이 있는 그래프를 모델링하고, 전후 관계가 있으므로 위상정렬한다.  Topological Sort(위상 정렬)가 뭐길래? 예를 들면 수학을 공부 할 때 더하기를 배우고 곱하기를 배우는게 좋다, 빨래를 하고 건조를 해야한다. 등    선후관계가 있는 것들이 있다.    이런 것들을 그래프로 모델링 할 때 위상정렬로 일직선에 놓인것 처럼 모델링하는 것이다.    그래서 정점들을 출력하면 순서대로 나올 수 있도록 한다.    DFS로 위상정렬하는 방법은 단순하다.(dfs함수 종료 할때 정점을 추가하고 다 추가한 뒤 배열을 뒤집어 주면 됨)     하지만 이문제는 올해 순위가 특정 될 수 도 있고 안될 수도 있어서 dfs로 단순히 풀기가 쉽지 않았다.  아이디어 얻기. 1등을 루트로 선후관계를 그래프로 그려보면 꼴등은 모든 곳에서 화살표를 받을 것이고 1등은 들어오는 간선이 없을 것이다.    즉 inorder[root] = 0이고 inorder[leaf] = n 일 것이다.     그리고 올바른 순위라면 모든 inorder가 한개씩 차이가 날 것이다.     즉 inorder가 작은것부터 큐에 넣어서 처리하면 된다.    이 문제는 잘 지켜보면 작년 순위가 모두 주어졌고 순위 변경만 일어난다.    그렇다면 모순될 수는 있어도 순위 정보를 모를 수는 없다. 따라서 ?는 나올리가 없다.     난 이런 낚시가 너무 어렵다. 엄청난 혼란이 왔었다.  주의할 점 BFS 위상정렬할 때 사이클이 발견되면 모순된다는 뜻이다.     인접리스트를 쓸 수도 있는데 인접행렬이 더 편한거 같다(inorder를 계산할 떄)  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #define fast_io cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; pii;  int n,m; vector&lt;int&gt; last; vector&lt;vector&lt;int&gt; &gt; adj;  void BFS_topoSort(){     vector&lt;int&gt; indegree(n+1, 0);      for(int u=1;u&lt;=n;u++){         for(int v=1;v&lt;=n;v++){             if(adj[u][v]) indegree[v] += adj[u][v];         }     }      queue&lt;int&gt; q;     for(int i=1;i&lt;=n;i++) if(!indegree[i]) q.push(i);   //DAG특성상 하나가 있을거임     int cnt=0;     vector&lt;int&gt; curorder;     while (!q.empty()){         int here = q.front();         q.pop();         curorder.push_back(here);          for(int i=1;i&lt;=n;i++){             if(adj[here][i]){                 indegree[i]--;                 if(!indegree[i]) q.push(i);             }                          }         cnt++;     }          if(cnt!=n) cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; '\\n';     else{         for(int i=0;i&lt;curorder.size();i++) cout &lt;&lt; curorder[i] &lt;&lt; ' ';         cout &lt;&lt; '\\n';     } } int main(){     fast_io;     int t; cin &gt;&gt; t;     while (t--){         cin &gt;&gt; n;         last = vector&lt;int&gt; (n+1);         adj = vector&lt;vector&lt;int&gt; &gt; (n+1, vector&lt;int&gt; (n+1, 0));         for(int i=1;i&lt;=n;i++) {             cin &gt;&gt; last[i];             for(int j=1;j&lt;i;j++){                 adj[last[j]][last[i]]++;  //last[j]에서 last[i]로 가는길이 있다             }         }                  cin &gt;&gt; m;         for(int i=0;i&lt;m;i++){             int u, v;             cin &gt;&gt; u &gt;&gt; v;             if(adj[u][v]&lt;adj[v][u]) swap(u, v);             adj[u][v]--;             adj[v][u]++;         }          BFS_topoSort();     } }"
  },
  
  {
    "title": "Trie",
    "url": "/posts/Trie/",
    "categories": "BOJ",
    "tags": "Trie",
    "date": "2022-07-03 00:00:00 +0900",
    "content": "Trie 자료구조 이해하기  [5670 휴대폰 자판] https://www.acmicpc.net/problem/5670  .     트라이 자료구조를 이용한다.  문제상황 파악하기. 휴대폰의 자동완성 기능을 사용했을 때 버튼 누르는 횟수를 계산하는 문제이다.     트라이 자료구조를 이용하여 버튼을 누를 때마다 카운트를 해주면 된다.  Trie가 뭐길래? 트라이 자료구조는 원래 있던 문자면 따라가다가 달라지면 방향을 틀어 새로운 길을 만드는 트리구조이다.    생각하기는 편한 자료구조인데 처음보면은 구현은 어떻게 해야하지 싶다.    기본적으로는 연결리스트의 아이디어이다.   최적화할 때 맵을 이용하는 방법도 있지만 여기서는 알파벳 26개의 배열을 만들어서 트라이를 구현해보자!  아이디어 얻기. 트라이 구조를 만들고 단어가 끝날 때마다 bool형 isEnd에다가 체크를 했다.    그리고 그 단어들을 따라가며 isEnd가 나올 때마다 카운트를 해준다.     그러면 카운트된 수가 문자들을 치기 위해서 타이핑해야하는 숫자이고 이를 문자의 수로 나눠주면 평균이 된다.     이는 문자를 따라가며 단 한번만 수행 되므로 문자의 길이 즉, O(N)의 시간복잡도를 가질 것이다.    다만 알파벳이 새로 생길 때마다 공간을 할당하다보니 메모리의 소모가 크다.  주의할 점 동적할당을 했으면 delete를 이용하여 메모리를 비워야한다.  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;map&gt; #define fast_io cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll;   const int ALPHABET = 26;  struct Trie{     Trie *children[ALPHABET];     bool isEnd;     Trie(){         isEnd = false;         for(int i=0;i&lt;ALPHABET;i++) children[i] = NULL;     }     ~Trie(){         for(int i=0;i&lt;ALPHABET;i++)             if(children[i]) delete children[i];     } };  void insert(Trie* root, string&amp; key, bool isFirst, int idx){     Trie *pCrawl = root;      if(!pCrawl-&gt;children[key[idx]-'a']) {         pCrawl-&gt;children[key[idx]-'a'] = new Trie();         if(!isFirst){             pCrawl -&gt; isEnd = true; //처음으로 갈라지거나 끝나는 부분을 체크했음             isFirst = true;         }     }     if(idx==key.length()) {         pCrawl -&gt; isEnd = true;         return;     }     insert(pCrawl-&gt;children[key[idx]-'a'], key, isFirst, idx+1);  }  int search(Trie* root, string&amp; key){     Trie * pCrawl = root;     int ret = 0;     for(int i=0;i&lt;key.length();i++){         int idx = key[i]-'a';         if(pCrawl-&gt;isEnd) ret++;         pCrawl = pCrawl-&gt;children[idx];     }     return ret; }  vector&lt;string&gt; strs;  int main(){     fast_io;     int num;     while (cin&gt;&gt;num){         strs = vector&lt;string&gt; (num);         Trie* root = new Trie();         for(int i=0;i&lt;num;i++){             cin &gt;&gt; strs[i];             insert(root, strs[i], false, 0);         }         int res = 0;         for(int i=0;i&lt;num;i++){             res += search(root, strs[i]);         }         cout &lt;&lt; fixed;         cout.precision(2);         cout &lt;&lt; (double)res/(double)num &lt;&lt; '\\n';         delete root;     }      }"
  },
  
  {
    "title": "Merge Sort",
    "url": "/posts/MergeSort/",
    "categories": "BOJ",
    "tags": "Merge Sort",
    "date": "2022-06-27 00:00:00 +0900",
    "content": "merge sort를 이용하여 inversion 개수세기  [1517 버블 소트] https://www.acmicpc.net/problem/1517  .     inversion의 개수를 센다.  문제상황 파악하기. 버블소트는 arr[i]&gt;arr[i+1]이면 swap하면서 진행하는 정렬 방법이다.   그리고 이는 당연하게도 O(n^2)이 걸린다.           그리고 당연하게도 그대로 구현하면 시간초과다 그러면 실버급이겠지.  O(NlogN)까지는 허용 될 것이므로 다른 방법을 찾아야한다.  inversion? i &lt; j 일 때 arr[i] &gt; arr[i+1] 일때 (arr[i], arr[i+1])의 쌍을 inversion이라고 한다.    결국 이 문제는 모든 inversion의 개수를 세는 것이다.     inversion을 세는 방법은 merge sort, bit, segment tree 등 여러가지가 있지만 merge sort를 이용해 구해보자!     [참고자료] https://www.geeksforgeeks.org/counting-inversions-in-an-array-using-segment-tree/?ref=gcse     나는 위의 링크를 참고 했다.  아이디어 얻기. merge sort는 Divide &amp; Conquer를 이용한다.    분해되고 병합되는 과정은 아래 그림과 같다.         최대한 절반으로 나눠서 효율적인 계산을 하도록 하고,    노란색, 초록색으로 분해 되고 병합된다. 그 과정에서 빨간색 박스로 inversion을 센다.    병합하는 과정에서 mid-i개(앞인데 더 큰거의 개수)를 계속 더해주는 것이다.  주의할 점 값이 long long을 넘어갈 수 있다. 범위를 보면 쉽게 알 수 있다.  (근데 난 한번 틀렸다 제출하자마자 아차 했다 ㅋㅋ)  실제 코드 나머지 주의 할 점은 코드에 주석으로 처리했다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #include &lt;set&gt; #define fast_io cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll;  int n; ll arr[500001];  ll merge(ll arr[], ll temp[], int left, int mid, int right){     int i, j, k;     ll inv_count = 0;     i = left; j = mid; k = left;     while (i&lt;mid&amp;&amp;j&lt;=right){         if(arr[i]&lt;=arr[j]){             temp[k++] = arr[i++];         }else{             temp[k++] = arr[j++];             //mid는 right덩어리의 처음 index이다.              inv_count += mid-i;         }     }     //남은거 다 넣어     while (i&lt;mid) temp[k++] = arr[i++];     while (j&lt;=right) temp[k++] = arr[j++];     //원래 배열로 다 옮겨     for(i= left;i&lt;=right;i++) arr[i] = temp[i];     return inv_count; }  ll _mergeSort(ll arr[], ll temp[], int left, int right){     int mid; ll inv_count=0;     if(right&gt;left){         mid = (left+right)&gt;&gt;1;         inv_count += _mergeSort(arr, temp, left, mid);         inv_count += _mergeSort(arr, temp, mid+1, right);          inv_count += merge(arr, temp, left, mid+1, right);     }     return inv_count; }  ll mergeSort(ll arr[], int array_size){     ll temp[array_size];     return _mergeSort(arr, temp, 0, array_size-1);  //mergesort call-by-address }  int main(){     fast_io;     cin &gt;&gt; n;     for(int i=0;i&lt;n;i++) cin &gt;&gt; arr[i];     cout &lt;&lt; mergeSort(arr, n); }"
  },
  
  {
    "title": "코드포스 - 3솔의 벽",
    "url": "/posts/Codeforces-801,-802/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2022-06-21 00:00:00 +0900",
    "content": "3솔의 벽이 너무 높다..  Codeforces Round #801, #802 div2 개요. 벌써 코포를 시작한지 한달 정도가 넘어간다.   div2만 들어서면 2솔밖에 못한다..   3솔의 벽이 너무 높다. 아이디어도 못떠올리는 경우가 대다수이다.   “dp 같긴한데…, greedy같긴한데..”생각만하고 못풀 때도 많다.    문제점 잡기가 어렵다. 3솔의 벽을 깨보기 위해 이번에는 C, D만 업솔빙 해보려고 한다.  801 C. Zero Path 문제를 조금 읽고 보면 dp같긴했다. 평소 2차원 dp의 좀 복잡한 형태는 항상 못풀었었고 자신감이 없었따… dp가 맞긴맞았는데 잘못 짚었다. 4칸을 기준으로 보면 상황은 다음 그림과 같다.    보면 2, 0, -2밖에 되지 않는다. 따라서 경로를 적절히 조절하여 2씩 줄이거나 늘릴 수 있다는 뜻이다.   즉 끝점에서의 min, max값이 min &lt;= 0 &lt;= max 이고 2, 0, -2 단위면 적절히 조절하여 0을 만들 수 있다는 뜻이다.  mindp[0][0] = maxdp[0][0] = grid[0][0]; for(int i=1;i&lt;n;i++){ mindp[i][0] = maxdp[i][0] = mindp[i-1][0]+grid[i][0]; } for(int j=1;j&lt;m;j++){     mindp[0][j] = maxdp[0][j] = mindp[0][j-1] +grid[0][j]; } for(int i=1;i&lt;n;i++){     for(int j=1;j&lt;m;j++){         mindp[i][j] = min(mindp[i-1][j], mindp[i][j-1]) + grid[i][j];         maxdp[i][j] = max(maxdp[i-1][j], maxdp[i][j-1]) + grid[i][j];        } }     if((maxdp[n-1][m-1]%2)||mindp[n-1][m-1]&gt;0||maxdp[n-1][m-1]&lt;0) cout &lt;&lt; \"NO\\n\";  else cout &lt;&lt; \"YES\\n\";   801 D. Tree queries C가 자신이 없었기에 contest당시에는 D를 더 오래봤다.   근데 끝나고 디코반응같은걸 보니 D가 은근히 복병이었던것 같다.   그래프를 만들고 트리의 지름 문제 처럼 접근하려고 했다. DFS해서 가장 멀리 있는 것을 찾고, 그 다음 남은 서브트리를 찾고,..그런식으로..   예제 3번조차 잘 안됐다. 아이디어가 틀렸던 것 같다.   업솔빙도 오래걸렸다. 위의 문장을 쓰고 2시간이 지났다 ㅋㅋㅋㅋ    내가 영어를 못하는건지 문제가 눈에 하나도 안들어왔는데 이제야 좀 알겠다.   차수가 1이면 1개로 그냥 판단된다. 차수가 2여도 한방에 그냥 판단된다.   그니까 차수가 3개이상일 때만 판단하려면 2번이상 봐야한다. 근데 이걸 볼때도 루트기준으로 (서브트리에서 온 거) + (일자인거 갯수-1)을 해줘야한다.   그냥 무작정 차수가 3개이상이면 degree-1 하고 더하면 문제가 된다.  왜냐하면 서브트리를 판단할 때 썼던 간선이 다른걸 판단 할 때 또 쓰여서 중복으로 세질 수 있기 때문이다.   그래서 각 루트를 기준으로 세서 최소값을 출력한다. int dfs(int i, int p) {     int sm = 0, z = 0;  //sm은 서브트리에서 온 k개수, z는 서브트리 중 일자인거 개수이다          for (int j : tree[i]) if (j != p) { //부모노드 빼고 검사하고         int x = dfs(j, i);         sm += x;         if (x == 0) //일자면             z++;     }          return sm + max(0, z - 1);  //부모노드 제외하고 2개이상이어야 카운트 된다. }   특징은 간선이 3개 이상인 곳에서 검사하면 모든 정점 검사할 필요없이 끝이긴하다.(왜그런진 모름..)  802 C. Helping the nature 이런 문제 옛날에 어디선가 풀었던 것같은데 라는 생각만 계속하다가 결국 아무것도 못했다.   난 이런 문제가 젤 어렵다 손으로 하면 되긴하는데 컴퓨터로 어케하지 싶은 문제들..     그래서 맨날 C번을 못푸나 보다 ㅠㅠ    중요한건 인접한 것의 크기비교였다. 만약에 a[i] &lt; a[i+1]이면 오른쪽 시작(suffix)으로 빼야한다. 왜냐면 왼쪽시작(prefix)으로 빼면 이미 작은데 더 빼서 손해기 때문이다.   빼는 양의 정도는 a[i+1]-a[i]일 것이다. 크기를 똑같이 만들어 같이 움직여야한다.   그러면서 평평하게 만들어지고, 그렇다면 그 평평할 때 의  높이 curh를 저장해놓고 마지막에 더해주면 된다.   이래도 되는 이유는 인접한거는 세트로 움직이기 때문이다 그러니까 차이가 변하질 않는다.    a배열의 값이 10억이므로 답은 int형을 훌쩍 넘어갈 수 있다. 따라서 long long으로 해줘야한다.     long long res = 0;     long long curh = a[0];     for(int i = 0; i &lt; n-1; i++) {         res += abs(a[i] - a[i+1]);         if(a[i] &gt; a[i+1]) {             curh += a[i+1] - a[i];  //깎일 수도있고 늘어날수도 있으니 이건 절댓값 안붙여         }     }     cout &lt;&lt; res+abs(curh)&lt;&lt;'\\n';   802 D. River Locks C에 올인해서 문제도 안읽어 봤다.   읽어보니 일단 왼쪽에서 넣는게 이득이라는 것을 확인됐다.    조금 이해가 안되는건 높은곳에서 낮은쪽으로 가는게 아니라 그냥 왼쪽이 꽉차면 오른쪽으로 간다.        그림을 위와 같이 그려놔서 내가 해석을 제대로 한건가? 헷갈렸다. ㅋㅋㅋ cin &gt;&gt; n; vol = vector&lt;ll&gt; (n+1); mintime = vector&lt;ll&gt; (n+1); ll sum = 0; for(int i=1;i&lt;=n;i++){     cin &gt;&gt; vol[i]; } mintime[0] =0;    for(int i=1;i&lt;=n;i++){     sum += vol[i];      // i개 썼을 떄 i개 다 채울라면 몇초 걸림?       // 앞에께 크면 앞에꺼 만큼 걸리고, 뒤에께 크면 앞에서 좀 흘러나온거 받음      // 나눗셈연산 생각해서 올림처리 해줌     mintime[i] = max(mintime[i-1], (sum+i-1)/i);    } cin &gt;&gt; q; while (q--){     ll query;     cin &gt;&gt; query;     ll rst = (sum+query-1)/query;     if(rst&lt;=n&amp;&amp;mintime[rst]&lt;=query) cout &lt;&lt; rst &lt;&lt; '\\n';     else cout &lt;&lt; -1 &lt;&lt; '\\n'; }"
  },
  
  {
    "title": "Segment Tree - 구간갱신",
    "url": "/posts/Segment-Tree2/",
    "categories": "BOJ",
    "tags": "Segment Tree, 세그먼트트리",
    "date": "2022-06-21 00:00:00 +0900",
    "content": "lazy propagation없이 구간 갱신하기  [16975 수열과 쿼리 21] https://www.acmicpc.net/problem/16975  .     lazy propagation없이 segment tree를 이용하여 구간 갱신을 하고 점 쿼리를 해결한다.  문제상황 파악하기. 문제는 구간에다가 k를 더한다.   우리가 알고있는 segment tree로는 구간의 크기만큼 시간이 걸릴 것이다.           그렇다면 구간이 크다면 그냥 선형 배열 수정하듯이 O(n)의 시간 복잡도를 가질 것이다. (세그트리의 의미가 없겠다…).  그래서 구간 update를 위한 방법으로 lazy propagation이 있는데 이는 내가 아직 공부를 못해서 모르고 그거 없이 구간 update하는 법을 공부했다.       이는 [구간 갱신 + 점 쿼리] 에 사용된다.  어떻게 구간갱신 + 점 쿼리를? 다른 배열 D[i]를 사용하는 것이다. D[i] = A[i]-A[i-1], D[0]=A[0] 으로 정의한다.    이 배열이 구간 갱신을 할 때 필요하다.  update(l, r, x)를 D[l] += x, D[r+1] -= x 를 해준다. printArray() A[0] = D[0]는 그냥 프린트하고 A[i] = A[i-1]+D[i]를 하고 프린트한다. update는 상수시간, 프린트는 여기서는 배열의 크기의 시간이 걸리고 점이면 상수시간에 해결 가능하다.   [구간 갱신 이용] https://www.geeksforgeeks.org/difference-array-range-update-query-o1/     위의 개념을 세그먼트 트리에 적용하는 것이다!!  아이디어 얻기. Segment Tree를 만들때 D[i]를 이용한다. 그렇게 되면 세그트리에는 D[i]의 부분합들이 들어가 있을 것이다.    그렇다면 점쿼리를 구할 때 뭐를 출력해야하는가 index x의 값을 구하고 싶으면 sum(x)를 하면 된다.    ex) sum(3) = (arr[3]-arr[2])+(arr[2]-arr[1])+(arr[1]-arr[0]) = arr[3]이기 때문이다.   세그트리에서는 D[]를 2번의 점 갱신, 한번의 구간합 구하기 하는 거나 다름 없지만 arr에서는 구간 갱신, 점쿼리 하는 꼴이 되는 것이다.    너무 놀랍다…  주의할 점 값이 long long을 넘어갈 수 있다. 범위를 보면 쉽게 알 수 있다.  실제 코드  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;cmath&gt; #define fast_io cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false); using namespace std; typedef long long ll;  int n, m; vector&lt;ll&gt; arr; vector&lt;ll&gt; tree;  ll init(int node, int S, int E){     if(S==E){         return tree[node] = arr[S]-arr[S-1];        //여기가 중요!!     }     int mid = (S+E)/2;     return tree[node] = init(2*node, S, mid) + init(2*node+1, mid+1, E); }  void update(int x, ll val, int node, int S, int E){ //점 갱신 먼저 구현한다.     if(S==E) tree[node] += val;     else{         int mid = (S+E)/2;         if(x&lt;=mid) update(x, val, 2*node, S, mid);         else update(x, val, 2*node+1, mid+1, E);                  tree[node] = tree[2*node]+tree[2*node+1];   //update를 한후에 더해주는 연산     } }  ll sum(int L, int R, int node, int S, int E){        if(L&gt;R) return 0;     if(L==S&amp;&amp;R==E) return tree[node];        int mid = (S+E)/2;     return sum(L, min(mid, R), 2*node, S, mid)+sum(max(L, mid+1), R, 2*node+1, mid+1, E); }  void getElement(int x){     cout &lt;&lt; sum(1, x, 1, 1, n) &lt;&lt; '\\n'; }  void RangeUpdate(int L, int R, ll x){     update(L, x, 1, 1, n);          // arr[l] += x;     if(R+1&lt;=n) update(R+1, -x, 1, 1, n); //arr[r+1] -= x; }  int main(){     fast_io;     cin &gt;&gt; n;     arr = vector&lt;ll&gt; (n+1);     tree = vector&lt;ll&gt; (4*n+10);  //넉넉잡아 4배 했음     for(int i=1;i&lt;=n;i++) cin &gt;&gt; arr[i];     init(1, 1, n);     cin &gt;&gt; m;     for(int iter=0;iter&lt;m;iter++){         int o;         cin &gt;&gt; o;         if(o==1){             int i, j;             ll k;             cin &gt;&gt; i &gt;&gt; j &gt;&gt; k;             RangeUpdate(i, j, k);                      }else{             int x;             cin &gt;&gt; x;             getElement(x);         }     } }"
  },
  
  {
    "title": "코드포스 폭망 기념",
    "url": "/posts/Codeforces-800/",
    "categories": "Codeforces",
    "tags": "upsolving, 코드포스",
    "date": "2022-06-18 00:00:00 +0900",
    "content": "코드포스 폭망기념 upsolving  Codeforces Round #800 Editorial 개요. 코드포스를 시작하고 그래도 계속 그린 퍼포먼스는 나오길래 답만 보고 넘겼었다.   그런데 이번 코포에서 정말 단 한문제도 못풀었다…    그래서 분노의 업솔빙을 해보려고 한다. ㅠㅠ   백준 플레가 코포 뉴비에서 헤매고 있다니 정말 분하고 부끄럽다.   업솔빙을 계기로 강해져보자  A. Creep 나를 눈물나게 한 문제이다.   접두사가 될 수있는 최대 점수는 전체 = abs(a-b)라고 생각을 했고, 앞에서부터 채워나가면서 이 abs(a-b)만 안넘으면 된다고 생각했다.   그래서 a, b를 모두 소진 할 때까지 Max = abs(a-b)를 넘기지 않으면서 넣는 과정을 계속했는데…ㅠㅠ 계속 틀렸다.   a와 b가 충분히 작기 때문에 O(a+b)로 해결할 수 있다고 믿었기 때문이다.   정답을 봤는데 비슷하다…다만 내가 신경쓰지 못한부분은 a==b이고 cnt가 계속 0이니까 라고 생각했는데 내가 cnt를 ++하고 비교했다는 것을 깨닫지 못한것이다…   아래 코드에서 Max를 max(1, Max)로 바꾸니 통과했다.         int a, b;         cin &gt;&gt; a &gt;&gt; b;         int Max = abs(a-b);         int cnt = 0;         bool state;         if(a&gt;b) state = true;         else state = false;                  int acnt = a, bcnt = b;         for(int i=0;i&lt;a+b;i++){             if(state&amp;&amp;acnt){                 cout &lt;&lt; '0';                 cnt++; acnt--;                 if(cnt==Max||acnt==0) {                     cnt = 0;                     state = false;                 }             }else if(bcnt){                 cout &lt;&lt; '1';                 cnt++; bcnt--;                 if(cnt==Max||bcnt==0) {                     cnt = 0;                     state = true;                 }             }         }  B. Paranoid String A가 안풀려서 멘탈이 터진 상태로 B로 왔는데.  또 멘탈이 터졌다.    문제 이해부터 쉽지 않았는데 그냥 모든 01, 10, 또는 1, 0을 세라는 거구나라고 이해했다.  하지만 어떻게 문자열을 줄이느냐에 따라 paranoid string이 생길 수도 있고 안생길 수도 있었다.   나는 이 문제는 경우에 따라 나눠서 dp로 접근할까했는데 예제 4번에서 막혔다. 예제 4번 1001은 1,0,0,1, 10, 01, 01, 01 이렇게 8개 있는데 마지막 101의 01을 못세었다.   답을 봤는데… 역대급으로 간단했다.   그냥 전체 크기 + 10 or 01인걸 셀 때 index값만 해주면 되었다..덜덜덜…why?    예를 들어 s[m-1] != s[m] 일 때 s[m] = 0이라고 하면 110, 010의 경우가 있다. 둘다 10 -&gt; 0 , 10 -&gt; 0으로 만들 수 있다.   s[m] = 1이라고 하면 001, 101이 있고 이는 01 -&gt; 1 , 01 -&gt; 1로 둘다 만들 수 있다. 그니깐 저렇게 풀어도 되는것이다..ㅠㅠ         cin &gt;&gt; n &gt;&gt; S, ans = n; \t\tfor (int i = 1; i &lt; n; ++ i) \t\t\tif (S[i] != S[i - 1]) \t\t\t\tans += i; \t\tcout &lt;&lt; ans &lt;&lt; '\\n';  답이 long long으로 int형이 넘어간다는 것도 체크해야한다.  C. Directional Increase A, B를 WA맞고 아주 살짝 건드린 문제.   문제를 이해함과 동시에 아 그냥 A, B만 팔까 싶었다.    어려워서 그랬다기 보다는 A,B도 못푸는데 무슨 C냐 하는 마음이였던 것같다.   총합은 무조건 0이고,  일단 문제를 보고 투포인터를 떠올렸고 앞에 포인터가 음수거나 뒤에 포인터가 양수면 실패하도록 설계했다. 하지만 예제 4번째꺼가 발목을 잡았다.ㅠㅠ   이 문젠 부분합을 이용하여 부분합 마지막이 0, 부분합 중간 부분에 음수가 있거나, 중간에 0이 껴있으면 실패하는 경우를 찾는 것이다.   부분합 + casework 문제였다.(할만했을지도…)         if(ps[n]) { //부분 합 마지막이 0이 아님             cout &lt;&lt; \"No\\n\";             continue;         }         bool possible = true;         for(int i=1;i&lt;=n;i++) if(ps[i]&lt;0) possible = false; // 부분합 중간에 음수가 있음         bool zero = false;         for(int i = 1;i&lt;=n;i++){    //부분 합 중간에 0이 껴있음             if(ps[i]==0) zero = true;             else if(zero) possible = false;         }   D. Fake Plastic Trees 여기서부터는 완벽하게 올업솔빙이다.   건들지도 못했다. 이번 코포는 나를 너무 자책하게 만들었다.   하지만 괜찮다. 못하는걸 어떡하겠어 더 실력을 갈고 닦아야지.   문제 이해를 대충해보니 greedy하게 풀 수 있을 것 같았다.   왜냐하면 부모는 무조건 자식에게 영향 받으므로 자식이 없는 노드 부터 생각을 해가면 부모의 경우의 수가 줄어 들것으로 예상했기 때문이다.   dfs로 자식에서 부터 올라면서 더하는 것을 구현한다.   근데 이거 그리디하게만 하면 된다는 것을 증명하기는 좀 까다로운 것 같다…  E. Keshi in Search of AmShZ n은 정점, m은 간선으로 graph 모델링은 쉬운것같고, 방향이 있는 간선이라고 줬다.   이제 문제는 두가지 메시지를 보내서 서로 만나는 거리을 최소화하는 것이다.   최단거리니깐 다익스트라를 사용해봐야겠다는 직관을 얻을 수 있다.   keshi는 1에 AmshZ는 n에 있고 n에서 1까지 다익스트라 하면 된다.  F. Decinc Dividing 몰라… 걍 생략!"
  },
  
  {
    "title": "Segment Tree",
    "url": "/posts/Segment-Tree/",
    "categories": "BOJ",
    "tags": "Segment Tree, 세그먼트트리",
    "date": "2022-06-18 00:00:00 +0900",
    "content": "백준 11505 구간 곱 구하기 문제풀이  [11505 구간 곱 구하기] https://www.acmicpc.net/problem/11505  .     segment tree를 이용하여 빠르게 구간 곱을 변경하고 출력한다.  문제상황 파악하기. [2042 구간 합 구하기] https://www.acmicpc.net/problem/2042  .  위 문제와 똑같지만 구간합이 구간 곱으로 변했다. 합과 거의 비슷하지만 주의해야할 부분이 몇개 있다.   먼저 구간 곱을 모두 구해 놓고 한다고 하면 구간 곱을 출력하는 것은 O(1)에 할 수 있지만,       구간 곱을 수정하는데에는 O(n)이 걸린다.  이를 해결하기 위해서 구간을 나눠서 구간의 곱을 미리 다 구해 놓고 수정 할 때 트리를 따라가며 해결하면 수정에 O(logN), 탐색(출력)에 O(logN)이 걸릴 것이다.  Segment Tree가 뭐길래? 먼저 쿼리 란    어떤 문제에 비슷한 형태의 질문이 여러 개 주어지는 것이다.   모든 쿼리에 대해 올바르게 답하면서 시간안에 해결하려면 쿼리를 어느 정도 미리 계산해 두면 좋다.  그래서 구간 별로 계산을 해두고 쿼리가 주어지면 필요한 부분만 뽑아서 계산하는 것에서 착안한 것이 Segment tree이다.   펜윅 트리(bit연산이용),index tree 등등 여러 종류가 있고 트리구조 답게 재귀를 사용하는 것이 직관적이다.    여기서는 트리를 채우는 init(), 트리의 어떤 수를 변경하는 update(), 트리의 구간 곱을 출력하는 query()함수로 segment tree를 구현했다.  아이디어 얻기. Segment Tree를 만들었으면 끝이다. 주어진 쿼리에 대해 계산하면 된다.  주의할 점 구간 합에 비해 주의 할 점이 몇개 생겼다.   구간 합은 그냥 0을 리턴하면 됐지만 구간 곱이기 때문에 1을 리턴해야한다.    또한 구간 곱이라서 update할 때 0으로 나누는 경우가 생기면 안된다.    0을 처리하는 부분이 중요하고 나는 init함수와 비슷한 형태로 update를 만들고 필요한 부분만 검사하는 식으로 구현했다.   메모리 초과를 피하기 위해서 ceil(log2(MAX))+1 을 높이로 tree의 크기를 설정했다.   int형으로 된다고 했지만 곱이기 때문에 중간에 int형이 넘어갈 까봐 long long으로 처리했다.  실제 코드  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; #define fast_io cin.tie(NULL);cout.tie(NULL);ios_base::sync_with_stdio(false); typedef long long ll;  const int MAX = 1000001; const int HEIGHT = 1&lt;&lt;((int)ceil(log2(MAX))+1); const int BIGNUM = 1000000007; int n, m, k; vector&lt;ll&gt; arr; vector&lt;ll&gt; tree;  ll init(ll node, ll S, ll E){     if(S==E){         return tree[node] = arr[S];     }     ll mid = (S+E)/2;     return tree[node] = (init(2*node, S, mid)*init(2*node+1, mid+1, E))%BIGNUM; }  ll update(ll x, ll node, ll S, ll E){     if(x&lt;S||x&gt;E) return tree[node];     if(S==E) return tree[node] = arr[x];     ll mid = (S+E)/2;     return tree[node] = (update(x, 2*node, S, mid)*update(x, 2*node+1, mid+1, E))%BIGNUM; }  ll query(ll L, ll R, ll node, ll S, ll E){     if(L&gt;E||R&lt;S) return 1;     if(S&gt;=L&amp;&amp;R&gt;=E) return tree[node];     ll mid = (S+E)/2;     return (query(L, R, 2*node, S, mid)*query(L, R, 2*node+1, mid+1, E))%BIGNUM; }  int main(){     fast_io;     cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;     arr = vector&lt;ll&gt; (MAX);     tree = vector&lt;ll&gt; (HEIGHT+1, 1);     for(int i=1;i&lt;=n;i++) cin &gt;&gt; arr[i];     init(1, 1, n);     for(int i=0;i&lt;m+k;i++){         ll a, b, c;         cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;         if(a==1){             arr[b] = c;             update(b, 1, 1, n);         }else{             cout &lt;&lt; query(b, c, 1, 1, n) &lt;&lt; '\\n';         }     } }"
  },
  
  {
    "title": "KMP의 Partial Match Table",
    "url": "/posts/KMP/",
    "categories": "BOJ",
    "tags": "KMP, 크누스모리스",
    "date": "2022-06-14 00:00:00 +0900",
    "content": "백준 1305 광고 문제풀이  [1305 광고] https://www.acmicpc.net/problem/1305  .     KMP알고리즘 base의 failure function을 이용해서 문제의 답을 구한다.  문제상황 파악하기. 광고 문구가 될 수 있는 것중 가장 짧은 광고문구를 찾는 문제이다 .  광고가 될수 있는 문구 1글자, 2글자, 3글자… 씩 늘려가며 이 문구가 광고가 될 수 있나 검사할 수도 있지만 이는 O(N^2)의 시간복잡도가 걸릴 것이다.   따라서 O(N)으로 작동하는 KMP(knuth-moris-pratt)알고리즘을 이용할 것이다.  KMP와 failure function이 뭐길래? 이는 문자열(hey)을 검사할 때 검사하려는 문자(needle)의 pattern을 파악해 모든 부분을 검사하지 않고 넘기면서 검사하는 알고리즘이다.  그리고 그 pattern을 파악하는 부분도 KMP를 이용하고 이는 partial match table이라고 부른다.  그리고 pi 테이블을 만드는 함수를 failure function이라고 부른다.   이는 다른 블로그에서 간단하게 구현하는 것들이 있지만 나는 KMP알고리즘과 비슷하게 종만북을 참고하여 작성했다.  아래 코드는 pi table을 얻는 failure function이다. vector&lt;int&gt; getPartialMatch(const string &amp;N){     int size = N.size();     vector&lt;int&gt; pi(L, 0);          int begin = 1, matched = 0;     while (begin+matched&lt;size) {         if(N[begin+matched]==N[matched]){             matched++;             pi[begin+matched-1] = matched;         }else{             if(matched==0) begin++;             else{                 begin += matched - pi[matched-1];                 matched = pi[matched-1];             }         }     }          return pi; }   아이디어 얻기. 사실 pi를 만들었으면 게임 끝이다.  광고판에 나온 글자들은 어찌됐든 광고 문구안에 포함되어있는 문자들이다.      위 그림을 보면 PI의 마지막 값만 중요하다는 것을 알아낼 수 있다.  그러면 패턴하나의 크기만 알아내면 되므로  광고판 사이즈 - 마지막 PI의 값 = 정답!!!  주의할 점 딱히 주의할 점은 없다.   PI 테이블만 잘 만들면 문제 없기 때문이다.  실제 코드  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;string&gt; using namespace std;  int L; vector&lt;int&gt; part; //pi를 만든다 vector&lt;int&gt; getPartialMatch(const string &amp;N){     int size = N.size();     vector&lt;int&gt; pi(L, 0);          int begin = 1, matched = 0;     while (begin+matched&lt;size) {         if(N[begin+matched]==N[matched]){             matched++;             pi[begin+matched-1] = matched;         }else{             if(matched==0) begin++;             else{                 begin += matched - pi[matched-1];                 matched = pi[matched-1];             }         }     }          return pi; }  int main(){     cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false);          cin &gt;&gt; L;     string str;     cin &gt;&gt; str;          part = getPartialMatch(str);     cout &lt;&lt; part.size()-part.back();    //tablesize - pi마지막값 }"
  },
  
  {
    "title": "Prim Algorithm optimazation",
    "url": "/posts/MST&Prim_Algorithm/",
    "categories": "BOJ",
    "tags": "MST, Prim",
    "date": "2022-06-12 00:00:00 +0900",
    "content": "백준 4386 별자리 만들기 문제풀이  [4386 별자리 만들기] https://www.acmicpc.net/problem/4386  .     간선을 추려서 MST(minimum spanning tree)를 만든다.  문제상황 파악하기. 정점들의 위치가 주어지고 이동은 어디든 할 수 있다 .  이동 할때 그 거리는 점과 점사이의 거리이다.     모든 별이 연결은 되어 있어야한다.  즉 후보 간선들을 만들고 모든 점을 포함하는 MST를 만들고 그 가중치들을 다 합하면 끝이다!  MST가 뭐길래? minimum spanning tree.        그래프는 여러가지 스패닝 트리를 만들 수 있는데 그중 가중치 합이 가장 작은 트리이다.  그래프의 연결성은 유지하고 가장 싼 그래프를 찾는 것이다.  이를 찾는 대표적인 알고리즘으로 Kruskal 알고리즘과, Prim알고리즘이 있다. 잘 알려진 구현방법으로 하면 Kruskal은 O(ElogE), Prim은 O(VE)이다.  오늘은 E가 약 10000까지 커질 수 있고 V는 최대 100이다. 둘 중 무엇을 써도 되지만 프림 알고리즘을 최적화하여 O(ElogV)로 문제를 풀어보겠다.  아이디어 얻기. 각 정점에서 간선은 V-1개만들 수 있다 이를 다 만들고 검사해도 시간안에 잘 통과 할 것이다.  getDist함수를 짜서 이를 이용해 간선을 만들어보자.  //거리를 구하는 함수 inline double getDist(pdd p1, pdd p2){  //함수 호출엔 시간이 오래걸리니 inline함수로 선언했다.     double temp = pow((p2.first-p1.first), 2)+pow(p2.second-p1.second, 2);     return sqrt(temp); } // 구한거리를 가중치로 하여 간선들 정보 저장하기    for(int i=0;i&lt;n;i++){   //각각 자신을 제외하고 n-1개의 간선을 갖는다. 간선 수의 최댓값은 10000         for(int j=0;j&lt;n;j++){             if(i==j) continue;             adj[i].push_back({getDist(stars[i], stars[j]),j});         }     }   주의할 점 실수 연산이므로 출력형식에 주의해야한다.  프림알고리즘을 최적화하는 과정이 다익스트라와 비슷하지만 다익스트라는 한 정점에서의 최단거리를 구하는 거라면  프림알고리즘은 각 정점에서 최단거리만 뽑아서 검사하는 것이다.   매우 비슷하게 생겨서 주의를 해야한다  실제 코드  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;queue&gt; using namespace std; typedef pair&lt;double, double&gt; pdd; typedef pair&lt;double, int&gt; pdi; const int INF = 987654321; int n; vector&lt;pdd&gt; stars; vector&lt;pdi&gt; adj[101];    //가중치가 있는 인접리스트  inline double getDist(pdd p1, pdd p2){     double temp = pow((p2.first-p1.first), 2)+pow(p2.second-p1.second, 2);     return sqrt(temp); }  double prim(){     vector&lt;bool&gt; intree(n, false);     vector&lt;double&gt; minweight(n, INF);     double ret = 0;     minweight[0] = 0;     priority_queue&lt;pdi, vector&lt;pdi&gt;, greater&lt;pdi&gt; &gt; pq;     pq.push({0, 0});          while (!pq.empty()) {         int here = pq.top().second;         double weight = pq.top().first;         pq.pop();         if(intree[here]) continue;         intree[here] = true;         ret += weight;                  for(int i=0;i&lt;adj[here].size();i++){             int there = adj[here][i].second;             double togo = adj[here][i].first;             if(!intree[there]&amp;&amp;minweight[there]&gt;togo){                 minweight[there]= togo;                 pq.push({minweight[there], there});             }         }              }     return ret; }  int main(){     cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false);     cin &gt;&gt; n;     for(int i=0;i&lt;n;i++){         double y, x;         cin &gt;&gt; y &gt;&gt; x;         stars.push_back({y,x});     }          for(int i=0;i&lt;n;i++){   //각각 자신을 제외하고 n-1개의 간선을 갖는다. 간선 수의 최댓값은 10000         for(int j=0;j&lt;n;j++){             if(i==j) continue;             adj[i].push_back({getDist(stars[i], stars[j]),j});         }     }          cout &lt;&lt; fixed;     cout.precision(2);     cout &lt;&lt; prim();      }"
  },
  
  {
    "title": "Disjoint Set",
    "url": "/posts/DisjointSet/",
    "categories": "BOJ",
    "tags": "Disjoint Set",
    "date": "2022-06-12 00:00:00 +0900",
    "content": "백준 4803 트리  [4803 트리] https://www.acmicpc.net/problem/4803  .     상호 배타적 집합(disjoint set)을 이용하여 트리인지 아닌지 판단한다.  문제상황 파악하기. 정점을 잇는 간선이 주어진다 .  이 그래프는 서로 떨어져있는 그래프일 수도 있고 사이클이 있을 수도 있다.  즉 떨어져 있는 그래프 하나 하나가 트리인지 아닌지 확인하고 그 개수를 세는 것이다! 트리의 특징으로는 정점이 V면 간선의 개수는 v-1이고, 사이클이 없다는 것이다.  Disjoint Set이 뭐길래? 집합을 다루는 자료구조이다.     각 집합마다 부모가 하나 있다고 하고 이를 트리 구조로 정리하는 것이 disjoint set이다.  이 문제에서는 merge부분을 조금 변형하여 disjoint set을 구현했다.  disjoint set기본 자체는 종만북 : 알고리즘 문제해결 전략을 참고하였다. struct disjointSet{     vector&lt;int&gt; parent,rank;     disjointSet(int n):parent(n+1), rank(n+1, 1){         for(int i=1;i&lt;=n;i++) parent[i] = i;     }     int find(int u){         if(parent[u]==u) return u;         return parent[u] = find(parent[u]);     }     void merge(int u, int v){         u = find(u);         v = find(v);         if(u==v){             tominus[v] = 1;             return;         }                  if(tominus[u]&amp;&amp;tominus[v]) tominus[u] = 0;         if(rank[u]&gt;rank[v]) swap(u,v);         parent[u] = v;         rank[v] += rank[u];         rank[u] = 0;     } };   아이디어 얻기. 사이클이 있는 것도 세어주되 나중에 빼주기 위해서 위에 있는 tominus 배열을 만들었다.  연결되어있는 그래프의 개수를 모두 세고 그중에 tominus(사이클이 있는 그래프)를 빼준다는 느낌이다.  주의할 점 하지만 문제가 생겼다!! 사이클이 있는 두 개의 집합을 합칠 때 tominus가 각각 1이라서 총 2번 빠지는 문제가 생겼다.  이는 둘다 tominus가 1인것을 합칠 때 하나를 0으로 만들어 줌으로써 해결했다.  반례를 만들었으니 참고 하면 좋을것 같다.   9 13  1 2  2 3  3 4  1 5  2 5  3 5  4 5  6 7  7 8  8 9   6 9   7 9   4 6  0 0 답은 no tree여야하는데 나는 tree값이 음수가 되어버려 이상한것을 출력했다..  실제 코드  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  vector&lt;int&gt; tominus;  struct disjointSet{     vector&lt;int&gt; parent,rank;     disjointSet(int n):parent(n+1), rank(n+1, 1){         for(int i=1;i&lt;=n;i++) parent[i] = i;     }     int find(int u){         if(parent[u]==u) return u;         return parent[u] = find(parent[u]);     }     void merge(int u, int v){         u = find(u);         v = find(v);         if(u==v){             tominus[v] = 1;             return;         }                  if(tominus[u]&amp;&amp;tominus[v]) tominus[u] = 0;         if(rank[u]&gt;rank[v]) swap(u,v);         parent[u] = v;         rank[v] += rank[u];         rank[u] = 0;     } }; int main(){     cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false);     int tc=0;     while (1){         tc++;         int n, m;         cin &gt;&gt; n &gt;&gt; m;         if(n==0&amp;&amp;m==0) break;         tominus = vector&lt;int&gt; (n+1,0);         disjointSet dset(n);         int trees = 0;         for(int i=0;i&lt;m;i++){             int a,b;             cin &gt;&gt; a &gt;&gt; b;             dset.merge(a,b);         }         for(int i=1;i&lt;=n;i++){             if(dset.rank[i]&gt;0) trees++;             trees -= tominus[i];         }         if(trees==0) cout &lt;&lt; \"Case \" &lt;&lt; tc &lt;&lt; \": No trees.\" &lt;&lt; '\\n';         else if(trees==1) cout &lt;&lt; \"Case \" &lt;&lt; tc &lt;&lt; \": There is one tree.\" &lt;&lt; '\\n';         else cout &lt;&lt; \"Case \" &lt;&lt; tc &lt;&lt; \": A forest of \" &lt;&lt; trees &lt;&lt; \" trees.\" &lt;&lt; '\\n';     }      }"
  },
  
  {
    "title": "BFS",
    "url": "/posts/BFS-%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC(%EB%B0%B1%EC%A4%80-2206-%EB%B2%BD-%EB%B6%80%EC%88%98%EA%B3%A0-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0)/",
    "categories": "BOJ",
    "tags": "",
    "date": "2022-04-27 00:00:00 +0900",
    "content": "백준 2206 벽 부수고 이동하기 문제풀이  [2206 벽 부수고 이동하기] https://www.acmicpc.net/problem/2206 .    BFS로 최단거리를 탐색한다.  문제상황 파악하기. 전형적인 그래프 탐색 문제처럼 보인다.  최단거리를 구해야하므로 DFS가 아닌 * BFS(너비우선 탐색) 으로 풀어야한다.  문제는 벽을 한번만 부술수 있다는 것, 그리고 마지막까지 못갈 수도 있다는 점을 파악하고 문제를 풀어보자!  BFS가 뭐길래? 최단거리 문제이기에 BFS로 접근했는데 BFS(Breadth First Search)가 무엇이길래 최단거리르 구할 수 있을까?  BFS는 한 정점에서 가까운 곳부터 순서대로 방문하는 알고리즘이다.  예시는 아래 그림과 같다.    그렇다면 큐를 이용해서 BFS를 구현하고 문제를 풀어보자!  아이디어 얻기. 나는 벽을 부수는 것을 캐릭터가 한다고 생각해서 Player Class를 만들었다. class Player{ public:     int item=1; //벽 부수는 아이템     int y, x;   //위치 };  그리고 이 플레이어들을 queue에 넣어주면 풀 수 있을 거라 생각했다.  왜냐하면 이 플레이어들은 각각 독립되어 있다고 생각했기 때문이다.  주의할 점 하지만 문제가 생겼다!! 플레이어들이 각각 독립적이라 생각했지만 방문처리는 동시에 하는 문제가 있었다.  ** 즉, 벽을 안부수고 간 player가 갔던 자리를 벽을 부수고 간 다른 player가 방문을 안하는 문제가 생긴것이다.  아이고…그러니깐 이문제는 벽을 부수고 간 자리인지 아닌지에 따라 방문처리를 해야하는 것이다.  고생한 반례 하나 뿌리고 가겠다.  3 6   010000   010111   000110   ans : 12  **현재 상태를 정점을 만들고 방문처리를 한다.  마지막에 어떤 값이 최소값인지 판단해야하므로 벽을 뚫고 간것 안뚫고 간것을 모두 비교해서 출력해주는 것도 필요하다.  실제 코드 player가 item을 보유하고 있는가 아닌가에 따라 현재 상태를 분류했다.  게임을 좋아하는 나에겐 이 편이 더 직관적이였기 때문이다. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;algorithm&gt;  using namespace std;  const int dx[] = {-1,0,0,1}; const int dy[] = {0,-1,1,0};  class Player{ public:     int item=1; //벽 부수는 아이템     int y, x;   //위치 };  int n,m; vector&lt;vector&lt;int&gt;&gt; map; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dist;  void bfs(){     Player start;     start.y = 0; start.x = 0;          queue&lt;Player&gt; q;     q.push(start);     dist[start.y][start.x][1] = 1;          while (!q.empty()) {         Player here = q.front();         q.pop();                  for(int i=0;i&lt;4;i++){             if(here.y+dy[i]&gt;=0&amp;&amp;here.y+dy[i]&lt;map.size()&amp;&amp;here.x+dx[i]&gt;=0&amp;&amp;here.x+dx[i]&lt;map[0].size()){                 Player p;                 p.y = here.y+dy[i]; p.x = here.x +dx[i]; p.item = here.item;                 if(map[p.y][p.x]==0&amp;&amp;dist[p.y][p.x][p.item]==-1){                     q.push(p);                     dist[p.y][p.x][p.item] = dist[here.y][here.x][here.item]+1;                 }else if(map[p.y][p.x]==1&amp;&amp;dist[p.y][p.x][p.item]==-1&amp;&amp;p.item){                     p.item--;                     dist[p.y][p.x][p.item] = dist[here.y][here.x][here.item]+1;                     q.push(p);                 }             }         }     } }  int main(){     cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false);          cin &gt;&gt; n &gt;&gt; m;          map = vector&lt;vector&lt;int&gt;&gt; (n, vector&lt;int&gt;(m));     dist = vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; (n, vector&lt;vector&lt;int&gt;&gt; (m,vector&lt;int&gt; (2,-1)));     for(int i=0;i&lt;n;i++){         for(int j=0;j&lt;m;j++){             char ch;             cin &gt;&gt; ch;             map[i][j] = ch-'0';         }     }          bfs();     if(dist[n-1][m-1][1]!=-1&amp;&amp;dist[n-1][m-1][0]!=-1) cout &lt;&lt; min(dist[n-1][m-1][1],dist[n-1][m-1][0]);     else if(dist[n-1][m-1][1]!=-1) cout &lt;&lt; dist[n-1][m-1][1];     else if(dist[n-1][m-1][0]!=-1) cout &lt;&lt; dist[n-1][m-1][0];     else cout &lt;&lt; dist[n-1][m-1][0]; }"
  },
  
  {
    "title": "기하",
    "url": "/posts/%EB%8B%A4%EA%B0%81%ED%98%95%EC%9D%98-%EB%A9%B4%EC%A0%81(%EB%B0%B1%EC%A4%80-2166-%EB%8B%A4%EA%B0%81%ED%98%95%EC%9D%98-%EB%A9%B4%EC%A0%81-)/",
    "categories": "BOJ",
    "tags": "",
    "date": "2022-04-23 00:00:00 +0900",
    "content": "백준 2166 다각형의 면적 문제풀이  [2166 다각형의 면적] https://www.acmicpc.net/problem/2166 .    신발끈 공식을 이용하여 다각형의 면적을 구해보자  문제상황 파악하기. 점들로 구성된 다각형의 넓이를 구하는 문제로 신발끈 공식을 이용하여 구할 수 있다.  점의 최대 좌표는 100000이고 그렇다면 면적을 구할 때 int형을 사용하면 overflow가 나온다.  따라서 면적 구하는 과정에서 long long형을 사용하고 마지막에 나누기 연산을 하고 나서는 double형을 사용하겠다.  아이디어 얻기. 신발끈 공식은 아래 사진과 같다.   이 공식은 오목다각형과 볼록 다각형 모두 성립하므로 사용해도 좋다.  주의할 점 문제는 self-intersect한 다각형에서는 신발끈 공식이 성립하지 않는다는 것이다.   self-intersect인 다각형의 예시는 아래와 같다.  4점 안에서 교차하는 경우인 것이다. 이런경우 다각형이 2개 이상 생겨버려 신발끈 공식을 쓰면 넓이가 상쇄되곤 한다.   알아보니 이 문제는 simple polygon(단순 다각형)만 테스트케이스에 주어지는듯 하다.  찝찝하지만 골드5문제인데 self-intersect까지 쓰기 뭐해서 그냥 제출했다.  나는 틀렸습니다를 하나 받았는데 그 이유는 배열 마지막에 처음 좌표를 넣어두고(계산의 편의를 위함) 그걸 신경쓰지 않고 계산했기 때문이다.  실제 코드 pair를 이용하여 좌표를 나타냈고. 가장 중요한것은 calculateArea 함수의 for문에서 i를 vec 사이즈보다 하나 덜 연산하는 것이다. 왜냐하면 처음에 배열에 마지막원소에 처음원소를 추가했기 때문이다.(신발끈 공식이용의 편의를 위해) #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;utility&gt; #include &lt;cmath&gt;  using namespace std;  typedef long long ll;  double calculateArea(vector&lt;pair&lt;ll, ll&gt;&gt; &amp;vec){     double ret =0;     for(int i=0;i&lt;vec.size()-1;i++){         ret += vec[i].first*vec[i+1].second - vec[i+1].first*vec[i].second;     }     return abs(ret)/2.0; }  int main(){     cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false);          int n;     cin &gt;&gt; n;          vector&lt;pair&lt;ll, ll&gt;&gt; points(n+1);     for(int i=0;i&lt;n;i++){         cin &gt;&gt; points[i].first &gt;&gt; points[i].second;     }     points[n].first = points[0].first;     points[n].second = points[0].second;          cout &lt;&lt; fixed;     cout.precision(1);     cout &lt;&lt; calculateArea(points); }"
  },
  
  {
    "title": "이분탐색",
    "url": "/posts/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89(%EB%B0%B1%EC%A4%80-12015-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B42)/",
    "categories": "BOJ",
    "tags": "",
    "date": "2022-04-20 00:00:00 +0900",
    "content": "백준 12015 가장 긴 증가하는 부분 수열2 문제풀이  12015 가장 긴 증가하는 부분 수열2.  DP의 대표적인 문제인 LIS의 시간 복잡도를 줄여보자  문제상황 파악하기. 이 문제는 가장 긴 증가하는 부분 수열1 보다 N이 1000배 정도 늘어났다.  따라서 같은 방법으로 풀면 TLE(Time Limit Exceeded)를 받게 된다. 그러면 시간 복잡도를 O(NlogN)까지 줄여서 풀어야한다.    그 때 이분탐색의 아이디어를 얻게 된다.  거기까지 알 수 있었는데 과연 이제 어떻게 이분탐색으로 풀어야할까?  아이디어 얻기. 이분탐색을 하려면 정렬이 되어있는 자료여야한다.  그렇다면 어떤 자료를 정렬하여 쓸 수 있는지 확인해보자! 먼저 수열 그 자체는 정렬하면 의미가 퇴색되므로 정렬할 수 없다.  하지만 찾고 있느 증가하는 부분수열은 정렬되어있다!  이 아이디어를 끌고 나가보았는데 쉽지만은 않았다.   그래서 게시판 질문들을 참고했는데 증가하는 부분수열의 요소으 값은 무시하고 배열의 길이만 찾는것을 확인 할 수 있었다.    그렇다면 이분탐색을 이용해 가장 긴 수열의 길이를 찾아보자    대체가 가능한 이유는 더 길어지면 그것이 제일 긴 수열이 되는거고 넘어가지 않으면 이전 것이 최대가 되는것이기 때문이다.  주의할 점 나는 구현을 하다가 InvalidNextSize\tfree(): invalid next size 를 만났다. 동적배열을 free시켜주는 과정에서 문제가 발생한 것이다. 또한 이분탐색 구현 중 맨처음 넣어둔 매우 작은 수가 대체되는 경우가 생겨 틀리는 경우가 생겼다.  이분 탐색 구현의 경게값을 확인하며 off-by-one Error를 조심하자.  실제코드 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt;  using namespace std;  vector&lt;int&gt; arr;        //입력받는 수열 vector&lt;int&gt; nowlongest; //가장긴 부분수열의 길이를 구하기 위한 배열  int main(){     cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false);          int n;     cin &gt;&gt; n;          for(int i=0;i&lt;n;i++){         int num;         cin &gt;&gt; num;         arr.push_back(num);     }          nowlongest.push_back(-987654321);   //충분히 작은값을 넣어준다.          for(int i=0;i&lt;n;i++){         if(nowlongest.back()&lt;arr[i]){             nowlongest.push_back(arr[i]);         }else{             int lo=0,hi= nowlongest.size();             while (lo+1&lt;hi) {                 int mid = (lo+hi)/2;                                  if(nowlongest[mid]&gt;=arr[i]) hi = mid;                 else lo = mid;             }                          nowlongest[hi] = arr[i];         }     }          cout &lt;&lt; nowlongest.size()-1; }"
  },
  
  {
    "title": "누적 합",
    "url": "/posts/%EB%88%84%EC%A0%81%ED%95%A9(%EB%B0%B1%EC%A4%80-10986-%EB%82%98%EB%A8%B8%EC%A7%80-%ED%95%A9)/",
    "categories": "BOJ",
    "tags": "",
    "date": "2022-04-19 00:00:00 +0900",
    "content": "백준 10986 나머지합 문제풀이  굉장히 오랜만에 블로그로 돌아왔다. 폐관수련 중이였다.   백준티어도 골드2정도로 올렸고 여러가지 자료구조들과 알고리즘들을 익혔다.  이제 본격적으로 포스팅도 해가며 공부를 할 계획이다.    이제 백준 플레티넘과 코드포스 블루를 향해 달려보도록 하겠다.  이후에 고수가 된다면 공부방법도 포스팅해봐야지    그 시작으로 누적합관련 문제..  백준 10986 나머지 합을 풀어보도록 하자 10986 나머지 합.  문제상황 파악하기.  나머지 연산(moduler 연산)에 관련되어있고 누적합을 이용하여 시간 복잡도를 줄여야한다.  for문을 두번 써서 계산하면 O(N^2)의 시간 복잡도를 가지는데 N이 최대 1000000이므로 이문제는 O(N)으로 풀어야한다.   그러면 자연스럽게 누적합을 써야겠단 생각이든다.  아이디어 얻기.    (A+B)mod m = A mod m + B mod m. (A-B)mod m = A mod m - B mod m moduler연산에서 성립한다.   그러므로 모든 누적합들을 미리 m으로 나누어둬도 상관없다.  그러면 누적합을 구하고 맨 같은 수가 몇개인지 센후 이항계수를 다 더해주면 정답이 될것이다.   주의할 점. 그렇다면 정답의 최댓값은 무엇이 될까    이항계수 binomal(1000001,2)가 최대가 될것이고 이 값은 int범위를 넘어간다.  그러니 답은 long long 형으로 해주기로 하자. 하지만 연산 과정에 int가 있으면 int로 바꾸니 모든 변수를 long long으로 바꿔주겠다.  실제 코드.  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cmath&gt;  using namespace std;  long long cumsum[1000001];    //누적합 저장 long long modrlt[1001];   // 나머지가 몇개인지 카운트  int main(){     cin.tie(NULL);     cout.tie(NULL);     ios_base::sync_with_stdio(false);          int n,m;     cin &gt;&gt; n &gt;&gt; m;          cumsum[0] = 0;     modrlt[0]++;     for(int i=1;i&lt;=n;i++){         long long num;         cin &gt;&gt; num;         cumsum[i] = cumsum[i-1] + num;         modrlt[cumsum[i]%m]++;     }          long long result=0;     for(int i=0;i&lt;1001;i++){         result += modrlt[i]*(modrlt[i]-1)/2;     }          cout &lt;&lt; result; }"
  },
  
  {
    "title": "Stack",
    "url": "/posts/stack/",
    "categories": "BOJ",
    "tags": "",
    "date": "2022-02-25 00:00:00 +0900",
    "content": "스택 구현하기   ==========  자료구조의 기본이라고 하면 스택 과 큐가 있다 백준 10828번에서 마주친 스택  #include  헤더 파일을 쓰느 방법도 있지만 문제가 문제인지라 직접 구현을 해보기로했다.  # Class로 나의 스택 구현하기    class myStack{ public:     int current=-1;     int stack[10001];          void push(int num)     {         stack[++current] = num;     }     void pop(void)     {         if(current==-1)         {             cout &lt;&lt; -1 &lt;&lt;endl;         }         else         {             cout &lt;&lt; stack[current]&lt;&lt;endl;             stack[current] = NULL;             current--;         }     }     void size(void)     {         cout &lt;&lt; current+1 &lt;&lt; endl;     }     void empty(void)     {         if(current == -1)         {             cout &lt;&lt; 1 &lt;&lt; endl;         }         else cout &lt;&lt; 0 &lt;&lt;endl;     }     void top(void)     {         if(current ==-1)         {             cout &lt;&lt; -1 &lt;&lt; endl;         }         else         {             cout &lt;&lt; stack[current] &lt;&lt;endl;         }     } };  myStack 클래스에는 현재 위치를 저장하는 변수  current와 스택을 표현하는 배열 stack이 있다. 변수를 집어넣으면 현재위치가 늘어나고 아무것도 없을 땐 현재위치를 -1로 저장했다.  #직접테스트 해보기    int main() {     int order;     cin &gt;&gt; order;          myStack s1;     for(int i=0;i&lt;order;i++)     {         string str;         cin &gt;&gt; str;                  if(str == \"push\")         {             int num;             cin &gt;&gt; num;                          s1.push(num);         }         else if(str == \"pop\")         {             s1.pop();         }         else if(str == \"size\")         {             s1.size();         }         else if(str == \"empty\")         {             s1.empty();         }         else if(str == \"top\")         {             s1.top();         }     } }   문자열을 string변수에 입력받아서 비교하고 각 경우마다 함수를 호출하는 식으로 구현하였다.   다음에는 큐도 구현해봐야징"
  },
  
  {
    "title": "정렬1",
    "url": "/posts/Sorting1/",
    "categories": "BOJ",
    "tags": "",
    "date": "2022-02-22 00:00:00 +0900",
    "content": "매우매우 많은 정렬이 있지만 그중 가장 안 어려운 3가지를 공부해보았다.  버블정렬 / 선택정렬 / 삽입정렬  모두 시간복잡도는 O(n^2)이다.  단순히 생각하면 for문을 두번 쓰기 때문이다.  # Swap 구현하기   void swap(int *ptr1, int *ptr2)   {       int temp;       temp = *ptr1;       *ptr1 = *ptr2;       *ptr2 = temp;   }  버블정렬 / 선택정렬 / 삽입정렬 모두 배열에서 자리를 바꾸는 행위를 해야한다.  Swap함수는 int형 변수의 주소를 2개 받아 그 주소에 변수를 바꿔서 넣는 것으로 구현했다.  문제 상황은 n개의 수를 입력받아서 arr[]배열에 넣어둔 후 부터 시작이다.  n개의 수는 중복되지 않는다 자세한 내용은 백준 2750번 문제를 참고하자  # 버블정렬 구현하기     for(int i=0;i&lt;n;i++)    {        for(int j=0;j&lt;n-1-i;j++)        {            if(arr[j]&gt;arr[j+1])            {                swap(arr+j, arr+(j+1));            }        }    }  버블정렬은 {1번,2번} {2번,3번} … 이런식으로 비교해 나가며 큰수를 밀어내는 방식이다  그러면 마지막 수는 제일 큰수가 가게 되고 다음 반복할때는 마지막 배열-1 까지 for문을 실행하게 된다.  # 선택정렬 구현하기     int min;    int *ptr1;    for(int i=0;i&lt;n;i++)    {        min = arr[i];        ptr1 = &amp;arr[i];        for(int j=i;j&lt;n;j++)        {            if(arr[j]&lt;min)            {                min = arr[j];                ptr1 = &amp;arr[j];            }        }        swap(arr+i, ptr1);    }  선택정렬은 처음부터 끝까지 최소값 찾고 그 최소값을 제일 앞에 두는 방식이다  그러면 다음에 반복할 때는 두번째 부터 최소값을 찾기 시작한다.  # 삽입정렬 구현하기     for(int i=1; i&lt;n;i++)    {        for(int j=i;j&gt;0;j--)        {            if(arr[j]&lt;arr[j-1])            {                swap(arr +j, arr+(j-1));            }            else break;        }    }  삽입정렬은 자기 왼쪽에 자기보다 큰수가 있다면 자리를 바꾸는 방식이다.  2번 자리 부터 시작해서 왼쪽의 수들을 정렬하는 식으로 구현했다."
  }
  
]




<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>도사였다 블로그</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2026-02-20T10:56:21+09:00</updated>
  <author>
    <name>Han Seungjun</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="ko"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2026 Han Seungjun </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>문자열 - 아호 코라식(Aho-Corasick)</title>
    <link href="http://localhost:4000/posts/aho-corasick/" rel="alternate" type="text/html" title="문자열 - 아호 코라식(Aho-Corasick)" />
    <published>2024-07-17T00:00:00+09:00</published>
  
    <updated>2024-07-17T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/aho-corasick/</id>
    <content type="text/html" src="http://localhost:4000/posts/aho-corasick/" />
    <author>
      <name>Han Seungjun</name>
    </author>

  
    
    <category term="BOJ" />
    
  

  <summary>아호 코라식(Aho-Corasick)에 대해 알아보자.  개요 문자열 알고리즘은 어렵다.  트라이 부터 조금 어려워지다가 KMP의 failure function, 접미사 배열 등이 나오면서 대가리가 깨진다.  하나씩 차근차근 정리를 해보려고 한다.  지금 클래스 8을 풀다가 문자열 집합 판결이라는 문제에서 막혔는데 태그를 까보니 아호 코라식이 써 있었다. 이 문제를 계기로 아호 코라식을 정리해 보겠다.  언제 쓰지? 일단 KMP같은 경우엔 Hay(건초)에서 Needle(바늘)이 몇 개, 어디에 있는지 찾을 수 있다.  인터넷에서 ctrl + f를 누르고 어떤 패턴의 문자열을 찾는 식이다.  그니깐, 하나의 패턴만 찾을 수 있다는 것이다.  그럼 어떤 큰 문자열에 dosa, was, hi 등의 문자열이 ...</summary>

  </entry>

  
  <entry>
    <title>docker 이해해보기</title>
    <link href="http://localhost:4000/posts/docker-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="docker 이해해보기" />
    <published>2024-06-12T00:00:00+09:00</published>
  
    <updated>2024-07-17T17:04:48+09:00</updated>
  
    <id>http://localhost:4000/posts/docker-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</id>
    <content type="text/html" src="http://localhost:4000/posts/docker-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/" />
    <author>
      <name>Han Seungjun</name>
    </author>

  
    
    <category term="CS" />
    
  

  <summary>docker를 이해해보자  프로젝트를 제대로 배포해보지 않은 입장에서 docker는 뭔가 개념자체가 잘 와닿지 않았다.  그래서 직접 정리를 하며 docker, k8s, jenkins에 대해 각각 한페이지짜리 정리를 해보려한다.  개요 일단 내가 어떤 Web Service를 개발했는데, 이것이 누군가의 환경에서는 동작하지 않을 수가 있다. 이는 여러 이유가 있겠지만, 한마디로 dependencies가 달라서라고 할 수 있다.  매우 쉬운 예시로, 파이썬으로 Hello world를 출력하는 프로그램을 만들었는데 다른 컴퓨터에서 실행하려니 파이썬이 안깔려있는 상황인 것이다.     개발환경과 운영환경의 불일치가 있고   매우 가벼운 실행 패키지가 필요해졌다.   그래서 등장한 것이 Containerizat...</summary>

  </entry>

  
  <entry>
    <title>염소줄서기 문제 풀이</title>
    <link href="http://localhost:4000/posts/2060-%EC%97%BC%EC%86%8C%EC%A4%84%EC%84%9C%EA%B8%B0-%ED%92%80%EC%9D%B4/" rel="alternate" type="text/html" title="염소줄서기 문제 풀이" />
    <published>2024-04-20T00:00:00+09:00</published>
  
    <updated>2024-04-20T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/2060-%EC%97%BC%EC%86%8C%EC%A4%84%EC%84%9C%EA%B8%B0-%ED%92%80%EC%9D%B4/</id>
    <content type="text/html" src="http://localhost:4000/posts/2060-%EC%97%BC%EC%86%8C%EC%A4%84%EC%84%9C%EA%B8%B0-%ED%92%80%EC%9D%B4/" />
    <author>
      <name>Han Seungjun</name>
    </author>

  
    
    <category term="BOJ" />
    
  

  <summary>2060 염소줄서기 풀이 및 코드  개요 오랜만에 다이아 문제 풀이를 써보려고 한다.  이 문제는 내가 옛날에 북마크 해뒀던 문젠데 북마크에서 거의 1년간 썩어가고 있어서 속상해서 선택했다.  문제 이해가 어렵지 않아서 선택한 것도 있다.  다이아 문제를 하루에 하나씩 풀면 엄청난 도움이 되겠지만 블로그 풀이를 안보면 하루에 하나는 무슨 일주일에 하나도 힘들것이다. 그래도 1일 1플레는 도전을 해봐야겠다.  문제 이해 염소들 번호가 있는데 밥먹는 순서는 다음과 같다. 염소번호를 이진수로 나타냈을 때    1의 개수가 적을 수록 먼저먹는다.   1의 개수가 같다면 그냥 이진수 크기가 더 작은 염소가 먼저 먹는다.   이진수로 A부터 B까지의 염소가 있을 때, k번째 밥을 먹는 염소는 몇 번 친구인가?  ...</summary>

  </entry>

  
  <entry>
    <title>D&amp;C Optimization</title>
    <link href="http://localhost:4000/posts/%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%B5%9C%EC%A0%81%ED%99%94(Divide-&amp;-Conquer-Optimization)/" rel="alternate" type="text/html" title="D&amp;amp;C Optimization" />
    <published>2024-04-08T00:00:00+09:00</published>
  
    <updated>2024-04-08T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%B5%9C%EC%A0%81%ED%99%94(Divide-&amp;-Conquer-Optimization)/</id>
    <content type="text/html" src="http://localhost:4000/posts/%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%B5%9C%EC%A0%81%ED%99%94(Divide-&amp;-Conquer-Optimization)/" />
    <author>
      <name>Han Seungjun</name>
    </author>

  
    
    <category term="BOJ" />
    
  

  <summary>분할정복을 이용한 다이나믹 프로그래밍 최적화  목적과 조건  목적     $O(KN^2)$ 의 알고리즘을 $O(KNlogN)$으로 시간복잡도를 줄이기 위함   조건  1. DP 점화식 $dp[i][j] = min_{k&amp;lt;i}(dp[i-1][k] + C[k][j])$ 2. C의 조건 $C[i][j]$ 는 Monge array이거나 최적해의 단조성이 있어야한다. Monge array $C[a][b] + C[b][d] \leq C[a][d] + C[b][c]$  인 배열이라는 뜻이다. $C[i][j]$ 를 $i, j$  사이에서의 비용이라고 하면 구간을 포함하면 더 비싼 배열이라고 보면 된다. (최솟값인지 최댓값인지에 따라 부등호 방향이 바뀜) 최적해의 단조성은 임의의 $c &amp;lt; d$ 에 대해 $dp...</summary>

  </entry>

  
  <entry>
    <title>코드포스 - 다시 맘 잡기</title>
    <link href="http://localhost:4000/posts/Codeforces-Round-936(Div.2)/" rel="alternate" type="text/html" title="코드포스 - 다시 맘 잡기" />
    <published>2024-03-22T00:00:00+09:00</published>
  
    <updated>2024-03-30T17:27:17+09:00</updated>
  
    <id>http://localhost:4000/posts/Codeforces-Round-936(Div.2)/</id>
    <content type="text/html" src="http://localhost:4000/posts/Codeforces-Round-936(Div.2)/" />
    <author>
      <name>Han Seungjun</name>
    </author>

  
    
    <category term="Codeforces" />
    
  

  <summary>코드포스 다시 열심히! 블로그도 열심히!  개요 본케도 블루에 올려놨지만 맨날 민트로 다시 떨어진다. 항상 잘보면 1700언저리 못보면 1500 정도 나와서 딱 민트 상위 블루 하위가 지금 나의 퍼포먼스라고 생각하면 될 듯하다. 하지만 나는 더 잘하고 싶다. 지금까지 귀찮아서 버추얼과 업솔빙을 소홀히 했는데 지금이라도 열심히 해보려한다. 목표는 정규라운드를 포함하여 일주일에 꼭 2번은 대회를 치고 업솔빙까지 블로그에 쓰는 식으로 해보려고 한다. 내가 퍼플에 가는 그 날까지 블로그에는 코드포스 관련 글만 올릴 듯 싶다. 오늘 대회는 2솔을 했다. 너무 슬프다 ㅠㅠ 하지만 내실력인걸 어떡하겠나…열심히해야지  A. Median of an Array 배열의 원소에 1을 더하는 연산을 할 수 있다.  이 때, ...</summary>

  </entry>

</feed>



---
layout: posts
categories: ["BOJ"]
title:  "í–‰ë ¬ ê±°ë“­ì œê³±"
tags : [í–‰ë ¬ê±°ë“­ì œê³±, matrix]
use_math : true
---

# í–‰ë ¬ ê±°ë“­ ì œê³±

<aside>
ğŸ’¡ DP ì í™”ì‹ì´ ì„ í˜• ë°©ì •ì‹ì¸ ê²½ìš°

</aside>

$
a_n = \sum_{k=1}^{m}{c_k*a_{n-k}}
$

ìœ„ì™€ ê°™ì€ í˜•íƒœì˜ ì í™”ì‹ì¼ ë•Œ $O(m^3log(n))$ ì— në²ˆì§¸ í•­ì„ êµ¬í•  ìˆ˜ ìˆë‹¤. 

## ë¶„í• ì •ë³µì„ ì´ìš©í•œ í–‰ë ¬ ê±°ë“­ì œê³± $O(log(n))$

ì˜ˆë¥¼ ë“¤ì–´ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ ìƒê°í•´ë³´ì

$$ \begin{bmatrix}
F_2 \\
F_1
\end{bmatrix} = \begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix} \begin{bmatrix}
F_1 \\
F_0
\end{bmatrix}, \begin{bmatrix}
F_3 \\
F_2
\end{bmatrix} = {\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}}^2\begin{bmatrix}
F_2 \\
F_1
\end{bmatrix} \dots $$


$$
\begin{bmatrix}
F_n \\
F_{n-1}
\end{bmatrix} = {\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}}^{n-1}\begin{bmatrix}
F_{n-1} \\
F_{n-2}
\end{bmatrix}
$$

ì´ë ‡ê²Œ ì •ë¦¬í•  ìˆ˜ ìˆë‹¤. 

## ê·¸ë˜í”„ì˜ ì´ë™ ê²½ë¡œ ê²½ìš°ì˜ ìˆ˜

$$
ADJ= \begin{bmatrix}
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0\end{bmatrix}
$$

ì¸ì ‘ í–‰ë ¬ì´ ì´ëŸ° ì‹ìœ¼ë¡œ ë˜ì–´ ìˆë‹¤ë©´ ì‚¼ê°í˜•ì„ ë– ì˜¬ë¦´ ìˆ˜ ìˆë‹¤. 

$$
{\begin{bmatrix}
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0\end{bmatrix}}^2 =  \begin{bmatrix}
2 & 1 & 1 \\
1 & 2 & 1 \\
1 & 1 & 2\end{bmatrix}
$$

ì œê³± í•œ ê²°ê³¼ëŠ” 2ë²ˆ ì´ë™í–ˆì„ ë•Œ 1ë²ˆ ì •ì ì— ë‹¤ì‹œ ëŒì•„ ì˜¤ëŠ” ê²½ìš°ëŠ” 2ê°œ, 1â†’2ëŠ” 1ê°€ì§€, 1â†’3ì€ 1ê°€ì§€ ì´ëŸ°ì‹ì´ë‹¤. 

3ë²ˆ ì´ë™í•œ ê²°ê³¼ëŠ” ì–´ë–»ê²Œ ë ê¹Œ

$$
{\begin{bmatrix}
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0\end{bmatrix}}^3 =  \begin{bmatrix}
2 & 3 & 3 \\ 3 & 2  &3 \\ 3 &3 & 2\end{bmatrix}
$$

3ë²ˆ ì´ë™í–ˆì„ ë•Œ ë‹¤ì‹œ ì œìë¦¬ë¡œ ì˜¤ë ¤ë©´ í•œìª½ ë°©í–¥ìœ¼ë¡œ ìª½ ê°€ë©´ ë˜ë‹ˆê¹Œ 2ê°€ì§€

ë‚˜ë¨¸ì§€ ê²½ìš°ëŠ” ë’¤ë¥¼ -1 ì•ì„ 1ì´ë¼ê³  í•˜ë©´ {-1, 1, 1} ,  {1, -1, 1}, {1, 1,- 1} ì´ëŸ°ì‹ìœ¼ë¡œ 3ê°€ì§€ ë°©ì‹ì´ ìˆë‹¤. 

**ì¤‘ìš”í•œ ê²ƒì€** 

<aside>
ğŸ’¡ í–‰ë ¬ ì œê³±ì„ í•˜ë©´ í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ì •ì ê¹Œì§€ ê°€ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ì•Œ ìˆ˜ ìˆë‹¤.

</aside>

### [12850 ë³¸ëŒ€ì‚°ì±…2](https://www.acmicpc.net/problem/12850)

ê° ì •ì ì„ ìˆ«ìëŠ” ì•Œì•„ì„œ ì„¤ì •í•˜ê³  ì¸ì •í–‰ë ¬ì„ ë§Œë“ ë‹¤. 

ê·¸ë¦¬ê³  ì œê³±ì„ í•œë’¤ì— $matrix[ê³¼í•™ê´€ì •ì ][ê³¼í•™ê´€ì •ì ]$ ì„ í•˜ë©´ ë‹µì´ë‹¤. 

ì‹œê°„ ë³µì¡ë„ëŠ” $O(8^3log(D))$ë¡œ í’€ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤. 

ì•„ë˜ê°€ ì½”ë“œì´ë‹¤. 

```cpp
#include <bits/stdc++.h>
#define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false);
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef tuple<int, int, int> tiii;
#define xx first
#define yy second

const ll MOD = 1e9+7;
class matrix{
public:
    vector<vector<ll>> mat;
    
    void initialize(int a, int b){
        mat.assign(a, vector<ll>(b,0));
    }
    
    void input(){
        mat = { {0, 1, 1, 0, 0, 0, 0, 0},
                {1, 0, 1, 1, 0, 0, 0, 0},
                {1, 1, 0, 1, 1, 0, 0, 0},
                {0, 1, 1, 0, 1, 1, 0, 0},
                {0, 0, 1, 1, 0, 1, 1, 0},
                {0, 0, 0, 1, 1, 0, 0, 1},
                {0, 0, 0, 0, 1, 0, 0, 1},
                {0, 0, 0, 0, 0, 1, 1, 0},
        };
    }
    
    matrix operator*(matrix A){
        matrix result;
        result.initialize(mat.size(), A.mat[0].size());
        for(int i=0;i<mat.size();i++){
            for(int j=0;j<A.mat[0].size();j++){
                for(int k=0;k<A.mat.size();k++){
                    result.mat[i][j] += mat[i][k]*A.mat[k][j];
                    result.mat[i][j] %= MOD;
                }
            }
        }
        return result;
    }
    
};

matrix mat;

matrix powMat(matrix &mat, ll b){
    if(b==1){
        return mat;
    }
    
    matrix half = powMat(mat, b/2);
    matrix ret = (half*half);
    if(b&1) return ret*mat;
    return ret;
}

int main(){
    fast_io
    ll D; cin >> D;
    mat.input();
    matrix res = powMat(mat, D);
    cout << res.mat[0][0];
}
```

### [1533 ê¸¸ì˜ ê°œìˆ˜](https://www.acmicpc.net/problem/1533)

ì´ ë¬¸ì œëŠ” ì¸ì ‘í–‰ë ¬ì— ê°€ì¤‘ì¹˜ê°€ ìˆë‹¤. 

ê·¸ë˜ì„œ ë‹¨ìˆœíˆ ê°€ì¤‘ì¹˜ë¥¼ í¬í•¨í•˜ì—¬ ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•  ìˆ˜ëŠ” ì—†ë‹¤. 

ê·¸ëŸ¬ë©´ ì•„ê¹Œ í’€ì—ˆë˜ ë¬¸ì œë¡œ ì¹˜í™˜ í•´ì•¼í•˜ëŠ”ë° ê°€ì¤‘ì¹˜ë¥¼ ì—†ëŠ” ê²ƒ ì²˜ëŸ¼ ë§Œë“œëŠ” ë°©ë²•ì€ ê°€ì¤‘ì¹˜ë§Œí¼ ë°˜ë³µí•˜ëŠ” ê²ƒì´ë‹¤. 

ì˜ˆë¥¼ ë“¤ì–´ 

$$
\begin{bmatrix}
0 & 1 & 2 \\
1 & 0 & 1 \\
1 & 2 & 0\end{bmatrix}
$$

1. ë‹¤ìŒê³¼ ê°™ì€ í–‰ë ¬ì´ ìˆìœ¼ë©´ 1â†’3ê¹Œì§€ ê°€ëŠ”ë° 2ë¶„ì´ ê±¸ë¦°ë‹¤. 
2. ê·¸ëŸ¼ 1ë¶„í›„ ë‹¤ë¥¸ ì •ì ì— ë“¤ë €ë‹¤ê°€
3. ë‹¤ì‹œ 1ë¶„í›„ ì›ë˜ ëª©ì ì§€ì— ë„ì°©í•œë‹¤. 

ì´ëŸ° ì‹ìœ¼ë¡œ í‘¼ë‹¤ë©´ 1ê°€ì§€ ê²½ìš°ì˜ ìˆ˜ë¡œ ëª©ì ì§€ì— ì˜ ë„ì°©í•˜ë˜, 1ë¶„ë‹¨ìœ„ë¡œ ê³„ì‚°í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤. 

ì‹œê°„ì˜ ë²”ìœ„ëŠ” 5ì´ë‚´ ì´ë‹ˆê¹Œ nê°œì˜ ì •ì  ì´ì™¸ 4ê°œì˜ ì •ì ì„ ë§Œë“¤ì—ˆë‹¤. n+1, n+2, n+3, n+4

ë§Œì•½ì— ì‹œê°„ì´ 3ë¶„ ê±¸ë¦¬ë©´ n+3ë¡œ ê°„ë‹¤. (src â†’ n+3 â†’ n+4 â†’ dest)

í™”ì‚´í‘œê°€ 3ê°œìˆìœ¼ë‹ˆê¹Œ 3ë¶„ ê±¸ë¦¬ëŠ”ê²Œ ë§ë‹¤. 

**ê·¼ë° ì´ëŒ€ë¡œ êµ¬í˜„í•˜ë‹ˆê¹Œ ê°’ì´ ë” í¬ê²Œ ë‚˜ì™”ë”°. (í‹€ë ¸ë‹¨ ëœ»)**

```mermaid
graph TD;
	A-->C;
	B-->C;
	C-->D;
	C-->E;
```

```mermaid
graph TD;
	A-->C1;
	B-->C2;
	C1-->D;
	C2-->E;
```

ìœ„ ì™€ ê°™ì€ ê·¸ë˜í”„ê°€ ìˆë‹¤ê³  í•˜ë©´ ë‹¹ì—°íˆ ê²½ë¡œì˜ ìˆ˜ëŠ” ì™¼ìª½ì€ 4ê°€ì§€, ì˜¤ë¥¸ìª½ì€ 2ê°€ì§€ê°€ ëœë‹¤. 

ê·¸ë¦¬ê³  ìš°ë¦¬ê°€ ì°¾ê³  ì‹¶ì€ ê²½ë¡œëŠ” ì˜¤ë¥¸ìª½ì´ë‹¤. ê·¸ëŸ¬ë©´ ê° ì •ì ë§ˆë‹¤ ê²½ìœ ì§€ë¥¼ ì„¤ì •í•´ì•¼í•œë‹¤ëŠ” ëœ»ì´ë‹¤. 

ê·¸ëŸ¬ë©´ ì •ì ì´ ì´ $N + 4*N = 5N$ ê°œê°€ ìˆì„ ê²ƒì´ë‹¤. 

ì‹œê°„ë³µì¡ë„ëŠ” $O((5N)^3log(T))$ ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤. 

ì˜ˆë¥¼ ë“¤ì–´, Aë²ˆ ì •ì ì—ì„œ Bë²ˆì •ì ìœ¼ë¡œ ê°€ëŠ”ë° ì‹œê°„ì´ 2ê±¸ë¦°ë‹¤ê³  ì¹˜ì. ê·¸ëŸ¬ë©´ Aì—ì„œ ì¶œë°œí•˜ì—¬ Bë²ˆ ì •ì ì˜ 4ë²ˆ ê²½ìœ ì§€ë¥¼ ë“¤ë €ë‹¤ê°€ê°€ë©´ Bê¹Œì§€ëŠ” 2ê±¸ë¦´ ê²ƒì´ë‹¤. ì´ ì•„ì´ë””ì–´ê°€ ê°€ì¥ ì¤‘ìš”í•˜ë‹¤. 

```cpp
#include <bits/stdc++.h>
#define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false);
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef tuple<int, int, int> tiii;
#define xx first
#define yy second

const ll MOD = 1e6+3;
class matrix{
public:
    vector<vector<ll>> mat;
    
    void initialize(int a, int b){
        mat.assign(a, vector<ll>(b,0));
    }
    
    void input(int n, int m){
        mat = vector (5*n+1, vector<ll>(5*m+1));
        for(int i=5;i<=5*n;i+=5){
            for(int j=4;j>0;j--){
                mat[i-j][i-j+1] = 1;
            }
        }
        
    }
    
    matrix operator*(matrix A){
        matrix result;
        result.initialize(mat.size(), A.mat[0].size());
        for(int i=0;i<mat.size();i++){
            for(int j=0;j<A.mat[0].size();j++){
                for(int k=0;k<A.mat.size();k++){
                    result.mat[i][j] += mat[i][k]*A.mat[k][j];
                    result.mat[i][j] %= MOD;
                }
            }
        }
        return result;
    }
    
};

matrix mt;

matrix powMat(matrix &mat, ll b){
    if(b==1){
        return mat;
    }
    
    matrix half = powMat(mat, b/2);
    matrix ret = (half*half);
    if(b&1) return (ret*mat);
    return ret;
}

int main(){
    fast_io
    ll n, S, E, T;
    cin >> n >> S >> E >> T;
    mt.input(n, n);
    for(int i=1;i<=n;i++){
        string s; cin >> s;
        for(int j=1;j<=s.size();j++){
            int t = s[j-1]-'0';
            if(t){
                if(t==1){
                    mt.mat[5*i][5*j] = 1;
                }else{
                    mt.mat[5*i][5*j-t+1] = 1;
                }
            }
        }
    }
    matrix res = powMat(mt, T);
    cout << res.mat[5*S][5*E];
}
```

### [12728 nì œê³± ê³„ì‚°](https://www.acmicpc.net/problem/12728)

ê·¸ëŸ¬ë©´ ì¢€ ì–´ë ¤ìš´ ë¬¸ì œë¥¼ í’€ì–´ ë³¼ ê²ƒì´ë‹¤. 

$(3 + \sqrt(5))^n$ì˜ ì†Œìˆ«ì  ì•ì— ë§ˆì§€ë§‰ ì„¸ìë¦¬ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤. (ì •ìˆ˜ë¶€ë¥¼ 1000ìœ¼ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€)

$a = (3 + \sqrt(5))$, $b = (3 - \sqrt(5))$ ë¼ê³  í•´ë³´ì 

- $a + b = 6, ab = 4$ ì´ë‹¤.
- ìœ„ ë‘ê°œë¥¼ ë³´ë©´ $a, b$ ëŠ”$x^2-6x+4$ì˜ 2ê°œì˜ í•´ì´ë‹¤.
- ë”°ë¼ì„œ $a^2 = 6a-4, b^2 = 6b-4$ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆë‹¤.

ë‹¤ì‹œ ëŒì•„ì™€ì„œ $(3 + \sqrt(5))^n$ ì˜ ì •ìˆ˜ë¶€ëŠ” ì–´ë–»ê²Œ êµ¬í• ê¹Œ?

ë¨¼ì €, $a^n + b^n$ì„ ìƒê°í•´ë³´ì. ì´ëŠ” $6a^{n-1}-4a^{n-2} + 6b^{n-1}-4b^{n-2}$ ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆë”°.  ì´ë¥¼ ì í™”ì‹ ì²˜ëŸ¼ ìƒê°í•´ë³´ë©´

$f_n = 6f_{n-1}-4f_{n-2}$ $(f_1 = a+b = 6, f_2 = (a+b)^2-2ab= 28)$ ì´ë‹¤. 

ì—¬ê¸°ì„œ ìš°ë¦¬ëŠ” ì„ í˜•ë°©ì •ì‹ì„ í•˜ë‚˜ êµ¬í•œ ê²ƒì´ë‹¤.  ê·¸ë¦¬ê³  $a^n + b^n$ì´ ì •ìˆ˜ë¼ëŠ” ê²ƒë„ ì•Œì•„ëƒˆë‹¤. 

ê·¸ëŸ°ë° ì´ ì‹ì´ ë¬¸ì œë‘ ë¬´ìŠ¨ ìƒê´€ì´ëƒê³  ìƒê°ì´ ë  ìˆ˜ë„ ìˆë‹¤. ìš°ë¦¬ëŠ” $a^n$ë§Œ í•„ìš”í•œë°â€¦

ê·¼ë° $b^n$ì„ ê°€ë§Œíˆ ìƒê°í•´ë³´ë©´ $0< b_n â‰¤ 1$ ì´ë¼ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.  ì¦‰â€¦ì´ê²ƒì€ ì†Œìˆ˜ì •ë„ ìˆ˜ì¤€ì´ë¼ëŠ” ê²ƒì´ë‹¤. 

ì¦‰, $a^n$ì—ì„œ 1ë³´ë‹¤ ì‘ì€ ìˆ˜ $b^n$ì„ ë”í–ˆë”ë‹ˆ $a^n + b^n$ê°€ ì •ìˆ˜ê°€ ë˜ì—ˆë‹¤. â†’ $a^n+b^n-1$ ì´ ë‹µì´ë‹¤. 

ê·¸ëŸ¬ë©´ ì´ì œ ì•„ê¹Œ êµ¬í–ˆë˜ ì„ í˜• ë°©ì •ì‹ì˜ í•´ë¥¼ êµ¬í•´ ë³´ì. 

$$\begin{bmatrix}
f_{n} \\
f_{n-1} \\
\end{bmatrix} = \begin{bmatrix}
f_{n-1} \\
f_{n-2} \\
\end{bmatrix}\begin{bmatrix}
6 & -4 \\
1 & 0 \\
\end{bmatrix} = \begin{bmatrix}
f_{2} \\
f_{1} \\
\end{bmatrix}{\begin{bmatrix}
6 & -4 \\
1 & 0 \\
\end{bmatrix}}^{n-2}$$

ì´ë¥¼ êµ¬í•˜ê³  $(1, 1)ìš”ì†Œ * f_2(28) + (1, 2)ìš”ì†Œ * f_1(6)-1$ì„ 1000ìœ¼ë¡œ ë‚˜ëˆ„ë©´ ë‹µì´ë‹¤. 

ì´ë•Œ ìŒìˆ˜ë¥¼ ë‚˜ì˜¤ì§€ ì•Šê²Œí•˜ê¸°ìœ„í•´ì„œ -4ì— 1000ì„ ë”í•´ì¤€ë‹¤. 

```cpp
#include <bits/stdc++.h>
#define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false);
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef tuple<int, int, int> tiii;
#define xx first
#define yy second

const ll MOD = 1e3;
class matrix{
public:
    vector<vector <ll> > mat;
    
    void initialize(int a, int b){
        mat.assign(a, vector<ll>(b,0));
    }
    
    void input(){
	//ì–´ì§œí”¼ 1000ìœ¼ë¡œ ë‚˜ëˆ„ë‹ˆê¹Œ ìŒìˆ˜ ë¶€ë¶„ì„ ì—†ì• ë²„ë¦°ë‹¤. 
        mat = { {6, -4+MOD}, {1, 0} };
    }
    
    matrix operator*(matrix A){
        matrix result;
        result.initialize(mat.size(), A.mat[0].size());
        for(int i=0;i<mat.size();i++){
            for(int j=0;j<A.mat[0].size();j++){
                for(int k=0;k<A.mat.size();k++){
                    result.mat[i][j] += mat[i][k]*A.mat[k][j];
                    result.mat[i][j] %= MOD;
                }
            }
        }
        return result;
    }
    
};

matrix mt;

matrix powMat(matrix &mat, ll b){
    if(b==0){// ë‹¨ìœ„ ë²¡í„° ë¦¬í„´
        matrix ret; ret.mat = { {1, 0}, {0, 1} };
        return ret;
    }
    if(b==1){
        return mat;
    }
    
    matrix half = powMat(mat, b/2);
    matrix ret = (half*half);
    if(b&1) return (ret*mat);
    return ret;
}

int main(){
    fast_io
    int tt; cin >> tt;
    int ori = tt;
    while (tt--) {
        ll n; cin >> n;
        mt.input();
        matrix res = powMat(mt, n-2);
        ll ans = (res.mat[0][0]*28+res.mat[0][1]*6-1)%MOD;
        string ANS = to_string(ans);
        cout << "Case #" << ori-tt << ": ";
        for(int i=ANS.size();i<3;i++) cout << '0';
        cout << ANS << '\n';
    }

}
```

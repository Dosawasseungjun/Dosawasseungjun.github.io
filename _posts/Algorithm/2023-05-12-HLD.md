---
layout: posts
categories: ["BOJ"]
title:  "Heavy-Light decomposition"
tags : [heavy-lightë¶„í• , íŠ¸ë¦¬]
use_math : true
---

# HLD(Heavy Light Decomposition)

<aside>
ğŸ’¡ íŠ¸ë¦¬ì—ì„œ ì„ì˜ì˜ ë‘ ì •ì ì„ ì‡ëŠ” ê²½ë¡œì— ëŒ€í•œ ì¿¼ë¦¬ê°€ ê¶ê¸ˆí•  ë•Œ.

</aside>

## êµ¬í˜„ê³¼ì •

êµ¬í˜„ê³¼ì •ì€ [jinhanë‹˜ì˜ ë¸”ë¡œê·¸](https://blog.naver.com/jinhan814/222144994173) ë¥¼ ì°¸ê³ í•˜ì—¬ êµ¬í˜„í–ˆë‹¤. 

1. ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ê·¸ë˜í”„ë¼ë©´ adjì— ê°€ì¤‘ì¹˜ ì—†ëŠ” ê·¸ë˜í”„ë¥¼ ë§Œë“¤ê³ , cost[ì •ì ]ì— í•´ë‹¹ ì •ì ìœ¼ë¡œ ê°ˆ ë•Œ ë“œëŠ” ë¹„ìš©ì„ ì €ì¥í•œë‹¤. ê·¸ë¦¬ê³  i**nput[i] = {u, v}ì´ëŸ° ì‹ìœ¼ë¡œ ì •ì ì— ë²ˆí˜¸ë¥¼ ë¶™ì—¬ì¤€ë‹¤.**(ì„¸ê·¸íŠ¸ë¦¬ë¡œ ë‹¤ë£¨ê¸° ìœ„í•¨) 
2. dfs1ì„ ëŒë©´ì„œ **ê° ì •ì ì˜ ê¹Šì´(dep), ê° ì •ì ì˜ ë¶€ëª¨ ì •ì (par), ê° ì •ì ì´ ë§Œë“œëŠ” ì„œë¸ŒíŠ¸ë¦¬ í¬ê¸°(sz)**ë¥¼ ì €ì¥í•œë‹¤. ì´ ë•Œ adj[ì •ì ][0]ì—ëŠ” ê°€ì¥ ë¬´ê±°ìš´ ê°„ì„ ì´ ë˜ë„ë¡ í•œë‹¤. 
3. dfs2ë¥¼ ëŒë©´ì„œ **ì˜¤ì¼ëŸ¬íˆ¬ì–´ í…Œí¬ë‹‰**ì„ ì ìš©í•˜ê³  **ì •ì ì´ ë¬´ê±°ìš´ ê°„ì„ ì„ ì§€ë‹ˆëŠ” ì •ì ì¸ì§€ë¥¼ ì²´í¬í•œë‹¤. (top)**

ì •ë¦¬í•´ë³´ë©´ 

- input[i] = ië²ˆì§¸ ì •ì ì€ {xxì •ì , yyì •ì }ë¥¼ ì‡ëŠ” ê°„ì„ ì…ë‹ˆë‹¤.
- inp[i] : ì§ì ‘ ì…ë ¥ ë°›ì€ ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ê·¸ë˜í”„
- adj[i] : inpì„ ë°”ê¿”ì„œ ê°€ì¤‘ì¹˜ë¥¼ ë–¼ì–´ë‚¸ ê·¸ë˜í”„
- cost[i] : ië²ˆ ì§¸ ì •ì ê¹Œì§€ ê°€ëŠ”ë° ë“œëŠ” ê°€ì¤‘ì¹˜(ë¹„ìš©)
- dep, par, szëŠ” ìœ„ì— ì„¤ëª…í–ˆê³ 
- in, out â†’ ì˜¤ì¼ëŸ¬ íˆ¬ì–´ í…Œí¬ë‹‰(DFS ordering)í•˜ê³  ë‚œ ê²°ê³¼ in[ì–´ë–¤ ì •ì ]ì´  ì§€ì¹­í•˜ëŠ” ê°„ì„  ë²ˆí˜¸
- top[i] : ië²ˆ ì •ì ì´ ë¬´ê±°ìš´ ê°„ì„ ì„ í¬í•¨í•˜ë©´ 0 ì•„ë‹ˆë©´ ë¬´ê±°ìš´ ê°„ì„ ì„ í¬í•¨í•˜ëŠ” ì •ì ì„ ì €ì¥í•´ë‘ .

ì´ì œ ìš°ë¦¬ì˜ ë¬¸ì œë¥¼ í•´ê²°í•´ë³´ì!

1. ë‘ ì •ì ì„ ì‡ëŠ” ê²½ë¡œì—ì„œ ê°€ì¥ í° ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§„ ê°„ì„ ì€ ë¬´ì—‡ì¼ê¹Œ?
2. ì´ ë•Œ, ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ëŠ” ë³€í•  ìˆ˜ ìˆë‹¤.  â†’ [13510 íŠ¸ë¦¬ì™€ ì¿¼ë¦¬](https://www.acmicpc.net/problem/13510) 

ìœ„ì˜ ë¬¸ì œë¥¼ í•´ê²°í•  ê²ƒ ì´ë‹¤. 

```cpp
//update ì—°ì‚° , xstëŠ” maxSegmentTreeì´ë‹¤.
// i ë²ˆ ê°„ì„ ì„ valë¡œ
    void update(T i, T val){
        if(dep[input[i].xx] < dep[input[i].yy]) swap(input[i].xx, input[i].yy);
        xst.update(in[input[i].xx], val, 1, 1, n);
    }
```

ìœ„ ì½”ë“œë¥¼ ë³´ë©´ depê°€ ê¹Šì€ ì •ì ì— í•´ë‹¹í•˜ëŠ” ê°„ì„ ì„ valë¡œ ë³€í™”ì‹œí‚¨ë‹¤.  2ë²ˆì— í•´ë‹¹í•˜ëŠ” ì½”ë“œì´ë‹¤. 

```cpp
//query ì—°ì‚°
//u, vìœ„ ê°€ì¥ í° ê°€ì¤‘ì¹˜
    T query(T u, T v){
        T ret = 0;
        while(top[u]!=top[v]){
            if(dep[top[u]] < dep[top[v]]) swap(u, v);
            int st = top[u];
            ret = max(ret, xst.xquery(in[st], in[u], 1, 1, n));
            u = par[st];
        }
        if(u==v) return ret;
        if(dep[u] > dep[v]) swap(u, v);
        T nxt = -1;
        for(auto i : adj[u]) if(top[i]==top[u]) nxt = i;
        ret = max(ret, xst.xquery(in[nxt], in[v], 1, 1, n));
        return ret;
    }
```

ì´ëŠ” 1ë²ˆ - ì¦‰ ê²½ë¡œì—ì„œ ê°€ì¥ í° ê°€ì¤‘ì¹˜ë¥¼ êµ¬í•˜ëŠ” ì¿¼ë¦¬ì´ë‹¤. 

![HLD.jpeg](HLD(Heavy%20Light%20Decomposition)%20b0761096507a4ac8885d9fce35c30109/HLD.jpeg)

top[ì–´ë–¤ ì •ì ]ì€ ê°„ì„  ë¶„ë¥˜ì˜ ë§¨ ìœ„ë¡œ ì˜¬ë¼ê°„ë‹¤ëŠ” ëœ»ì´ë‹¤. 

ì˜ˆë¥¼ ë“¤ì–´ 5 - 7ë¡œ ê°„ë‹¤ê³  í•˜ë©´

1. 5ë‘ 7ì˜ ê¹Šì´ê°€ ê°™ìœ¼ë‹ˆê¹Œ u = 5, v = 7
2. uë¥¼ st = top[u] = 2ì´ë‹¤.  íŒŒë€ ê°„ì„ ì´ ëë‚˜ëŠ” ì •ì ê¹Œì§€ ê°€ê³ 
3. ì´ ë•Œ **ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¡œ ê²½ë¡œ ìƒ íŒŒë€ ê°„ì„ ì„ ëª¨ë‘ ë”í•œë‹¤(ìµœëŒ€ê°’ì„ ì°¾ëŠ”ë‹¤).** 
4. ë‹¤ìŒì—” u = 7, v = 2ê°€ ë  ê²ƒì´ê³  top[u] = 1ì´ë‹¤. â†’ ê²½ë¡œ ìƒ **ë…¸ë€ê°„ì„ ì„ ëª¨ë‘ ë”í•œë‹¤.(ìµœëŒ€ê°’ì„ ì°¾ëŠ”ë‹¤)** 
5. ë‹¤ìŒì—” u = 2, v = 1ì´ ë  ê²ƒì´ê³  top[2] = 1ì´ë‹¤. â†’ **ê²½ë¡œ ìƒ ë¹¨ê°„ ê°„ì„ ì„ ëª¨ë‘ ë”í•œë‹¤.(ìµœëŒ€ê°’ì„ ì°¾ëŠ”ë‹¤)**

ì´ëŸ° ì‹ìœ¼ë¡œ ë¬´ê±°ìš´ ê°„ì„ ì„ í†µí•´ ë¶„ë¥˜í•œ ê°„ì„ ìœ¼ë¡œ ì­‰ì­‰ ì´ë™í•˜ë©´ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ HLDì´ë‹¤. 

ì´ë•Œ ì´ ê°„ì„ ì˜ ì¢…ë¥˜ê°€ $logN$ê°œ ì´ë¯€ë¡œ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¥¼ í•˜ëŠ” $logN$ê³¼ í•©ì³

ì´ ì‹œê°„ ë³µì¡ë„ : $O((logN)^2)$ìœ¼ë¡œ ê° ì¿¼ë¦¬ë¥¼ í•´ê²° í•  ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤. 

### [13309 íŠ¸ë¦¬](https://www.acmicpc.net/problem/13309)

íŠ¸ë¦¬ê°€ ê°€ì¤‘ì¹˜ 1ë¡œ ëª¨ë‘ ì—°ê²° ë˜ì–´ìˆë‹¤ê³  í•˜ê³  ì—°ê²°ì´ ëŠì–´ì§€ë©´ updateì—°ì‚°ìœ¼ë¡œ í•´ë‹¹ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ë¥¼ 0ìœ¼ë¡œ ë°”ê¿”ì¤€ë‹¤. ê·¸ë¦¬ê³ ë‚˜ì„œ êµ¬í•œ ê²½ë¡œì˜ ê¸¸ì´ê°€ $dep[u] + dep[v] - dep[lca(u, v)]$ ì™€ ê°™ë‹¤ë©´ ê²½ë¡œê°€ ì¡´ì¬í•˜ëŠ” ê²ƒì´ê³  ë‚˜ë¨¸ì§€ ê²½ìš°ëŠ” ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²ƒì´ë‹¤. 

ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ë‹¤. 

```cpp
#include <bits/stdc++.h>
#define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false);
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef tuple<int, int, int> tiii;
#define xx first
#define yy second

const int MAXSIZE = 2e5+1;

// êµ¬ê°„í•© ì„¸ê·¸
template <class T>
class Segtree{
public:
    static const int TREESIZE = 4*MAXSIZE;
    T* tree = new T[TREESIZE];

    Segtree(){
        for(int i=0;i<TREESIZE;i++) tree[i] = 0;
    }
    ~Segtree(){
        delete[] tree;
    }
    T update(T x, T v, T node, T S, T E){
        if(S==E) return tree[node] = v; // ì›ì†Œêµì²´ì—°ì‚°, ë”í•˜ê¸°ë©´ +í•˜ì…ˆ
        
        T mid = (S+E)>>1;
        if(x<=mid) update(x, v, 2*node, S, mid);
        else update(x, v, 2*node+1, mid+1, E);
        return tree[node] = tree[2*node]+tree[2*node+1];
    }
    T kth(T node, T S, T E, T K){
        if(S==E) return S;
        T mid = (S+E)>>1;
        if(tree[2*node]>=K) return kth(2*node, S, mid, K);
        else return kth(2*node+1, mid+1, E, K-tree[2*node]);
    }
    T query(T L, T R, T node, T S, T E){
        if(L>E||R<S) return 0;
        if(L<=S&&E<=R) return tree[node];
        T mid = (S+E)>>1;
        return query(L, R, 2*node, S, mid)+query(L, R, 2*node+1, mid+1, E);
    }
};
// ê²½ë¡œ ì¤‘ ìµœëŒ€ê°’ ì°¾ê¸°
template <class T>
class HLD{
public:
    int n;
    T cost[MAXSIZE], sz[MAXSIZE], dep[MAXSIZE], par[MAXSIZE];
    T top[MAXSIZE], in[MAXSIZE], out[MAXSIZE];
    vector<pair<T, T>> input, inp[MAXSIZE];
    vector<T> adj[MAXSIZE];
    
    bool visited[MAXSIZE];
    
    void dfs(int now = 1){
        visited[now] = 1;
        for(auto [ncost, nxt] : inp[now]){
            if(visited[nxt]) continue;
            adj[now].push_back(nxt);
            cost[nxt] = ncost;
            dfs(nxt);
        }
    }
    
    void dfs1(int now = 1){
        sz[now] = 1;
        for(T& nxt : adj[now]){
            dep[nxt] = dep[now]+1;
            par[nxt] = now;
            dfs1(nxt);
            sz[now] += sz[nxt];
            if(sz[nxt]>sz[adj[now][0]]) swap(nxt, adj[now][0]); //adj[now][0]ì—ëŠ” ê°€ì¥í°ê²ƒ (heavy)
        }
    }
    
    int tmp = 0;
    void dfs2(int now = 1){
        in[now] = ++tmp;
        for(T nxt : adj[now]){
            top[nxt] = (nxt==adj[now][0] ? top[now] : nxt);
            dfs2(nxt);
        }
        out[now] = tmp;
    }
    
    Segtree<T> st;
    
    // i ë²ˆ ê°„ì„ ì„ valë¡œ
    void update(T i, T val){
        if(dep[input[i].xx] < dep[input[i].yy]) swap(input[i].yy, input[i].xx);
        st.update(in[input[i].xx], val, 1, 1, n);
    }
    
    //u, vìœ„ ê°€ì¥ í° ê°€ì¤‘ì¹˜
    T query(T u, T v){
        T ret = 0;
        while(top[u]!=top[v]){
            if(dep[top[u]] < dep[top[v]]) swap(u, v);
            int ST = top[u];
            ret += st.query(in[ST], in[u], 1, 1, n);
            u = par[ST];
        }
        if(u==v) return ret;
        if(dep[u] > dep[v]) swap(u, v);
        ret += st.query(in[u], in[v], 1, 1, n);
        int LCA = lca(u, v);
        ret -= st.query(in[LCA], in[LCA], 1, 1, n);
        return ret;
    }
    
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            u = par[top[u]];
        }
        if (dep[u] > dep[v]) swap(u, v);
        return u;
    }
    
    void precal(){
        input = vector<pair<T, T> > (n+1);
        for(int i=2;i<=n;i++){
            int p; cin >> p;
            input[i-1] = {p, i};
            inp[p].push_back({1, i});
            inp[i].push_back({1, p});
        }
        for(int i=1;i<=n;i++){
            st.update(i, 1, 1, 1, n);
        }
        top[1] = 1;
        dfs(); dfs1(); dfs2();
    }
};
HLD<int> hld;

int main(){
    fast_io
    int n, q; cin >> n >> q;
    hld.n = n;
    hld.precal();
    while (q--) {
        int u, v, o; cin >> u >> v >> o;
        bool ok = false;
        if(hld.query(u, v)==hld.dep[u]+hld.dep[v]-2*hld.dep[hld.lca(u, v)]){
            ok = true;
            cout << "YES\n";
        }else{
            cout << "NO\n";
        }
        if(o){
            if(ok) hld.st.update(hld.in[u], 0, 1, 1, n);
            else hld.st.update(hld.in[v], 0, 1, 1, n);
        }
        
    }
}
```

### [13512 íŠ¸ë¦¬ì™€ ì¿¼ë¦¬3](https://www.acmicpc.net/problem/13512)

1. 1ë²ˆ ì¿¼ë¦¬ëŠ” íŠ¸ë¦¬ì˜ ìƒ‰ì„ ë°”ê¾¸ëŠ” ì—°ì‚°ì€ XOR 1ì—°ì‚°ì„ í†µí•´ í•´ê²° í•  ìˆ˜ ìˆì„ ê²ƒì´ë‹¤. 
2. 2ë²ˆ ì¿¼ë¦¬ëŠ” 1ë²ˆ ë¶€í„° í•´ë‹¹ ì •ì ìœ¼ë¡œ ê°€ë©´ì„œ ê°€ì¥ ë¨¼ì € ë‚˜ì˜¤ëŠ” 1ì„ ì°¾ìœ¼ë©´ ëœë‹¤. 

2ë²ˆ ì¿¼ë¦¬ë¥¼ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ë¬¸ì œì¸ë°â€¦

ê°€ì¥ ë¨¼ì € ë‚˜ì˜¤ëŠ” 1ì„ êµ¬í•˜ëŠ” ë°©ë²•ì€ ì´ë¶„ íƒìƒ‰ì„ ì´ìš©í•˜ë©´ ëœë‹¤. 

```cpp
T bisearch(T L, T R){
        if(!query(L, R, 1, 1, MAXSIZE)) return -1;
        T lo = L-1 , hi = R;
        while(lo+1<hi){
            T mid = (lo+hi)>>1;
//Lë¶€í„° ê²€ì‚¬í•˜ëŠ”ê²Œ ì¤‘ìš”!! loëŠ” off-by-one errorë•œì— 1ì„ ëºìŒ
            if(query(L, mid, 1, 1, MAXSIZE)){
                hi = mid;
            }else{
                lo = mid;
            }
        }
        return hi;
    }
```

ì´ë¥¼ ì´ìš©í•˜ì—¬ êµ¬ê°„ì— 1ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ë°”ë¡œ -1 ë¦¬í„´

êµ¬ê°„ì— ì¡´ì¬í•˜ë©´ ê°€ì¥ ë¨¼ì €ë‚˜ì˜¤ëŠ” ê³³ì˜ dfs order ë²ˆí˜¸ë¥¼ ë¦¬í„´í•œë‹¤. 

ë¬¸ì œëŠ” ê°€ì¥ ë¨¼ì € 1ì´ ë‚˜ì˜¤ëŠ” ê³³ì˜ ì •ì  idxë¥¼ ì¶œë ¥í•˜ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì— dfs orderingì„ í•  ë•Œ ì—­í•¨ìˆ˜ë¥¼ êµ¬í•´ë†“ëŠ” ê²ƒì´ í¸í•˜ë‹¤.  ë‚˜ëŠ” Rì´ë¼ëŠ” ë°°ì—´ì„ ì´ìš©í–ˆë‹¤. 

```cpp
#include <bits/stdc++.h>
#define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false);
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef tuple<int, int, int> tiii;
#define xx first
#define yy second

const int MAXSIZE = 1e5+1;

// êµ¬ê°„í•© ì„¸ê·¸
template <class T>
class Segtree{
public:
    static const int TREESIZE = 4*MAXSIZE;
    T* tree = new T[TREESIZE];

    Segtree(){
        for(int i=0;i<TREESIZE;i++) tree[i] = 0;
    }
    ~Segtree(){
        delete[] tree;
    }
    T update(T x, T v, T node, T S, T E){
        if(S==E) return tree[node] ^= v; // ì›ì†Œêµì²´ì—°ì‚°, ë”í•˜ê¸°ë©´ +í•˜ì…ˆ
        
        T mid = (S+E)>>1;
        if(x<=mid) update(x, v, 2*node, S, mid);
        else update(x, v, 2*node+1, mid+1, E);
        return tree[node] = tree[2*node]+tree[2*node+1];
    }
    T kth(T node, T S, T E, T K){
        if(S==E) return S;
        T mid = (S+E)>>1;
        if(tree[2*node]>=K) return kth(2*node, S, mid, K);
        else return kth(2*node+1, mid+1, E, K-tree[2*node]);
    }
    T query(T L, T R, T node, T S, T E){
        if(L>E||R<S) return 0;
        if(L<=S&&E<=R) return tree[node];
        T mid = (S+E)>>1;
        return query(L, R, 2*node, S, mid)+query(L, R, 2*node+1, mid+1, E);
    }
    T bisearch(T L, T R){
        if(!query(L, R, 1, 1, MAXSIZE)) return -1;
        T lo = L-1 , hi = R;
        while(lo+1<hi){
            T mid = (lo+hi)>>1;
            if(query(L, mid, 1, 1, MAXSIZE)){
                hi = mid;
            }else{
                lo = mid;
            }
        }
        return hi;
    }
};
// ê²½ë¡œ ì¤‘ ìµœëŒ€ê°’ ì°¾ê¸°
template <class T>
class HLD{
public:
    int n;
    T cost[MAXSIZE], sz[MAXSIZE], dep[MAXSIZE], par[MAXSIZE];
    T top[MAXSIZE], in[MAXSIZE], out[MAXSIZE];
    T R[MAXSIZE]; //inì˜ ì—­í•¨ìˆ˜ë¥¼ ì„¤ì •í–ˆìŒ
    vector<pair<T, T>> input, inp[MAXSIZE];
    vector<T> adj[MAXSIZE];
    
    bool visited[MAXSIZE];
    
    void dfs(int now = 1){
        visited[now] = 1;
        for(auto [ncost, nxt] : inp[now]){
            if(visited[nxt]) continue;
            adj[now].push_back(nxt);
            cost[nxt] = ncost;
            dfs(nxt);
        }
    }
    
    void dfs1(int now = 1){
        sz[now] = 1;
        for(T& nxt : adj[now]){
            dep[nxt] = dep[now]+1;
            par[nxt] = now;
            dfs1(nxt);
            sz[now] += sz[nxt];
            if(sz[nxt]>sz[adj[now][0]]) swap(nxt, adj[now][0]); //adj[now][0]ì—ëŠ” ê°€ì¥í°ê²ƒ (heavy)
        }
    }
    
    int tmp = 0;
    void dfs2(int now = 1){
        in[now] = ++tmp;
        R[tmp] = now;
        for(T nxt : adj[now]){
            top[nxt] = (nxt==adj[now][0] ? top[now] : nxt);
            dfs2(nxt);
        }
        out[now] = tmp;
    }
    
    Segtree<T> st;
    
    // i ë²ˆ ê°„ì„ ì„ valë¡œ
    void update(T i, T val){
        if(dep[input[i].xx] < dep[input[i].yy]) swap(input[i].yy, input[i].xx);
        st.update(in[input[i].xx], val, 1, 1, n);
    }
    
    //u, vìœ„ ê°€ì¥ ë¨¼ì €ë‚˜ì˜¤ëŠ” 1
    T query(T u, T v){
        T ret = -1;
        while(top[u]!=top[v]){
            if(dep[top[u]] < dep[top[v]]) swap(u, v);
            int ST = top[u];
            int now = st.bisearch(in[ST], in[u]);
            if(now>0) ret = now;
            u = par[ST];
        }
            
        if(dep[u] > dep[v]) swap(u, v);
        int now = st.bisearch(in[u], in[v]);
        if(now>0) ret = now;
        return ((ret==-1) ? ret : R[ret]);
    }
    
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            u = par[top[u]];
        }
        if (dep[u] > dep[v]) swap(u, v);
        return u;
    }
    
    void precal(){
        input = vector<pair<T, T> > (n+1);
        for(int i=2;i<=n;i++){
            int u, v; cin >> u >> v;
            input[i-1] = {u, v};
            inp[u].push_back({1, v});
            inp[v].push_back({1, u});
        }
        top[1] = 1;
        dfs(); dfs1(); dfs2();
    }
};
HLD<int> hld;

int main(){
    fast_io
    int n, q; cin >> n;
    hld.n = n;
    hld.precal();
    cin >> q;
    while (q--) {
        int op, v; cin >> op >> v;
        if(op==1){
            hld.st.update(hld.in[v], 1, 1, 1, MAXSIZE);
        }else{
            cout << hld.query(1, v) << '\n';
        }
    }
}
```

### [2927 ë‚¨ê·¹íƒí—˜](https://www.acmicpc.net/problem/2927)

ìš°ë¦¬ëŠ” íŠ¸ë¦¬ êµ¬ì¡°ê°€ í™•ì •ëœ ìƒíƒœì—ì„œ HLDë¥¼ ì´ìš©í•˜ì—¬ ë¬¸ì œë¥¼ í’€ì—ˆì§€ë§Œ ì´ ë¬¸ì œëŠ” íŠ¸ë¦¬ êµ¬ì¡°ê°€ ì™„ì„±ë˜ì–´ ìˆì§€ ì•Šë‹¤. ì´ëŸ° ê²½ìš° ì™„ì„± ë˜ì—ˆì„ ë•Œì˜ ë¬¸ì œë¡œ ì¹˜í™˜ì„ í•˜ëŠ” ê²ƒì´ í•„ìš”í•˜ë‹¤. 

ì´ ë•Œ **ì˜¤í”„ë¼ì¸ ì¿¼ë¦¬**ë¥¼ ì´ìš©í•  ìˆ˜ ìˆë‹¤. 

ì¼ë‹¨, bridgeì—°ì‚°ì€ **Union Find**ë¥¼ ë– ì˜¬ë¦´ ìˆ˜ ìˆë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— ì´ ì—°ì‚°ì„ í†µí•´ ë§Œë“¤ì–´ì§„ ê·¸ë˜í”„ëŠ” ë¬´ì¡°ê±´ íŠ¸ë¦¬ í˜•íƒœì´ë‹¤. í•˜ì§€ë§Œ bridgeì—°ì‚°ì´ ì •í™•íˆ n-1ê°œì˜ yesê°€ ë‚˜ì˜¨ë‹¤ëŠ” ë³´ì¥ì´ ì—†ê¸° ë•Œë¬¸ì— ì—¬ëŸ¬ íŠ¸ë¦¬ê°€ ë§Œë“¤ì–´ ì§ˆ ìˆ˜ ìˆë‹¤. ì—¬ëŸ¬ íŠ¸ë¦¬ë¥¼ í•©ì³ì„œ í•˜ë‚˜ì˜ íŠ¸ë¦¬ë¥¼ ë§Œë“œëŠ” ì•„ì´ë””ì–´ë¥¼ ë– ì˜¬ë¦´ ìˆ˜ ìˆì—ˆë‹¤. 

ì´ì œ excursion ì—°ì‚°ì— ëŒ€í•´ ê³ ë¯¼í•´ë³´ì. 

excursionì€ ì¼ë‹¨ ê¸¸ì´ ì—†ìœ¼ë©´ â€œinpossibleâ€ì„ ì¶œë ¥í•œë‹¤. ê·¼ë° ì´ ê²½ìš°ëŠ” ê·¸ëƒ¥ ìˆœì„œëŒ€ë¡œ ë³´ë©´ì„œë„ í•´ê²° í•  ìˆ˜ ìˆë‹¤. ë‚˜ë¨¸ì§€ ê¸¸ì´ ìˆëŠ” ê²½ìš°ëŠ” **íŠ¸ë¦¬ì—ì„œëŠ” ì •ì  u, v ì‚¬ì´ì˜ ê¸¸ì´ í•˜ë‚˜ ë°–ì— ì—†ê¸° ë•Œë¬¸ì—** ê·¸ëƒ¥ HLDì´ìš©í•˜ë©´ ëœë‹¤. 

ê²°ë¡  : 

â†’ ìˆœì„œëŒ€ë¡œ ë³´ë©´ì„œ excursionì¤‘ì— ë¶ˆê°€ëŠ¥í•œ ê±°ëŠ” ë¯¸ë¦¬ ê³¨ë¼ ë‘”ë‹¤. 

â†’ ì´ì œ ì™„ì„±ëœ íŠ¸ë¦¬ë¥¼ ê°€ì§€ê³  ì¿¼ë¦¬ë¥¼ ê±°ê¾¸ë¡œ ë³´ë©´ì„œ ê²½ë¡œ ì¿¼ë¦¬ë¡œ ê¸¸ì´ ìˆëŠ” ê²½ìš°ë¥¼ ê³„ì‚°í•œë‹¤. 

â†’ penguins ì—°ì‚°ì€ ì—­ìœ¼ë¡œ ëŒì•„ê°€ëŠ” ì‹ìœ¼ë¡œ í•´ì•¼í•œë‹¤. (ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ updateí•˜ë©´ ëœë‹¤. )

- ë§ˆì§€ë§‰ìœ¼ë¡œ ê²°ê³¼ë¥¼ ì¶œë ¥í•  ë•Œ
    - bridgeë¼ë©´
        - ë¯¸ë¦¬ ì €ì¥ëœ 1 â†’ yes 0 â†’ no
    - penguinsë¼ë©´
        - continue
    - excursionë¼ë©´
        - Unionfindë¡œ í‰ê°€í–ˆì„ ë•Œ ì´ë¯¸ -1 â†’ â€œimpossibleâ€
        - ê·¸ê²Œ ì•„ë‹ˆë¼ë©´ query(a, b)

ìì„¸í•œê±´ ì•„ë˜ ì½”ë“œì—ì„œ ì£¼ì„ ì²˜ë¦¬ë¡œ ë³´ì´ê² ë‹¤. 

```cpp
#include <bits/stdc++.h>
#define fast_io cin.tie(NULL); ios_base::sync_with_stdio(false);
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef tuple<int, int, int> tiii;
#define xx first
#define yy second

const int MAXSIZE = 3e4+1;
int P[MAXSIZE];

struct DisjointSet{
    vector<int> parent, rank;
    
    DisjointSet(int n):parent(n+1),rank(n+1, 0){
        for(int i=0;i<=n;i++){
            parent[i] = i;
        }
    }
    
    int find(int u){
        if(u==parent[u]) return u;
        return parent[u] = find(parent[u]);
    }
    
    bool merge(int u, int v){
        u = find(u);
        v = find(v);
        if(u==v) return true;
        
        if(rank[u]>rank[v]) swap(u, v);
        parent[u] = v;
        if(rank[u]==rank[v]) rank[v]++;
        return false;
    }
    bool check(int u, int v){
        u = find(u);
        v = find(v);
        if(u==v) return true;
        return false;
    }
};

// êµ¬ê°„í•© ì„¸ê·¸
template <class T>
class Segtree{
public:
    static const int TREESIZE = 4*MAXSIZE;
    T* tree = new T[TREESIZE];

    Segtree(){
        for(int i=0;i<TREESIZE;i++) tree[i] = 0;
    }
    ~Segtree(){
        delete[] tree;
    }
    T update(T x, T v, T node, T S, T E){
        if(S==E) return tree[node] = v; // ì›ì†Œêµì²´ì—°ì‚°, ë”í•˜ê¸°ë©´ +í•˜ì…ˆ
        
        T mid = (S+E)>>1;
        if(x<=mid) update(x, v, 2*node, S, mid);
        else update(x, v, 2*node+1, mid+1, E);
        return tree[node] = tree[2*node]+tree[2*node+1];
    }
    T kth(T node, T S, T E, T K){
        if(S==E) return S;
        T mid = (S+E)>>1;
        if(tree[2*node]>=K) return kth(2*node, S, mid, K);
        else return kth(2*node+1, mid+1, E, K-tree[2*node]);
    }
    T query(T L, T R, T node, T S, T E){
        if(L>E||R<S) return 0;
        if(L<=S&&E<=R) return tree[node];
        T mid = (S+E)>>1;
        return query(L, R, 2*node, S, mid)+query(L, R, 2*node+1, mid+1, E);
    }
};
// ê²½ë¡œ ì¤‘ ìµœëŒ€ê°’ ì°¾ê¸°
template <class T>
class HLD{
public:
    int n;
    T cost[MAXSIZE], sz[MAXSIZE], dep[MAXSIZE], par[MAXSIZE];
    T top[MAXSIZE], in[MAXSIZE], out[MAXSIZE];
    vector<pair<T, T>> input, inp[MAXSIZE];
    vector<T> adj[MAXSIZE];
    
    bool visited[MAXSIZE];
    
    void dfs(int now = 0){
        visited[now] = 1;
        for(auto [ncost, nxt] : inp[now]){
            if(visited[nxt]) continue;
            adj[now].push_back(nxt);
            cost[nxt] = ncost;
            dfs(nxt);
        }
    }
    
    void dfs1(int now = 0){
        sz[now] = 1;
        for(T& nxt : adj[now]){
            dep[nxt] = dep[now]+1;
            par[nxt] = now;
            dfs1(nxt);
            sz[now] += sz[nxt];
            if(sz[nxt]>sz[adj[now][0]]) swap(nxt, adj[now][0]); //adj[now][0]ì—ëŠ” ê°€ì¥í°ê²ƒ (heavy)
        }
    }
    
    int tmp = -1;
    void dfs2(int now = 0){
        in[now] = ++tmp;
        for(T nxt : adj[now]){
            top[nxt] = (nxt==adj[now][0] ? top[now] : nxt);
            dfs2(nxt);
        }
        out[now] = tmp;
    }
    
    Segtree<T> st;
    
    // i ë²ˆ ê°„ì„ ì„ valë¡œ
    void update(T i, T val){
        if(dep[input[i].xx] < dep[input[i].yy]) swap(input[i].yy, input[i].xx);
        st.update(in[input[i].xx], val, 1, 0, n);
    }
    
    //u, vê²½ë¡œìƒ í­ê·„ì˜ ìˆ˜
    T query(T u, T v){
        T ret = 0;
        while(top[u]!=top[v]){
            if(dep[top[u]] < dep[top[v]]) swap(u, v);
            int ST = top[u];
            ret += st.query(in[ST], in[u], 1, 0, MAXSIZE);
            u = par[ST];
        }
        if(dep[u] > dep[v]) swap(u, v);
        ret += st.query(in[u], in[v], 1, 0, MAXSIZE);
        return ret;
    }
    
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            u = par[top[u]];
        }
        if (dep[u] > dep[v]) swap(u, v);
        return u;
    }
    
    void precal(){
        for(int i=1;i<=n;i++){
            inp[0].push_back({1, i});
            inp[i].push_back({1, 0});
        }
        
        top[0] = 1;
        dfs(); dfs1(); dfs2();
    }
};

DisjointSet uf(MAXSIZE);
HLD<int> hld;

class Data{
public:
    string op;
    int a, b ,idx, p,q;
};

pair<string, int> ans[300005];
int main(){
    fast_io
    int n; cin >> n;
    hld.n = n;
    for(int i=1;i<=n;i++) cin >> P[i];
    int q; cin >> q;
    vector<Data> Q(q+1);
    for(int i=1;i<=q;i++){
        string op;
        int a, b;
        cin >> op >> a >> b;
        if(op=="bridge"){
            if(uf.merge(a, b)){//ì´ë¯¸ í•©ì³ì ¸ìˆìŒ
                ans[i] = {"bridge", 0};
            }else{//í•©ì³ì•¼í•¨
                ans[i] = {"bridge", 1};
                hld.inp[a].push_back({1, b});
                hld.inp[b].push_back({1, a});
            }
            Q[i] = {op, a, b, i, -1, -1};
            
        }else if(op=="penguins"){
            Q[i] = {op, a, b, i, P[a], b};
            P[a] = b;
        }else{
            if(uf.check(a, b)){ //ì´ë¯¸ í•©ì³ì ¸ ìˆìŒ
                Q[i] = {op, a, b, i, a, b};
            }else{
                ans[i] = {"excursion", -1};
                Q[i] = {op, a, b, i, -1, -1};
            }
        }
    }
    
    hld.precal();   //0ì´ ë£¨íŠ¸ì¸ í•˜ë‚˜ì˜ íŠ¸ë¦¬
    for(int i=1;i<=n;i++){ //í­ê·„ì„ ê° ì„¬ì— ë„£ì–´ì¤Œ
        hld.st.update(hld.in[i], P[i], 1, 0, MAXSIZE);
    }
    
    
    for(int i=q;i>=1;i--){
        if(Q[i].op=="bridge") continue;
	        if(Q[i].op=="penguins"){
            hld.st.update(hld.in[Q[i].a], Q[i].p, 1, 0, MAXSIZE);
            ans[Q[i].idx] = {Q[i].op, 0};
        }else{
            if(Q[i].p==-1) continue;
            ans[Q[i].idx] = {Q[i].op, hld.query(Q[i].a, Q[i].b)};
        }
    }
    
    for(int i=1;i<=q;i++){
        if(ans[i].xx=="bridge"){
            if(ans[i].yy) cout << "yes\n";
            else cout << "no\n";
        }else if(ans[i].xx=="penguins"){
            continue;
        }else{
            if(ans[i].yy==-1) cout << "impossible\n";
            else cout << ans[i].yy << '\n';
        }
    }
}
```
